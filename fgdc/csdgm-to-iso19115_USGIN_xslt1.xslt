<?xml version="1.0" encoding="UTF-8"?>
<!--
======================================================================
	 FGDC CSDGM to ISO 19115 Transform version 2.0 using XPath 2.0
	USGIN v1.0

	 This is the XML Style sheet that transforms metadata conforming to the Content Standards for Digital Geospatial Metadata of the Federal Geographic Data Committee 
	 June 1998 FGDC-STD-001-1998 version to the ISO 19115:2003(E).  This stylesheet can be applied to FGDC CSDGM XML to generate ISO 19115 XML.

	 Original XSLT was generated by Altova MapForce 2009sp1. 

	 Authors:
	     Original XSLT is the product of a collaboration of the Metadata Transform Working Group. For further information, please contact NOAA's National Coastal Data 
	     Development Center (NCDDC).
			Toll Free: 866.732.2382
			E-mail: ncddcmetadata@noaa.gov

	 Distribution liability on original XSLT:
		 NOAA makes no warranty regarding these data, expressed or implied, nor does the fact of distribution constitute such a warranty. NOAA, NESDIS, 
		 NODC and NCDDC cannot assume liability for any damages caused by any errors or omissions in these data, nor as a result of the failure of these data 
		 to function on a particular system. These files were developed for opensource uses.

	Original auto-generated XSLT extensively modified by Stephen Richard and Leahanna Musil, USGIN to make the operation more intelligible and maintainable, 
		adopt for USGIN ISO metadata conventions. Spatial reference and entity-attribute information is put into the abstract as free text.

 Revisions:sta
	     20091028 (JLM) Namespaces were corrected to avoid duplicates.
							 xmlns:n="http://www.isotc211.org/2005/gfc" was changed
							 to xmlns:gfc="http://www.isotc211.org/2005/gfc" and
							 xmlns:n="http://www.opengis.net/gml/3.2" was changed to
							 xmlns:gml="http://www.opengis.net/gml/3.2". All used "n:" 
							 namespaces were changed to "gml:". 
		 20091120 (JLM) CodeLists were edited to remove extra quotes and other.
							 undesired characters. CodeLists were checked to ensure 
							 inclusion of domian codes. Edits were also made to remove 
							 un-used elements. FGDC CSDGM elements horizpa/horizpar and 
							 vertacc/vertaccr were changed from being mapped to gml:id to 
							 gml:CoventionalUnit. Single Date Time Period of contect was
							 added to mapping. Multiple Dates will replace if single date 
							 is empty. Duplicates of axisDimensionsProperties is not
							 allowed to repeat. To solve this, MD_GridSpatialRepresentation
							 was repeated. Cell Geometry Code information was also added.
SMR 2012-01-27 comment out gmd:extendedElementInformation
SMR 2012-01-28 edit xslt to make it more intelligible and maintainable. Give variables more 
							reasonable names, remove spurious type casting, add comments	
SMR 2014-11-20  This XSLT does not transform Extensions for Remote Sensing Metadata, FGDC-STD-012-2002
							To Do- add tests to recognize and handle remote sensing extensions.
SMR 2014-11-23 Start painful conversion to work with XSLT v1.0 for geoportal
-->
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:gco="http://www.isotc211.org/2005/gco" xmlns:gfc="http://www.isotc211.org/2005/gfc" xmlns:gmd="http://www.isotc211.org/2005/gmd" xmlns:gmx="http://www.isotc211.org/2005/gmx" xmlns:gsr="http://www.isotc211.org/2005/gsr" xmlns:gss="http://www.isotc211.org/2005/gss" xmlns:gts="http://www.isotc211.org/2005/gts" xmlns:gml="http://www.opengis.net/gml" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:vmf="http://www.altova.com/MapForce/UDF/vmf" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:grp="http://www.altova.com/Mapforce/grouping" xmlns:usgin="http://resources.usgin.org/xslt/FGDC2ISO" exclude-result-prefixes="fn grp vmf xs xsi xsl" xmlns="http://www.opengis.net/gml">
	<!-- ********************** templates by SMR   **************************** -->
	<xsl:template name="usgin:dateFormat">
		<xsl:param name="inputDate"/>
		<xsl:param name="inputTime"/>
		<!-- var_DateString will contain either 'nilAAAAA' where AAAA is a nilReason, a valid xs:dateTime, or it will contain a valid Date in format YYYY-MM-DD -->
		<xsl:variable name="currentDateTime">
			<xsl:value-of select="string('2014-12-31T12:00:00Z')"/>
		</xsl:variable>
		<!-- a brute force, incomplete test for DateTime for xslt 1.0 -->
		<xsl:variable name="castableAsDateTime">
			<xsl:value-of select="(substring($inputDate,5,1)='-') and (substring($inputDate,8,1)='-') and (substring($inputDate,11,1)='T') and (substring($inputDate,14,1)=':') and (substring($inputDate,17,1)=':')"/>
		</xsl:variable>
			<xsl:variable name="var_DateString">
			<xsl:choose>
				<xsl:when test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string($inputDate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string($inputDate))), 'unpublished'))">
					<!-- xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string(fn:normalize-space(fn:string(.)))"/></xsl:attribute -->
					<xsl:value-of select="fn:concat('nil',fn:string($inputDate))"/>
				</xsl:when>
				<xsl:when test="fn:contains(fn:lower-case(fn:normalize-space(fn:string($inputDate))), 'present')">
					<!--gco:DateTime -->
					<xsl:value-of select="$currentDateTime"/>
					<!-- /gco:DateTime -->
				</xsl:when>
				<xsl:when test="($castableAsDateTime)">
					<!-- gco:DateTime -->
					<xsl:value-of select="fn:string($inputDate)"/>
					<!-- /gco:DateTime -->
				</xsl:when>
				<!-- convert YYYYMMDD format to YYYY-MM-DD format -->
				<xsl:otherwise>
					<xsl:variable name="var_dateString_result" >
						<xsl:choose>
							<xsl:when test="string-length(fn:normalize-space(fn:string($inputDate)))=8">
								<xsl:value-of select="fn:concat(fn:substring(fn:normalize-space(fn:string($inputDate)), 0, 5), '-', fn:substring(fn:normalize-space(fn:string($inputDate)), 5, 2), '-',fn:substring(fn:normalize-space(fn:string($inputDate)), 7, 2))"/>
							</xsl:when>
							<xsl:when test="string-length(fn:normalize-space(fn:string($inputDate)))=6">
								<xsl:value-of select="fn:concat(fn:substring(fn:normalize-space(fn:string($inputDate)), 0, 5), '-', fn:substring(fn:normalize-space(fn:string($inputDate)), 5, 2), '-01')"/>
							</xsl:when>
							<xsl:when test="string-length(fn:normalize-space(fn:string($inputDate)))=4">
								<xsl:value-of select="fn:concat(fn:substring(fn:normalize-space(fn:string($inputDate)), 0, 5), '-01-01')"/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:value-of select="fn:string('nilmissing')"/>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					<xsl:variable name="castableAsDate">
						<xsl:value-of select="(substring($inputDate,5,1)='-') and (substring($inputDate,8,1)='-')"/>
					</xsl:variable>
					<xsl:choose>
						<xsl:when test="$castableAsDate">
							<xsl:value-of select="$var_dateString_result"/>
						</xsl:when>
						<xsl:otherwise>
							<!-- date format is screwy, put in default value -->
							<xsl:value-of select="fn:string('nilmissing')"/>
							<!-- xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string('InvalidValue')"/></xsl:attribute>
							<gco:DateTime>1900-01-01T12:00:00Z</gco:DateTime -->
						</xsl:otherwise>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<!-- done with date, either is nilAAAAA, 0000, a valid xs:dateTime, or a valid xs:date -->
		<!-- now need to process input time  -->
		<xsl:variable name="var_timeString">
			<!-- xsl:if test="fn:exists($inputTime)" -->
			<xsl:choose>
				<xsl:when test="(fn:upper-case(fn:string(.))='UNKNOWN')">
					<xsl:value-of select="xs:string('12:00:00')"/>
				</xsl:when>
				<xsl:when test="string-length($inputTime)=6">
					<xsl:value-of select="fn:concat(fn:substring(fn:string($inputTime), 0, 3), ':', fn:substring(fn:string($inputTime),3,2), ':', fn:substring(fn:string($inputTime), 5, 2))"/>
				</xsl:when>
				<xsl:when test="string-length($inputTime)=4">
					<xsl:value-of select="fn:concat(fn:substring(fn:string($inputTime), 0, 3), ':', fn:substring(fn:string($inputTime),3,2), ':00')"/>
				</xsl:when>
				<xsl:when test="string-length($inputTime)=2">
					<xsl:value-of select="fn:concat(fn:substring(fn:string($inputTime), 0, 3), ':00:00')"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="xs:string('12:00:00')"/>
				</xsl:otherwise>
			</xsl:choose>
			<!-- /xsl:for-each-->
		</xsl:variable>
		<!-- now merge date string with time string (if it exists) -->
		<xsl:choose>
			<xsl:when test="starts-with(xs:string($var_DateString),'nil')">
				<xsl:attribute name="gco:nilReason"><xsl:value-of select="substring-after($var_DateString,'nil')"/></xsl:attribute>
				<gco:DateTime>1900-01-01T12:00:00</gco:DateTime>
			</xsl:when>
			<xsl:when test="$castableAsDateTime">
				<gco:DateTime>
					<xsl:value-of select="fn:string($var_DateString)"/>
				</gco:DateTime>
			</xsl:when>
			<xsl:when test="fn:exists($var_DateString) and (fn:string-length($var_DateString)=10) and (fn:string-length($var_timeString)=8)">
				<gco:DateTime>
					<xsl:value-of select="fn:concat(fn:string($var_DateString),'T',fn:string($var_timeString))"/>
				</gco:DateTime>
			</xsl:when>
			<xsl:when test="fn:exists($var_DateString) and (fn:string-length($var_DateString)=10)  and not(fn:string-length($var_timeString)=8)">
				<gco:DateTime>
					<xsl:value-of select="fn:concat(fn:string($var_DateString),'T12:00:00')"/>
				</gco:DateTime>
			</xsl:when>
			<xsl:otherwise>
				<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string('missing')"/></xsl:attribute>
				<gco:DateTime>1900-01-01T12:00:00</gco:DateTime>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="usgin:TimePositionFormat">
		<xsl:param name="inputDate"/>
		<xsl:param name="inputTime"/>
		<!-- var_DateString will contain either 'nilAAAAA' where AAAA is a nilReason, a valid xs:dateTime, or it will contain a valid Date in format YYYY-MM-DD -->
		<xsl:variable name="castableAsDateTime">
			<xsl:value-of select="(substring($inputDate,5,1)='-') and (substring($inputDate,8,1)='-') and (substring($inputDate,11,1)='T') and (substring($inputDate,14,1)=':') and (substring($inputDate,17,1)=':')"/>
		</xsl:variable>
		<xsl:variable name="currentDateTime">
			<xsl:value-of select="string('2014-12-31T12:00:00Z')"/>
		</xsl:variable>
		<xsl:variable name="var_DateString">
			<xsl:choose>
				<xsl:when test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string($inputDate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string($inputDate))), 'unpublished'))">
					<!-- xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string(fn:normalize-space(fn:string(.)))"/></xsl:attribute -->
					<xsl:value-of select="fn:concat('nil',fn:string($inputDate))"/>
				</xsl:when>
				<xsl:when test="fn:contains(fn:lower-case(fn:normalize-space(fn:string($inputDate))), 'present')">
					<!--gco:DateTime -->
					<xsl:value-of select="$currentDateTime"/>
					<!-- /gco:DateTime -->
				</xsl:when>
				<xsl:when test="($castableAsDateTime)">
					<!-- gco:DateTime -->
					<xsl:value-of select="fn:string($inputDate)"/>
					<!-- /gco:DateTime -->
				</xsl:when>
				<!-- convert YYYYMMDD format to YYYY-MM-DD format -->
				<xsl:otherwise>
					<xsl:variable name="var_dateString_result" >
						<xsl:choose>
							<xsl:when test="string-length(fn:normalize-space(fn:string($inputDate)))=8">
								<xsl:value-of select="fn:concat(fn:substring(fn:normalize-space(fn:string($inputDate)), 0, 5), '-', fn:substring(fn:normalize-space(fn:string($inputDate)), 5, 2), '-',fn:substring(fn:normalize-space(fn:string($inputDate)), 7, 2))"/>
							</xsl:when>
							<xsl:when test="string-length(fn:normalize-space(fn:string($inputDate)))=6">
								<xsl:value-of select="fn:concat(fn:substring(fn:normalize-space(fn:string($inputDate)), 0, 5), '-', fn:substring(fn:normalize-space(fn:string($inputDate)), 5, 2), '-01')"/>
							</xsl:when>
							<xsl:when test="string-length(fn:normalize-space(fn:string($inputDate)))=4">
								<xsl:value-of select="fn:concat(fn:substring(fn:normalize-space(fn:string($inputDate)), 0, 5), '-01-01')"/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:value-of select="fn:string('nilmissing')"/>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					<xsl:variable name="castableAsDate">
						<xsl:value-of select="(substring($inputDate,5,1)='-') and (substring($inputDate,8,1)='-')"/>
					</xsl:variable>
					<xsl:choose>
						<xsl:when test="($castableAsDate)">
							<xsl:value-of select="$var_dateString_result"/>
						</xsl:when>
						<xsl:otherwise>
							<!-- date format is screwy, put in default value -->
							<xsl:value-of select="fn:string('nilmissing')"/>
							<!-- xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string('InvalidValue')"/></xsl:attribute>
							<gco:DateTime>1900-01-01T12:00:00Z</gco:DateTime -->
						</xsl:otherwise>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<!-- done with date, either is nilAAAAA, 0000, a valid xs:dateTime, or a valid xs:date -->
		<!-- now need to process input time  -->
		<xsl:variable name="var_timeString">
			<!-- xsl:if test="fn:exists($inputTime)" -->
			<xsl:choose>
				<xsl:when test="(fn:upper-case(fn:string(.))='UNKNOWN')">
					<xsl:value-of select="xs:string('12:00:00')"/>
				</xsl:when>
				<xsl:when test="string-length($inputTime)=6">
					<xsl:value-of select="fn:concat(fn:substring(fn:string($inputTime), 0, 3), ':', fn:substring(fn:string($inputTime),3,2), ':', fn:substring(fn:string($inputTime), 5, 2))"/>
				</xsl:when>
				<xsl:when test="string-length($inputTime)=4">
					<xsl:value-of select="fn:concat(fn:substring(fn:string($inputTime), 0, 3), ':', fn:substring(fn:string($inputTime),3,2), ':00')"/>
				</xsl:when>
				<xsl:when test="string-length($inputTime)=2">
					<xsl:value-of select="fn:concat(fn:substring(fn:string($inputTime), 0, 3), ':00:00')"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="xs:string('12:00:00')"/>
				</xsl:otherwise>
			</xsl:choose>
			<!-- /xsl:for-each-->
		</xsl:variable>
		<!-- now merge date string with time string (if it exists) -->
		<xsl:choose>
			<xsl:when test="starts-with(xs:string($var_DateString),'nil')">
				<xsl:value-of select="fn:string('indeterminate')"/>
			</xsl:when>
			<xsl:when test="($castableAsDateTime)">
				<xsl:value-of select="fn:string($var_DateString)"/>
			</xsl:when>
			<xsl:when test="fn:exists($var_DateString) and (fn:string-length($var_DateString)=10) and (fn:string-length($var_timeString)=8)">
				<xsl:value-of select="fn:concat(fn:string($var_DateString),'T',fn:string($var_timeString))"/>
			</xsl:when>
			<xsl:when test="fn:exists($var_DateString) and (fn:string-length($var_DateString)=10)  and not(fn:string-length($var_timeString)=8)">
				<xsl:value-of select="fn:concat(fn:string($var_DateString),'T12:00:00')"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="fn:string('indeterminate')"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="usgin:contactName">
		<xsl:param name="inputPersonNode"/>
		<xsl:param name="inputOrganizationNode"/>
		<xsl:param name="inputPositionNode"/>
		<!-- handler for individual, organization, position name -->
		<!-- done scraping content for contact name -->
		<!-- now populate the elements count(individualName + OrganisationName + positionName) must be >0 -->
		<!-- check that at least one got populated -->
		<xsl:choose>
			<xsl:when test="fn:exists($inputPersonNode) or fn:exists($inputOrganizationNode) or fn:exists($inputPositionNode)">
				<xsl:if test="fn:exists($inputPersonNode)">
					<gmd:individualName>
						<gco:CharacterString>
							<xsl:for-each select="$inputPersonNode">
								<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
								<xsl:if test="(count($inputPersonNode)>1)">
									<xsl:value-of select="xs:string(' ')"/>
								</xsl:if>
							</xsl:for-each>
						</gco:CharacterString>
					</gmd:individualName>
				</xsl:if>
				<xsl:if test="fn:exists($inputOrganizationNode)">
					<gmd:organisationName>
						<gco:CharacterString>
							<xsl:for-each select="$inputOrganizationNode">
								<xsl:value-of select="fn:concat(fn:normalize-space(xs:string(.)), ' ')"/>
								<!-- xsl:if test="(count($inputOrganizationNode)>1)">
									<xsl:value-of select="xs:string(' ')"/>
								</xsl:if -->
							</xsl:for-each>
						</gco:CharacterString>
					</gmd:organisationName>
				</xsl:if>
				<xsl:if test="fn:exists($inputPositionNode)">
					<xsl:for-each select="$inputPositionNode">
						<gmd:positionName>
							<gco:CharacterString>
								<xsl:for-each select="$inputPositionNode">
									<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
									<xsl:if test="(count($inputPositionNode)>1)">
										<xsl:value-of select="xs:string(' ')"/>
									</xsl:if>
								</xsl:for-each>
							</gco:CharacterString>
						</gmd:positionName>
					</xsl:for-each>
				</xsl:if>
			</xsl:when>
			<!-- if at least one is present check -->
			<!-- no contact name -->
			<xsl:otherwise>
				<gmd:organisationName>
					<gco:CharacterString>metadata contact name, organisation and position are missing</gco:CharacterString>
				</gmd:organisationName>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<!-- *************************************************** -->
	<xsl:template name="usgin:addressFormat">
		<xsl:param name="inputAddr"/>
		<!-- don't put in postal address elements unless at least one has a value -->
		<xsl:if test="fn:exists($inputAddr/address) or fn:exists($inputAddr/city) or fn:exists($inputAddr/state) or fn:exists($inputAddr/postal) or fn:exists($inputAddr/country)">
			<xsl:for-each select="$inputAddr/address">
				<gmd:deliveryPoint>
					<gco:CharacterString>
						<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
					</gco:CharacterString>
				</gmd:deliveryPoint>
			</xsl:for-each>
			<xsl:for-each select="$inputAddr/city">
				<gmd:city>
					<gco:CharacterString>
						<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
					</gco:CharacterString>
				</gmd:city>
			</xsl:for-each>
			<xsl:for-each select="$inputAddr/state">
				<gmd:administrativeArea>
					<gco:CharacterString>
						<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
					</gco:CharacterString>
				</gmd:administrativeArea>
			</xsl:for-each>
			<xsl:for-each select="$inputAddr/postal">
				<gmd:postalCode>
					<gco:CharacterString>
						<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
					</gco:CharacterString>
				</gmd:postalCode>
			</xsl:for-each>
			<xsl:for-each select="$inputAddr/country">
				<gmd:country>
					<gco:CharacterString>
						<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
					</gco:CharacterString>
				</gmd:country>
			</xsl:for-each>
		</xsl:if>
	</xsl:template>
	<!-- ********************************************************** -->
	<xsl:template name="usgin:telephoneFormat">
		<xsl:param name="telNode"/>
		<xsl:variable name="var_voicePhone_exists" >
			<xsl:if test="fn:exists($telNode/cntvoice)">
				<xsl:for-each select="$telNode/cntvoice">
					<xsl:value-of select="xs:string(.)"/>
				</xsl:for-each>
			</xsl:if>
		</xsl:variable>
		<xsl:variable name="var_faxPhone_exists" >
			<xsl:if test="fn:exists($telNode/cntfax)">
				<xsl:for-each select="$telNode/cntfax">
					<xsl:value-of select="xs:string(.)"/>
				</xsl:for-each>
			</xsl:if>
		</xsl:variable>
		<!-- done checking  for phone number existance in the source record -->
		<!-- do the phone number(s) -->
		<xsl:if test="fn:exists($var_voicePhone_exists) or fn:exists($var_faxPhone_exists)">
			<gmd:phone>
				<gmd:CI_Telephone>
					<xsl:if test="fn:exists($var_voicePhone_exists)">
						<gmd:voice>
							<gco:CharacterString>
								<xsl:for-each select="$var_voicePhone_exists">
									<xsl:value-of select="fn:concat(fn:normalize-space(.),' ')"/>
								</xsl:for-each>
							</gco:CharacterString>
						</gmd:voice>
					</xsl:if>
					<xsl:if test="fn:exists($var_faxPhone_exists)">
						<gmd:facsimile>
							<gco:CharacterString>
								<xsl:for-each select="$var_faxPhone_exists">
									<xsl:value-of select="fn:concat(fn:normalize-space(.),' ')"/>
								</xsl:for-each>
							</gco:CharacterString>
						</gmd:facsimile>
					</xsl:if>
				</gmd:CI_Telephone>
			</gmd:phone>
		</xsl:if>
	</xsl:template>
	<!-- ********************************************************** -->
	<xsl:template name="usgin:emailFormat">
		<xsl:param name="emailNode"/>
		<xsl:variable name="var_eMail_exists" >
			<xsl:if test="fn:exists($emailNode/cntemail)">
				<xsl:for-each select="$emailNode/cntemail">
					<xsl:value-of select="xs:string(.)"/>
				</xsl:for-each>
			</xsl:if>
		</xsl:variable>
		<!-- Set this up so that some value gets inserted -->
		<gmd:electronicMailAddress>
			<xsl:choose>
				<xsl:when test="fn:exists($var_eMail_exists)">
					<gco:CharacterString>
						<xsl:for-each select="$var_eMail_exists">
							<xsl:value-of select="fn:concat(fn:normalize-space(.),' ')"/>
						</xsl:for-each>
						<!-- xsl:value-of select="fn:normalize-space($var_eMail_exists)"/-->
					</gco:CharacterString>
				</xsl:when>
				<xsl:otherwise>
					<gco:CharacterString>eMail@missing.org</gco:CharacterString>
				</xsl:otherwise>
			</xsl:choose>
		</gmd:electronicMailAddress>
	</xsl:template>
	<!--  section 1, functions to translate generic codelist terms into ISO codeListValue and codelist code -->
	<xsl:template name="vmf:geometryType">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='PIXEL'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='GRID CELL'">
				<xsl:value-of select="'area'"/>
			</xsl:when>
			<xsl:when test="$input='VOXEL'">
				<xsl:value-of select="'area'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:geometryCode">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='PIXEL'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='GRID CELL'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='VOXEL'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:geometryType2">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='ENTITY POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='LABEL POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='AREA POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='NODE, PLANAR GRAPH'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$input='NODE, NETWORK'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$input='STRING'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='LINK'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='COMPLETE CHAIN'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='AREA CHAIN'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='NETWORK CHAIN, PLANAR GRAPH'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$input='NETWORK CHAIN, NONPLANAR GRAPH'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='CIRCULAR ARC, THREE POINT CENTER'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='ELLIPTICAL ARC'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='UNIFORM B-SPLINE'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='PIECEWISE BEZIER'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='RING WITH MIXED COMPOSITION'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF STRINGS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF CHAINS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF ARCS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='G-POLYGON'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input='GT-POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input='GT-POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:geometryCode2">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='ENTITY POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='LABEL POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='AREA POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='NODE, PLANAR GRAPH'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='NODE, NETWORK'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='STRING'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='LINK'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='COMPLETE CHAIN'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='AREA CHAIN'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='NETWORK CHAIN, PLANAR GRAPH'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='NETWORK CHAIN, NONPLANAR GRAPH'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='CIRCULAR ARC, THREE POINT CENTER'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='ELLIPTICAL ARC'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='UNIFORM B-SPLINE'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='PIECEWISE BEZIER'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='RING WITH MIXED COMPOSITION'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF STRINGS'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF CHAINS'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF ARCS'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='G-POLYGON'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='GT-POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='GT-POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:unknown">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input='UNKNOWN'">
				<xsl:value-of select="'unknown'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:docType">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input='ATLAS'">
				<xsl:value-of select="'mapHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='AUDIO'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$input='DIAGRAM'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$input='DOCUMENT'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$input='GLOBE'">
				<xsl:value-of select="'documentHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='MAP'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$input='PRINTED MAP'">
				<xsl:value-of select="'mapHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='MODEL'">
				<xsl:value-of select="'modelDigital'"/>
			</xsl:when>
			<xsl:when test="$input='PHYSICAL MODELl'">
				<xsl:value-of select="'modelHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='MULTIMEDIA PRESENTATION'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$input='PROFILE'">
				<xsl:value-of select="'profileDigital'"/>
			</xsl:when>
			<xsl:when test="$input='CROSS-SECTION'">
				<xsl:value-of select="'profileHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='RASTER DIGITAL DATA'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$input='REMOTE-SENSING IMAGE'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$input='SECTION'">
				<xsl:value-of select="'profileHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='SPREADSHEET'">
				<xsl:value-of select="'tableDigital'"/>
			</xsl:when>
			<xsl:when test="$input='TABULAR DIGITAL DATA'">
				<xsl:value-of select="'tableDigital'"/>
			</xsl:when>
			<xsl:when test="$input='VECTOR DIGITAL DATA'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$input='VIDEO'">
				<xsl:value-of select="'videoDigital'"/>
			</xsl:when>
			<xsl:when test="$input='VIEW'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$input='DATABASE'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:docCode">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input='ATLAS'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='AUDIO'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='DIAGRAM'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='DOCUMENT'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='GLOBE'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='MAP'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='PRINTED MAP'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='MODEL'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='PHYSICAL MODELl'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input='MULTIMEDIA PRESENTATION'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='PROFILE'">
				<xsl:value-of select="'009'"/>
			</xsl:when>
			<xsl:when test="$input='CROSS-SECTION'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input='RASTER DIGITAL DATA'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='REMOTE-SENSING IMAGE'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='SECTION'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input='SPREADSHEET'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='TABULAR DIGITAL DATA'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='VECTOR DIGITAL DATA'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='VIDEO'">
				<xsl:value-of select="'013'"/>
			</xsl:when>
			<xsl:when test="$input='VIEW'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='DATABASE'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:statusType">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input='COMPLETED'">
				<xsl:value-of select="'completed'"/>
			</xsl:when>
			<xsl:when test="$input='COMPLETE'">
				<xsl:value-of select="'completed'"/>
			</xsl:when>
			<xsl:when test="$input='ARCHIVED'">
				<xsl:value-of select="'historicalArchive'"/>
			</xsl:when>
			<xsl:when test="$input='OBSOLETE'">
				<xsl:value-of select="'obsolete'"/>
			</xsl:when>
			<xsl:when test="$input='ON GOING'">
				<xsl:value-of select="'onGoing'"/>
			</xsl:when>
			<xsl:when test="$input='CONTINUALLY'">
				<xsl:value-of select="'onGoing'"/>
			</xsl:when>
			<xsl:when test="$input='PLANNED'">
				<xsl:value-of select="'planned'"/>
			</xsl:when>
			<xsl:when test="$input='REQUIRED'">
				<xsl:value-of select="'required'"/>
			</xsl:when>
			<xsl:when test="$input='IN PROGRESS'">
				<xsl:value-of select="'underDevelopment'"/>
			</xsl:when>
			<xsl:when test="$input='IN WORK'">
				<xsl:value-of select="'underDevelopment'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:statusCode">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input='COMPLETED'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='COMPLETE'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='ARCHIVED'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='OBSOLETE'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='ON GOING'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='CONTINUALLY'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='PLANNED'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='REQUIRED'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='IN PROGRESS'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='IN WORK'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:updateFrequency">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input='CONTINUALLY'">
				<xsl:value-of select="'continual'"/>
			</xsl:when>
			<xsl:when test="$input='DAILY'">
				<xsl:value-of select="'daily'"/>
			</xsl:when>
			<xsl:when test="$input='WEEKLY'">
				<xsl:value-of select="'weekly'"/>
			</xsl:when>
			<xsl:when test="$input='TWO WEEKS'">
				<xsl:value-of select="'fortnightly'"/>
			</xsl:when>
			<xsl:when test="$input='MONTHLY'">
				<xsl:value-of select="'monthly'"/>
			</xsl:when>
			<xsl:when test="$input='QUARTERLY'">
				<xsl:value-of select="'quarterly'"/>
			</xsl:when>
			<xsl:when test="$input='BIANNUALLY'">
				<xsl:value-of select="'biannually'"/>
			</xsl:when>
			<xsl:when test="$input='ANNUALLY'">
				<xsl:value-of select="'annually'"/>
			</xsl:when>
			<xsl:when test="$input='YEARLY'">
				<xsl:value-of select="'annually'"/>
			</xsl:when>
			<xsl:when test="$input='AS NEEDED'">
				<xsl:value-of select="'asNeeded'"/>
			</xsl:when>
			<xsl:when test="$input='IRREGULAR'">
				<xsl:value-of select="'irregular'"/>
			</xsl:when>
			<xsl:when test="$input='NOT PLANNED'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:when test="$input='NONE PLANNED'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:when test="$input='UNKNOWN'">
				<xsl:value-of select="'unknown'"/>
			</xsl:when>
			<xsl:when test="$input='NONE'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:updateFrequencyCode">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input='CONTINUALLY'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='DAILY'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='WEEKLY'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='TWO WEEKS'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='MONTHLY'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='QUARTERLY'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='BIANNUALLY'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='ANNUALLY'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input='YEARLY'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input='AS NEEDED'">
				<xsl:value-of select="'009'"/>
			</xsl:when>
			<xsl:when test="$input='IRREGULAR'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input='NOT PLANNED'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='NONE PLANNED'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='UNKNOWN'">
				<xsl:value-of select="'012'"/>
			</xsl:when>
			<xsl:when test="$input='NONE'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'012'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:securityClassType">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input='CONFIDENTIAL'">
				<xsl:value-of select="'confidential'"/>
			</xsl:when>
			<xsl:when test="$input='SECRET'">
				<xsl:value-of select="'secret'"/>
			</xsl:when>
			<xsl:when test="$input='TOP SECRET'">
				<xsl:value-of select="'topSecret'"/>
			</xsl:when>
			<xsl:when test="$input='UNCLASSIFIED'">
				<xsl:value-of select="'unclassified'"/>
			</xsl:when>
			<xsl:when test="$input='RESTRICTED'">
				<xsl:value-of select="'restricted'"/>
			</xsl:when>
			<xsl:when test="$input='SECERT'">
				<xsl:value-of select="'secret'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:securityClassCode">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input='CONFIDENTIAL'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='SECRET'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='TOP SECRET'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='UNCLASSIFIED'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='RESTRICTED'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='SECERT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:spatialRepresentationType">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'vector'"/>
			</xsl:when>
			<xsl:when test="$input='VECTOR'">
				<xsl:value-of select="'vector'"/>
			</xsl:when>
			<xsl:when test="$input='RASTER'">
				<xsl:value-of select="'grid'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:spatialRepresentationCode">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input='vector'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='grid'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:mediumType">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input='CD-ROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:when test="$input='DVD'">
				<xsl:value-of select="'dvd'"/>
			</xsl:when>
			<xsl:when test="$input='DVD-ROM'">
				<xsl:value-of select="'dvdRom'"/>
			</xsl:when>
			<xsl:when test="$input='3-1/2 INCH FLOPPY DISK'">
				<xsl:value-of select="'3halfInchFloppy'"/>
			</xsl:when>
			<xsl:when test="$input='5-1/4 INCH FLOPPY'">
				<xsl:value-of select="'5quarterInchFloppy'"/>
			</xsl:when>
			<xsl:when test="$input='7-TRACK TAPE'">
				<xsl:value-of select="'7trackTape'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK TAPE'">
				<xsl:value-of select="'9trackType'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK'">
				<xsl:value-of select="'9trackTape'"/>
			</xsl:when>
			<xsl:when test="$input='3480 CARTRIDGE'">
				<xsl:value-of select="'3480Cartridge'"/>
			</xsl:when>
			<xsl:when test="$input='3490 CARTRIDGE'">
				<xsl:value-of select="'3490Cartridge'"/>
			</xsl:when>
			<xsl:when test="$input='3580 CARTRIDGE'">
				<xsl:value-of select="'3580Cartridge'"/>
			</xsl:when>
			<xsl:when test="$input='4 MM CARTRIDGE'">
				<xsl:value-of select="'4mmCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$input='8 MM CARTRIDGE'">
				<xsl:value-of select="'8mmCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$input='1/4 INCH CARTRIDGE'">
				<xsl:value-of select="'1quarterInchCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$input='DIGITAL LINEAR TAPE'">
				<xsl:value-of select="'digitalLinearTape'"/>
			</xsl:when>
			<xsl:when test="$input='ONLINE'">
				<xsl:value-of select="'onLine'"/>
			</xsl:when>
			<xsl:when test="$input='SATELLITE'">
				<xsl:value-of select="'satellite'"/>
			</xsl:when>
			<xsl:when test="$input='TELEPHONE LINK'">
				<xsl:value-of select="'telephoneLink'"/>
			</xsl:when>
			<xsl:when test="$input='HARDCOPY'">
				<xsl:value-of select="'hardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='CD ROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:when test="$input='CDROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:mediumCode">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input='CD-ROM'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='DVD'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='DVD-ROM'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='3-1/2 INCH FLOPPY DISK'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='5-1/4 INCH FLOPPY'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='7-TRACK TAPE'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK TAPE'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='3480 CARTRIDGE'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input='3490 CARTRIDGE'">
				<xsl:value-of select="'009'"/>
			</xsl:when>
			<xsl:when test="$input='3580 CARTRIDGE'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input='4 MM CARTRIDGE'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='8 MM CARTRIDGE'">
				<xsl:value-of select="'012'"/>
			</xsl:when>
			<xsl:when test="$input='1/4 INCH CARTRIDGE'">
				<xsl:value-of select="'013'"/>
			</xsl:when>
			<xsl:when test="$input='DIGITAL LINEAR TAPE'">
				<xsl:value-of select="'014'"/>
			</xsl:when>
			<xsl:when test="$input='ONLINE'">
				<xsl:value-of select="'015'"/>
			</xsl:when>
			<xsl:when test="$input='SATELLITE'">
				<xsl:value-of select="'016'"/>
			</xsl:when>
			<xsl:when test="$input='TELEPHONE LINK'">
				<xsl:value-of select="'017'"/>
			</xsl:when>
			<xsl:when test="$input='HARDCOPY'">
				<xsl:value-of select="'018'"/>
			</xsl:when>
			<xsl:when test="$input='CD ROM'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='CDROM'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:encodingType">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input='CPIO'">
				<xsl:value-of select="'cpio'"/>
			</xsl:when>
			<xsl:when test="$input='TAR'">
				<xsl:value-of select="'tar'"/>
			</xsl:when>
			<xsl:when test="$input='HIGH SEIRRA'">
				<xsl:value-of select="'highSierra'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660'">
				<xsl:value-of select="'iso9660'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH ROCK RIDGE'">
				<xsl:value-of select="'iso9660RockRidge'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 UNIX'">
				<xsl:value-of select="'iso9660RockRidge'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH APPLE HFS'">
				<xsl:value-of select="'iso9660AppleHFS'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 MAC'">
				<xsl:value-of select="'iso9660AppleHFS'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:encodingCode">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input='CPIO'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='TAR'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='HIGH SEIRRA'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH ROCK RIDGE'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 UNIX'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH APPLE HFS'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 MAC'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:function name="grp:sourcesUsed">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/srcused">
			<xsl:value-of select="xs:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:origins">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/origin">
			<xsl:value-of select="xs:string(xs:string(.))"/>
		</xsl:for-each>
	</xsl:function>
	<!-- end of codelist lookup functions -->
	<!--   ***** -->
	<!-- xml header stuff -->
	<xsl:namespace-alias stylesheet-prefix="gml" result-prefix="#default"/>
	<xsl:output method="xml" encoding="UTF-8" indent="yes"/>
	<!-- grouping keywords into themes -->
	<xsl:function name="grp:themektKeywords">
		<!-- themekt is theme keyword thesaurus -->
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/themekt">
			<xsl:if test="not(fn:contains(xs:string(xs:string(.)), 'ISO 19115'))">
				<xsl:value-of select="xs:string(.)"/>
			</xsl:if>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:themekeyKeyword">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/themekey">
			<xsl:value-of select="xs:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:placektKeywords">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/placekt">
			<xsl:value-of select="xs:string(xs:string(.))"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:placeKeyword">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/placekey">
			<xsl:value-of select="xs:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:strataktKeywords">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/stratkt">
			<xsl:value-of select="xs:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:strataKeyword">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/stratkey">
			<xsl:value-of select="xs:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<!-- tempkt is temporal keyword thesaurus -->
	<xsl:function name="grp:tempktKeywords">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/tempkt">
			<xsl:value-of select="xs:string(xs:string(.))"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:temporalKeyword">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/tempkey">
			<xsl:value-of select="xs:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:calendarDate">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/caldate">
			<xsl:value-of select="xs:string(xs:string(.))"/>
		</xsl:for-each>
	</xsl:function>
	<!-- end of group definition functions -->
	<!--  ***************** -->
	<!-- Start actual output metadata record here, let's get down to business -->
	<xsl:template match="/">
		<xsl:variable name="currentDateTime">
			<xsl:value-of select="string('2014-12-31T12:00:00Z')"/>
		</xsl:variable>
		<gmd:MD_Metadata>
			<xsl:attribute name="xsi:schemaLocation"><xsl:value-of select="'http://www.isotc211.org/2005/gmd http://schemas.opengis.net/iso/19139/20060504/gmd/gmd.xsd'"/></xsl:attribute>
			<xsl:variable name="var_InputRootNode" select="."/>
			<xsl:variable name="var_metadataRoot" select="./metadata"/>
			<!-- these all have fixed values for now -->

			<gmd:fileIdentifier>
				<gco:CharacterString>
					<xsl:choose>
						<xsl:when test="fn:exists($var_metadataRoot/idinfo/citation/citeinfo/onlink[1])">
							<xsl:value-of select="fn:normalize-space(fn:substring-after(xs:string($var_metadataRoot/idinfo/citation/citeinfo/onlink[1]),'//'))"/>
						</xsl:when>
						<xsl:when test="fn:exists($var_metadataRoot/distinfo[1]/resdesc)">
							<xsl:value-of select="fn:replace(fn:normalize-space(xs:string($var_metadataRoot/distinfo[1]/resdesc)),' ','')"/>
						</xsl:when>
						<xsl:otherwise>
							<!-- put in something, USGIN profile requires... -->
							<xsl:value-of select="fn:concat(fn:string('http://www.opengis.net/def/nil/OGC/0/missing/'),$currentDateTime)"/>
						</xsl:otherwise>
					</xsl:choose>	
				</gco:CharacterString>
			</gmd:fileIdentifier>
			<gmd:language>
				<gco:CharacterString>eng</gco:CharacterString>
			</gmd:language>
			<gmd:characterSet>
				<gmd:MD_CharacterSetCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CharacterSetCode" codeListValue="utf8" codeSpace="004">utf8</gmd:MD_CharacterSetCode>
			</gmd:characterSet>
			<gmd:hierarchyLevel>
				<gmd:MD_ScopeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode" codeListValue="dataset" codeSpace="005">dataset</gmd:MD_ScopeCode>
			</gmd:hierarchyLevel>
			<!-- end fixed values, now start pulling stuff from input record -->
			<gmd:hierarchyLevelName>
				<gco:CharacterString>
					<xsl:value-of select="$var_metadataRoot/distinfo/resdesc"/>
				</gco:CharacterString>
			</gmd:hierarchyLevelName>
			<gmd:contact>
				<gmd:CI_ResponsibleParty>
					<!-- scrape input cntinfo for person and org names that might be in one of 2 places -->
					<xsl:variable name="var_contactIndividual_exists" >
						<xsl:choose>
							<xsl:when test="fn:exists($var_metadataRoot/metainfo/metc/cntinfo/cntperp/cntper)">
								<!-- old xsl:when test="fn:exists($var5_map_select_metadata)" -->
								<xsl:for-each select="$var_metadataRoot/metainfo/metc/cntinfo/cntperp/cntper">
									<xsl:value-of select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:when>
							<xsl:otherwise>
								<xsl:for-each select="$var_metadataRoot/metainfo/metc/cntinfo/cntorgp/cntper">
									<xsl:value-of select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					<!-- xsl:variable name="var16_map_select_metadata" >
							<xsl:for-each select="$var_metadataRoot/metainfo/metc/cntinfo/cntperp/cntorg">
								<xsl:value-of select="xs:string(.)"/>
							</xsl:for-each>
						</xsl:variable -->
					<xsl:variable name="var_contactOrganisation_exists" >
						<xsl:choose>
							<xsl:when test="fn:exists($var_metadataRoot/metainfo/metc/cntinfo/cntperp/cntorg)">
								<xsl:for-each select="$var_metadataRoot/metainfo/metc/cntinfo/cntperp/cntorg">
									<xsl:value-of select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:when>
							<xsl:otherwise>
								<xsl:for-each select="$var_metadataRoot/metainfo/metc/cntinfo/cntorgp/cntorg">
									<xsl:value-of select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					<!-- done scraping content for contact name -->
					<!-- now populate the elements count(individualName + OrganisationName + positionName) must be >0 -->
					<xsl:call-template name="usgin:contactName">
						<xsl:with-param name="inputPersonNode" select="$var_contactIndividual_exists"/>
						<xsl:with-param name="inputOrganizationNode" select="($var_contactOrganisation_exists)"/>
						<xsl:with-param name="inputPositionNode" select="($var_metadataRoot/metainfo/metc/cntinfo/cntpos)"/>
					</xsl:call-template>
					<gmd:contactInfo>
						<gmd:CI_Contact>
							<!--xsl:variable name="var_eMail_exists" >
								<xsl:if test="fn:exists($var_metadataRoot/metainfo/metc/cntinfo/cntemail)">
									<xsl:for-each select="$var_metadataRoot/metainfo/metc/cntinfo/cntemail">
										<xsl:value-of select="xs:string(.)"/>
									</xsl:for-each>
								</xsl:if>
							</xsl:variable -->
							<!-- done checking  for phone number existance in the source record -->
							<!-- do the phone number(s) -->
							<xsl:call-template name="usgin:telephoneFormat">
								<xsl:with-param name="telNode" select="($var_metadataRoot/metainfo/metc/cntinfo)"/>
							</xsl:call-template>
							<gmd:address>
								<gmd:CI_Address>
									<xsl:call-template name="usgin:addressFormat">
										<xsl:with-param name="inputAddr" select="$var_metadataRoot/metainfo/metc/cntinfo/cntaddr[1]"/>
									</xsl:call-template>
									<!-- done with postal address elements, now the e-mail. Set this up so that some value gets inserted -->
									<xsl:call-template name="usgin:emailFormat">
										<xsl:with-param name="emailNode" select="$var_metadataRoot/metainfo/metc/cntinfo"/>
									</xsl:call-template>
									<!--gmd:electronicMailAddress>
										<xsl:choose>
											<xsl:when test="fn:exists($var_eMail_exists)">
												<gco:CharacterString>
													<xsl:value-of select="fn:normalize-space($var_eMail_exists)"/>
												</gco:CharacterString>
											</xsl:when>
											<xsl:otherwise>
												<gco:CharacterString>
												noPhone.or.eMail@missing.org
											</gco:CharacterString>
											</xsl:otherwise>
										</xsl:choose>
									</gmd:electronicMailAddress -->
								</gmd:CI_Address>
							</gmd:address>
							<xsl:if test="fn:exists($var_metadataRoot/metainfo/metc/cntinfo/hours)">
								<gmd:hoursOfService>
									<!-- xsl:for-each select="" pull this out so don't end up withh multiple characterstring elements -->
									<gco:CharacterString>
										<xsl:value-of select="fn:normalize-space(xs:string($var_metadataRoot/metainfo/metc/cntinfo/hours))"/>
									</gco:CharacterString>
									<!-- /xsl:for-each -->
								</gmd:hoursOfService>
							</xsl:if>
							<xsl:if test="fn:exists($var_metadataRoot/metainfo/metc/cntinfo/cntinst)">
								<gmd:contactInstructions>
									<!--xsl:for-each select="" pull this out so don't end up withh multiple characterstring elements -->
									<gco:CharacterString>
										<xsl:value-of select="fn:normalize-space(xs:string($var_metadataRoot/metainfo/metc/cntinfo/cntinst))"/>
									</gco:CharacterString>
									<!-- /xsl:for-each -->
								</gmd:contactInstructions>
							</xsl:if>
						</gmd:CI_Contact>
					</gmd:contactInfo>
					<!-- role gets a fixed value; FGDC doesn't allow for different roles, so assume point of contact -->
					<gmd:role>
						<gmd:CI_RoleCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode" codeListValue="pointOfContact" codeSpace="007">pointOfContact</gmd:CI_RoleCode>
					</gmd:role>
				</gmd:CI_ResponsibleParty>
			</gmd:contact>
			<gmd:dateStamp>
				<xsl:for-each select="$var_metadataRoot/metainfo/metd">
					<xsl:call-template name="usgin:dateFormat">
						<xsl:with-param name="inputDate" select="$var_metadataRoot/metainfo/metd"/>
						<xsl:with-param name="inputTime"/>
					</xsl:call-template>
				</xsl:for-each>
			</gmd:dateStamp>
			<gmd:metadataStandardName>
				<gco:CharacterString>
					<xsl:value-of select="'ISO-USGIN'"/>
				</gco:CharacterString>
			</gmd:metadataStandardName>
			<gmd:metadataStandardVersion>
				<gco:CharacterString>
					<xsl:value-of select="'1.2'"/>
				</gco:CharacterString>
			</gmd:metadataStandardVersion>
			<!-- if there is a URL supplied in the citation for the resource, use this as the resource identifier -->
			<gmd:dataSetURI>
				<gco:CharacterString>
					<xsl:choose>
						<!-- check first for FGDC-STD-012-2002 (extensions for Remote Sensing) identifier, that would be the best... -->
						<xsl:when test="fn:exists($var_metadataRoot/idinfo/datsetid)">
							<xsl:value-of select="fn:normalize-space(xs:string($var_metadataRoot/idinfo/datsetid))"/>
						</xsl:when>
						<!-- otherwise try a couple things that might be in original FGDC CSDGM -->
						<xsl:when test="fn:exists($var_metadataRoot/idinfo/citation/citeinfo/onlink[1])">
							<xsl:value-of select="fn:normalize-space(xs:string($var_metadataRoot/idinfo/citation/citeinfo/onlink[1]))"/>
						</xsl:when>
						<xsl:when test="fn:exists($var_metadataRoot/distinfo[1]/resdesc)">
							<xsl:value-of select="fn:normalize-space(xs:string($var_metadataRoot/distinfo[1]/resdesc))"/>
						</xsl:when>
						<xsl:otherwise>
							<!-- put in something, USGIN profile requires... -->
							<xsl:value-of select="fn:concat(fn:string('http://www.opengis.net/def/nil/OGC/0/missing/'),$currentDateTime)"/>
						</xsl:otherwise>
					</xsl:choose>
				</gco:CharacterString>
			</gmd:dataSetURI>
			<!--/xsl:for-each -->
			<!-- metadata/spdoinfo spatial data information -->
			<xsl:for-each select="$var_metadataRoot">
				<xsl:for-each select="spdoinfo">
					<!-- spatial representation -->
					<xsl:for-each select="rastinfo">
						<xsl:variable name="var_rastinfoNode" select="."/>
						<gmd:spatialRepresentationInfo>
							<gmd:MD_GridSpatialRepresentation>
								<xsl:variable name="var_rowCount_exists"  select="(fn:exists(rowcount))"/>
								<xsl:variable name="var_colCount_exists"  select="(fn:exists(colcount))"/>
								<xsl:variable name="var_vrtCount_exists"  select="(fn:exists(vrtcount))"/>
								<gmd:numberOfDimensions>
									<xsl:choose>
										<xsl:when test="fn:exists(xs:string(xs:integer($var_rowCount_exists + $var_colCount_exists + $var_vrtCount_exists)))">
											<gco:Integer>
												<xsl:value-of select="xs:string(xs:integer($var_rowCount_exists + $var_colCount_exists + $var_vrtCount_exists))"/>
											</gco:Integer>
										</xsl:when>
										<xsl:otherwise>
											<gco:Integer>
												<xsl:value-of select="xs:string('1')"/>
											</gco:Integer>
										</xsl:otherwise>
									</xsl:choose>
								</gmd:numberOfDimensions>
								<!-- This for-each and the similar ones below were commented out by Ted Habermann 2011-07-26
									<xsl:for-each select="$var72_metadata/idinfo/citation/citeinfo/lworkcit">-->
								<gmd:axisDimensionProperties>
									<gmd:MD_Dimension>
										<gmd:dimensionName>
<!--											<xsl:variable name="var_hasRow"  select="(if (fn:exists($var_rastinfoNode/rowcount)) then 'row' else ())"/>-->
											<xsl:if test="fn:exists($var_rastinfoNode/rowcount)">
												<gmd:MD_DimensionNameTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode" codeListValue="row" codeSpace="001">row</gmd:MD_DimensionNameTypeCode>
											</xsl:if>
										</gmd:dimensionName>
										<xsl:if test="fn:exists($var_rastinfoNode/rowcount)">
											<gmd:dimensionSize>
												<gco:Integer>
													<xsl:value-of select="xs:string(xs:integer($var_rastinfoNode/rowcount))"/>
												</gco:Integer>
											</gmd:dimensionSize>
										</xsl:if>
									</gmd:MD_Dimension>
								</gmd:axisDimensionProperties>
								<!--</xsl:for-each>-->
								<!--<xsl:for-each select="$var72_metadata/idinfo/citation/citeinfo/lworkcit">-->
								<gmd:axisDimensionProperties>
									<gmd:MD_Dimension>
										<gmd:dimensionName>
<!--											<xsl:variable name="var_hasColumn"  select="(if (fn:exists($var_rastinfoNode/colcount)) then 'column' else ())"/>-->
											<xsl:if test="fn:exists($var_rastinfoNode/colcount)">
												<gmd:MD_DimensionNameTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode" codeListValue="column" codeSpace="002">column</gmd:MD_DimensionNameTypeCode>
											</xsl:if>
										</gmd:dimensionName>
										<gmd:dimensionSize>
											<xsl:for-each select="$var_rastinfoNode/colcount">
												<gco:Integer>
													<xsl:value-of select="xs:string(xs:integer(.))"/>
												</gco:Integer>
											</xsl:for-each>
										</gmd:dimensionSize>
									</gmd:MD_Dimension>
								</gmd:axisDimensionProperties>
								<!--</xsl:for-each>-->
								<!--<xsl:for-each select="$var72_metadata/idinfo/citation/citeinfo/lworkcit">-->
								<xsl:if test="fn:exists($var_rastinfoNode/vrtcount)">
									<gmd:axisDimensionProperties>
										<gmd:MD_Dimension>
											<gmd:dimensionName>
												<!--<xsl:variable name="var_hasVertical"  select="(if (fn:exists($var_rastinfoNode/vrtcount)) then 'vertical' else ())"/>-->
												<gmd:MD_DimensionNameTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode" codeListValue="vertical" codeSpace="003">vertical</gmd:MD_DimensionNameTypeCode>
											</gmd:dimensionName>
											<gmd:dimensionSize>
												<xsl:for-each select="$var_rastinfoNode/vrtcount">
													<gco:Integer>
														<xsl:value-of select="xs:string(xs:integer(.))"/>
													</gco:Integer>
												</xsl:for-each>
											</gmd:dimensionSize>
										</gmd:MD_Dimension>
									</gmd:axisDimensionProperties>
								</xsl:if>
								<!--</xsl:for-each>-->
								<!-- determine if input data has a rasttype property and use that to assign cell geometry Type code -->
								<xsl:variable name="var_rasttypeGeometryType" >
									<xsl:call-template name="vmf:geometryType">
										<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(rasttype)))"/>
									</xsl:call-template>
								</xsl:variable>
								<!-- if have gridSpatialRepresnetation, cellGeometry is mandatory -->
								<xsl:choose>
									<xsl:when test="fn:exists($var_rasttypeGeometryType)">
										<gmd:cellGeometry>
											<gmd:MD_CellGeometryCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CellGeometryCode">
												<xsl:attribute name="codeListValue"><xsl:value-of select="xs:string(xs:anyURI($var_rasttypeGeometryType))"/></xsl:attribute>
												<xsl:variable name="var_rasttypeGeometryCode" >
													<xsl:call-template name="vmf:geometryCode">
														<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(rasttype)))"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:if test="fn:exists($var_rasttypeGeometryCode)">
													<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string(xs:anyURI($var_rasttypeGeometryCode))"/></xsl:attribute>
												</xsl:if>
												<xsl:value-of select="$var_rasttypeGeometryType"/>
											</gmd:MD_CellGeometryCode>
										</gmd:cellGeometry>
									</xsl:when>
									<xsl:otherwise>
										<gmd:cellGeometry gco:nilReason="missing"/>
									</xsl:otherwise>
								</xsl:choose>
								<!-- no content for transformation parmater avaialalbility in FGDC metatada -->
								<gmd:transformationParameterAvailability>
									<xsl:attribute name="gco:nilReason"><xsl:value-of select="unknown"/></xsl:attribute>
								</gmd:transformationParameterAvailability>
							</gmd:MD_GridSpatialRepresentation>
						</gmd:spatialRepresentationInfo>
					</xsl:for-each>
					<!-- do vector spatial represntation description; FGCD xml specifies choice between rastinfo or ptvctinf -->
					<!-- but ISO19115 allows both to be present in valid instance -->
					<xsl:for-each select="ptvctinf">
						<!-- Point and Vector Object Information,+ the types and numbers of vector or nongridded point spatial objects in the data set. -->
						<!-- FGDC xml implements this element as a choice between 1..* sdtsterm elements, or 1 vpfterm -->
						<!-- xsl:variable name="var_PointVectorObjCountNode" select="."/ -->
						<gmd:spatialRepresentationInfo>
							<gmd:MD_VectorSpatialRepresentation>
								<xsl:for-each select="vpfterm">
									<gmd:topologyLevel>
										<gmd:MD_TopologyLevelCode>
											<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string(xs:anyURI(fn:normalize-space(fn:string(vpflevel))))"/></xsl:attribute>
										</gmd:MD_TopologyLevelCode>
									</gmd:topologyLevel>
								</xsl:for-each>
								<!-- done with vpfterm processing -->
								<xsl:for-each select="sdtsterm">
									<gmd:geometricObjects>
										<gmd:MD_GeometricObjects>
											<gmd:geometricObjectType>
												<xsl:variable name="sdtsTermTypeList" >
													<xsl:for-each select="sdtsterm">
														<xsl:value-of select="fn:string(sdtstype)"/>
													</xsl:for-each>
												</xsl:variable>
												<xsl:variable name="sdtsTermExists" >
													<xsl:if test="fn:exists($sdtsTermTypeList)">
														<xsl:variable name="var136_cond_result_exists" >
															<xsl:choose>
																<xsl:when test="fn:exists($sdtsTermTypeList)">
																	<xsl:variable name="var142_map_select_sdtsterm" >
																		<xsl:for-each select="sdtsterm">
																			<xsl:if test="fn:exists($sdtsTermTypeList)">
																				<xsl:value-of select="fn:string(sdtstype)"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var142_map_select_sdtsterm)">
																		<xsl:value-of select="fn:string-join($var142_map_select_sdtsterm, ' ')"/>
																	</xsl:if>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:for-each select="vpfterm">
																		<xsl:value-of select="fn:string(vpflevel)"/>
																	</xsl:for-each>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:variable>
														<xsl:for-each select="$var136_cond_result_exists">
															<xsl:variable name="var139_result_geometryType2" >
																<xsl:call-template name="vmf:geometryType2">
																	<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:if test="fn:exists($var139_result_geometryType2)">
																<xsl:value-of select="$var139_result_geometryType2"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:if>
												</xsl:variable>
												<xsl:if test="fn:exists($sdtsTermExists)">
													<gmd:MD_GeometricObjectTypeCode>
														<xsl:variable name="var112_map_select_vpfterm" >
															<xsl:for-each select="vpfterm">
																<xsl:value-of select="fn:string(vpflevel)"/>
															</xsl:for-each>
														</xsl:variable>
														<xsl:variable name="var113_map_select_sdtsterm" >
															<xsl:for-each select="sdtsterm">
																<xsl:value-of select="fn:string(sdtstype)"/>
															</xsl:for-each>
														</xsl:variable>
														<xsl:if test="fn:exists($var113_map_select_sdtsterm) or fn:exists($var112_map_select_vpfterm)">
															<xsl:attribute name="codeList">
																<xsl:value-of select="xs:string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_GeometricObjectTypeCode')"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:attribute name="codeListValue"><xsl:value-of select="xs:string(xs:anyURI(fn:string($sdtsTermExists)))"/></xsl:attribute>
														<xsl:variable name="var119_map_select_sdtsterm" >
															<xsl:for-each select="sdtsterm">
																<xsl:value-of select="fn:string(sdtstype)"/>
															</xsl:for-each>
														</xsl:variable>
														<xsl:variable name="var118_cond_result_exists" >
															<xsl:if test="fn:exists($var119_map_select_sdtsterm)">
																<xsl:variable name="var121_cond_result_exists" >
																	<xsl:choose>
																		<xsl:when test="fn:exists($var119_map_select_sdtsterm)">
																			<xsl:variable name="var127_map_select_sdtsterm" >
																				<xsl:for-each select="sdtsterm">
																					<xsl:if test="fn:exists($var119_map_select_sdtsterm)">
																						<xsl:value-of select="fn:string(sdtstype)"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var127_map_select_sdtsterm)">
																				<xsl:value-of select="fn:string-join($var127_map_select_sdtsterm, ' ')"/>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:for-each select="vpfterm">
																				<xsl:value-of select="fn:string(vpflevel)"/>
																			</xsl:for-each>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:for-each select="$var121_cond_result_exists">
																	<xsl:variable name="var124_result_geometryCode2" >
																		<xsl:call-template name="vmf:geometryCode2">
																			<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																		</xsl:call-template>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var124_result_geometryCode2)">
																		<xsl:value-of select="$var124_result_geometryCode2"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:if>
														</xsl:variable>
														<xsl:if test="fn:exists($var118_cond_result_exists)">
															<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string(xs:anyURI(fn:string($var118_cond_result_exists)))"/></xsl:attribute>
														</xsl:if>
														<xsl:value-of select="fn:string($sdtsTermExists)"/>
													</gmd:MD_GeometricObjectTypeCode>
												</xsl:if>
											</gmd:geometricObjectType>
											<gmd:geometricObjectCount>
												<xsl:variable name="var152_map_select_sdtsterm" >
													<xsl:for-each select="sdtsterm/ptvctcnt">
														<xsl:value-of select="xs:string(xs:integer(.))"/>
													</xsl:for-each>
												</xsl:variable>
												<xsl:variable name="var149_cond_result_exists" >
													<xsl:choose>
														<xsl:when test="fn:exists($var152_map_select_sdtsterm)">
															<xsl:for-each select="sdtsterm/ptvctcnt">
																<xsl:value-of select="xs:string(xs:integer(.))"/>
															</xsl:for-each>
														</xsl:when>
														<xsl:otherwise>
															<xsl:for-each select="vpfterm/vpfinfo/ptvctcnt">
																<xsl:value-of select="xs:string(xs:integer(.))"/>
															</xsl:for-each>
														</xsl:otherwise>
													</xsl:choose>
												</xsl:variable>
												<xsl:for-each select="$var149_cond_result_exists">
													<gco:Integer>
														<xsl:value-of select="xs:string(xs:integer(.))"/>
													</gco:Integer>
												</xsl:for-each>
											</gmd:geometricObjectCount>
										</gmd:MD_GeometricObjects>
									</gmd:geometricObjects>
								</xsl:for-each>
							</gmd:MD_VectorSpatialRepresentation>
						</gmd:spatialRepresentationInfo>
					</xsl:for-each>
					<!-- End of ptvctinf-->
				</xsl:for-each>
			</xsl:for-each>
			<!-- spatial reference system information -->
			<!-- indspref is an indirect spatial reference: any way to describe a location without using coordinates. 
				Indirect spatial reference methods usually use a geographic feature, such as a county, state, township or
section of the Public Land Survey System, or a road, to uniquely identify a place. The reference
may use the name of the feature, for example "Westmoreland County", or a code that identifies the
feature (such as a county FIPS code). Other examples of indirect spatial references include street
addresses, linear reference systems, and River Reach codes. -->
			<!-- this is bogus; what need here is a mappign from =4.1.2.1.1 Map Projection Name - name of the map projection" 
				domain values to EPSG codes -->
			<!-- these are the domain values:
				Albers Conical Equal Area
				Azimuthal Equidistant
				Equidistant Conic
				Equirectangular
				General Vertical Near-sided Perspective Gnomonic
				Lambert Azimuthal Equal Area
				Lambert Conformal Conic
				Mercator
				Modified Stereographic for Alaska
				Miller Cylindrical
				Oblique Mercator
				Orthographic
				Polar Stereographic
				Polyconic
				Robinson
				Sinusoidal
				Space Oblique Mercator
				Stereographic
				Transverse Mercator
				van der Grinten -->
			<xsl:for-each select="$var_metadataRoot/spdoinfo">
				<gmd:referenceSystemInfo>
					<gmd:MD_ReferenceSystem>
						<xsl:for-each select="indspref">
							<gmd:referenceSystemIdentifier>
								<gmd:RS_Identifier>
									<!-- smr change gmd:CodeSpace to gmd:code -->
									<gmd:code>
										<gco:CharacterString>
											<!-- xsl:value-of select="xs:string(.)"/ -->
											http://www.opengis.net/def/nil/OGC/0/missing
										</gco:CharacterString>
									</gmd:code>
								</gmd:RS_Identifier>
							</gmd:referenceSystemIdentifier>
						</xsl:for-each>
					</gmd:MD_ReferenceSystem>
				</gmd:referenceSystemInfo>
			</xsl:for-each>
			<!-- metadata extensions FGDC metainfo/metextns/onlink here  -->
			<gmd:metadataExtensionInfo>
				<gmd:MD_MetadataExtensionInformation>
					<gmd:extensionOnLineResource>
						<gmd:CI_OnlineResource>
							<gmd:linkage>
								<gmd:URL>
									<xsl:variable name="CIlinkURL" >
										<xsl:value-of select="xs:integer(fn:count(/metadata/metainfo/metextns[1]/onlink))"/>
									</xsl:variable>
									<xsl:for-each select="/metadata/metainfo/metextns[1]/onlink">
										<xsl:value-of select="xs:string(xs:anyURI(fn:normalize-space(xs:string(.))))"/>
										<xsl:if test="($CIlinkURL>1)">
											<xsl:value-of select="xs:string(' ')"/>
										</xsl:if>
									</xsl:for-each>
									<!--xsl:value-of select="$var_metadataRoot/metainfo/metextns/onlink"/>
										<xsl:value-of select="xs:string(xs:anyURI(fn:normalize-space(xs:string(.))))"/> -->
								</gmd:URL>
							</gmd:linkage>
							<xsl:for-each select="metprof">
								<gmd:name>
									<gco:CharacterString>
										<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
									</gco:CharacterString>
								</gmd:name>
							</xsl:for-each>
						</gmd:CI_OnlineResource>
					</gmd:extensionOnLineResource>
				</gmd:MD_MetadataExtensionInformation>
			</gmd:metadataExtensionInfo>
			<!-- FGDC id metadata/idinfo goes into MD_identification -->
			<xsl:for-each select="$var_metadataRoot">
				<xsl:for-each select="idinfo">
					<xsl:variable name="var_idinfoSourceNode" select="."/>
					<gmd:identificationInfo>
						<gmd:MD_DataIdentification>
							<xsl:for-each select="citation">
								<gmd:citation>
									<xsl:for-each select="citeinfo">
										<xsl:variable name="var_citeinfoSourceNode" select="."/>
										<gmd:CI_Citation>
											<gmd:title>
												<xsl:for-each select="title">
													<gco:CharacterString>
														<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</xsl:for-each>
											</gmd:title>
											<gmd:date>
												<gmd:CI_Date>
													<gmd:date>
														<xsl:call-template name="usgin:dateFormat">
															<xsl:with-param name="inputDate" select="pubdate"/>
															<xsl:with-param name="inputTime" select="pubtime"/>
														</xsl:call-template>
													</gmd:date>
<!--													<xsl:variable name="var_pubdate_exists"  select="(if (fn:exists(pubdate)) then 'publication' else ())"/>-->
													<xsl:choose>
														<xsl:when test="fn:exists(pubdate)">
															<gmd:dateType>
																<gmd:CI_DateTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode" codeListValue="publication" codeSpace="002">publication</gmd:CI_DateTypeCode>
															</gmd:dateType>
														</xsl:when>
														<xsl:otherwise>
															<gmd:dateType gco:nilReason="missing"/>
														</xsl:otherwise>
													</xsl:choose>
												</gmd:CI_Date>
											</gmd:date>
											<xsl:for-each select="edition">
												<gmd:edition>
													<gco:CharacterString>
														<xsl:value-of select="xs:string(.)"/>
													</gco:CharacterString>
												</gmd:edition>
											</xsl:for-each>
											<xsl:for-each select="$var_metadataRoot/distinfo/resdesc">
												<!-- ESRI geoportal 9.3 maps distinfo/resdesc to dc:Type -->
												<!-- mapping to citation//identifier/code is NOAA convention -->
												<!-- USGIN convention is that citation//identifier//code should be same identifier as dataset URI. 
													Obviously this property is not very useful for interoperability -->
												<gmd:identifier>
													<gmd:MD_Identifier>
														<gmd:authority>
															<gmd:CI_Citation>
																<gmd:title>
																	<gco:CharacterString>NOAA NGDC convention</gco:CharacterString>
																</gmd:title>
																<gmd:date gco:nilReason="inapplicable"/>
															</gmd:CI_Citation>
														</gmd:authority>
														<gmd:code>
															<gco:CharacterString>
																<xsl:value-of select="xs:string(.)"/>
															</gco:CharacterString>
														</gmd:code>
													</gmd:MD_Identifier>
												</gmd:identifier>
											</xsl:for-each>
											<gmd:identifier>
												<gmd:MD_Identifier>
													<gmd:authority>
														<gmd:CI_Citation>
															<gmd:title>
																<gco:CharacterString>USGIN convention</gco:CharacterString>
															</gmd:title>
															<gmd:date gco:nilReason="inapplicable"/>
														</gmd:CI_Citation>
													</gmd:authority>
													<gmd:code>
														<gco:CharacterString>
															<xsl:for-each select="$var_idinfoSourceNode/citation/citeinfo/onlink">
																<xsl:value-of select="fn:concat(fn:normalize-space(xs:string(.)),' ')"/>
															</xsl:for-each>
															<!-- xsl:value-of select="xs:string($var_idinfoSourceNode/citation/citeinfo/onlink)"/ -->
														</gco:CharacterString>
													</gmd:code>
												</gmd:MD_Identifier>
											</gmd:identifier>
											<gmd:citedResponsibleParty>
												<gmd:CI_ResponsibleParty>
													<gmd:organisationName>
														<!--	<xsl:for-each select="origin"> -->
														<gco:CharacterString>
															<xsl:variable name="orgCount" >
																<xsl:value-of select="xs:integer(fn:count(origin))"/>
															</xsl:variable>
															<xsl:for-each select="origin">
																<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
																<xsl:if test="($orgCount>1)">
																	<xsl:value-of select="xs:string(' ')"/>
																</xsl:if>
															</xsl:for-each>
														</gco:CharacterString>
														<!-- </xsl:for-each> -->
													</gmd:organisationName>
													<gmd:role>
														<gmd:CI_RoleCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode" codeListValue="originator" codeSpace="006">originator</gmd:CI_RoleCode>
													</gmd:role>
												</gmd:CI_ResponsibleParty>
											</gmd:citedResponsibleParty>
											<gmd:presentationForm>
												<xsl:variable name="var342_cond_result_exists" >
													<xsl:choose>
														<xsl:when test="$var_citeinfoSourceNode/geoform">
															<xsl:variable name="var356_map_select_geoform" >
																<xsl:for-each select="geoform">
																	<xsl:variable name="var359_result_docType" >
																		<xsl:call-template name="vmf:docType">
																			<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(.)))"/>
																		</xsl:call-template>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var359_result_docType)">
																		<xsl:value-of select="$var359_result_docType"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:variable>
															<xsl:if test="fn:exists($var356_map_select_geoform)">
																<xsl:value-of select="xs:string(fn:string-join($var356_map_select_geoform, ' '))"/>
															</xsl:if>
														</xsl:when>
														<xsl:otherwise>
															<xsl:variable name="var360_map_select_geoform" >
																<xsl:for-each select="geoform">
			xs:string(												)		<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
																</xsl:for-each>
															</xsl:variable>
															<xsl:if test="fn:exists($var360_map_select_geoform)">
																<xsl:value-of select="xs:string(fn:string-join($var360_map_select_geoform, ' '))"/>
															</xsl:if>
														</xsl:otherwise>
													</xsl:choose>
												</xsl:variable>
												<xsl:for-each select="$var342_cond_result_exists">
													<gmd:CI_PresentationFormCode>
<!--														<xsl:variable name="var345_cond_result_exists"  select="(if (fn:exists($var_citeinfoSourceNode/geoform)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode' else ())"/>-->
														<xsl:if test="fn:exists($var_citeinfoSourceNode/geoform)">
															<xsl:attribute name="codeList"><xsl:value-of select="xs:string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode')"/></xsl:attribute>
														</xsl:if>
														<xsl:attribute name="codeListValue"><xsl:value-of select="xs:string(xs:anyURI(.))"/></xsl:attribute>
														<xsl:variable name="var346_cond_result_exists" >
															<xsl:if test="$var_citeinfoSourceNode/geoform">
																<xsl:variable name="var350_map_select_geoform" >
																	<xsl:for-each select="$var_citeinfoSourceNode/geoform">
																		<xsl:variable name="var353_result_docCode" >
																			<xsl:call-template name="vmf:docCode">
																				<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																			</xsl:call-template>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var353_result_docCode)">
																			<xsl:value-of select="$var353_result_docCode"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:if test="fn:exists($var350_map_select_geoform)">
																	<xsl:value-of select="xs:string(fn:string-join($var350_map_select_geoform, ' '))"/>
																</xsl:if>
															</xsl:if>
														</xsl:variable>
														<xsl:for-each select="$var346_cond_result_exists">
															<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string(xs:anyURI(.))"/></xsl:attribute>
														</xsl:for-each>
														<xsl:value-of select="."/>
													</gmd:CI_PresentationFormCode>
												</xsl:for-each>
											</gmd:presentationForm>
											<xsl:for-each select="serinfo">
												<gmd:series>
													<gmd:CI_Series>
														<gmd:name>
															<xsl:for-each select="sername">
																<gco:CharacterString>
																	<xsl:value-of select="xs:string(.)"/>
																</gco:CharacterString>
															</xsl:for-each>
														</gmd:name>
														<gmd:issueIdentification>
															<xsl:for-each select="issue">
																<gco:CharacterString>
																	<xsl:value-of select="xs:string(.)"/>
																</gco:CharacterString>
															</xsl:for-each>
														</gmd:issueIdentification>
													</gmd:CI_Series>
												</gmd:series>
											</xsl:for-each>
											<xsl:for-each select="othercit">
												<gmd:otherCitationDetails>
													<gco:CharacterString>
														<xsl:value-of select="xs:string(.)"/>
													</gco:CharacterString>
												</gmd:otherCitationDetails>
											</xsl:for-each>
										</gmd:CI_Citation>
									</xsl:for-each>
								</gmd:citation>
							</xsl:for-each>
							<!-- xsl:for-each select="descript/abstract" -->
							<gmd:abstract>
								<gco:CharacterString>
									<xsl:choose>
										<xsl:when test="fn:exists(descript/abstract) and string-length(xs:string(descript/abstract))>0">
											<xsl:value-of select="fn:normalize-space(xs:string(descript/abstract))"/>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="xs:string('no abstract provided')"/>
										</xsl:otherwise>
									</xsl:choose>
									<!-- insert text for spataial data organization, spatial data reference, and entity attribute information
							that is not well accounted for in transformation -->
									<!-- the following text is modified from FGDC_Classic for Web body
An xsl template for displaying metadata in ArcInfo8 with the traditional FGDC look and feel created by mp
	-->
Other sections: 	<xsl:for-each select="$var_metadataRoot/spdoinfo">
Spatial Data Organization:	<xsl:for-each select="indspref">
	Indirect_Spatial_Reference_Method:  <xsl:value-of select="."/>
										</xsl:for-each>
										<xsl:for-each select="direct">
	Direct_Spatial_Reference_Method: <xsl:value-of select="."/>
										</xsl:for-each>
										<xsl:for-each select="ptvctinf">
	Point_and_Vector_Object_Information: <xsl:for-each select="sdtsterm">
		SDTS_Terms_Description: <xsl:for-each select="sdtstype">
			SDTS_Point_and_Vector_Object_Type:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="ptvctcnt">
			Point_and_Vector_Object_Count:  <xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="vpfterm">
			VPF_Terms_Description: 
											<xsl:for-each select="vpflevel">
				VPF_Topology_Level: <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="vpfinfo">
				VPF_Point_and_Vector_Object_Information: 
												<xsl:for-each select="vpftype">
						VPF_Point_and_Vector_Object_Type: 
													<xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="ptvctcnt">
						Point_and_Vector_Object_Count:
													<xsl:value-of select="."/>
													</xsl:for-each>
												</xsl:for-each>
											</xsl:for-each>
										</xsl:for-each>
										<xsl:for-each select="rastinfo">
Raster_Object_Information: <xsl:for-each select="rasttype">
Raster_Object_Type:	<xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="rowcount">
	Row_Count: <xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="colcount">
	Column_Count: <xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="vrtcount">
	Vertical_Count: <xsl:value-of select="."/>
											</xsl:for-each>
										</xsl:for-each>
									</xsl:for-each>
									<!-- Spatial Reference text blob gets put in the abstract if its present.-->
									<xsl:for-each select="$var_metadataRoot/spref">
Spatial_Reference_Information: <xsl:for-each select="horizsys">
	Horizontal_Coordinate_System_Definition: <xsl:for-each select="geograph">
		Geographic: 	<xsl:for-each select="latres">
			Latitude_Resolution: <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="longres">
			Longitude_Resolution: <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="geogunit">
			Geographic_Coordinate_Units: <xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="planar">
				Planar: 	<xsl:for-each select="mapproj">
					Map_Projection: <xsl:for-each select="mapprojn">
						Map_Projection_Name: <xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="albers">
							Albers_Conical_Equal_Area: </xsl:for-each>
													<xsl:for-each select="azimequi">
							Azimuthal_Equidistant: </xsl:for-each>
													<xsl:for-each select="equicon">
							Equidistant_Conic:  </xsl:for-each>
													<xsl:for-each select="equirect">
							Equirectangular:  </xsl:for-each>
													<xsl:for-each select="gvnsp">
							General_Vertical_Near-sided_Perspective: </xsl:for-each>
													<xsl:for-each select="gnomonic">
							Gnomonic:  </xsl:for-each>
													<xsl:for-each select="lamberta">
							Lambert_Azimuthal_Equal_Area: </xsl:for-each>
													<xsl:for-each select="lambertc"> 
							Lambert_Conformal_Conic:  </xsl:for-each>
													<xsl:for-each select="mercator">
							Mercator:  </xsl:for-each>
													<xsl:for-each select="modsak">
							Modified_Stereographic_for_Alaska: </xsl:for-each>
													<xsl:for-each select="miller">
							Miller_Cylindrical: </xsl:for-each>
													<xsl:for-each select="obqmerc">
							Oblique_Mercator: </xsl:for-each>
													<xsl:for-each select="orthogr">
							Orthographic: </xsl:for-each>
													<xsl:for-each select="polarst">
							Polar_Stereographic: </xsl:for-each>
													<xsl:for-each select="polycon">
							Polyconic: </xsl:for-each>
													<xsl:for-each select="robinson">
							Robinson: </xsl:for-each>
													<xsl:for-each select="sinusoid">
							Sinusoidal: </xsl:for-each>
													<xsl:for-each select="spaceobq">
							Space_Oblique_Mercator_(Landsat): </xsl:for-each>
													<xsl:for-each select="stereo">
							Stereographic: </xsl:for-each>
													<xsl:for-each select="transmer">
							Transverse_Mercator: </xsl:for-each>
													<xsl:for-each select="vdgrin">
							van_der_Grinten: </xsl:for-each>
													<xsl:apply-templates select="*"/>
													<!-- this is where the work gets done, in the template for each projection -->
												</xsl:for-each>
												<xsl:for-each select="gridsys">
Grid_Coordinate_System: 	<xsl:for-each select="gridsysn">
	Grid_Coordinate_System_Name: <xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="utm">
	Universal_Transverse_Mercator: 	<xsl:for-each select="utmzone">
		UTM_Zone_Number: <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="transmer">
		Transverse_Mercator: 	</xsl:for-each>
														<xsl:apply-templates select="transmer"/>
													</xsl:for-each>
													<xsl:for-each select="ups">
		Universal_Polar_Stereographic: 
					<xsl:for-each select="upszone">
			UPS_Zone_Identifier: <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="polarst">
		Polar_Stereographic: 
					</xsl:for-each>
														<xsl:apply-templates select="polarst"/>
													</xsl:for-each>
													<xsl:for-each select="spcs">
		State_Plane_Coordinate_System: 
					<xsl:for-each select="spcszone">
			SPCS_Zone_Identifier:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="lambertc">
		Lambert_Conformal_Conic: 
					</xsl:for-each>
														<xsl:apply-templates select="lambertc"/>
														<xsl:for-each select="transmer">
		Transverse_Mercator: 
					</xsl:for-each>
														<xsl:apply-templates select="transmer"/>
														<xsl:for-each select="obqmerc">
		Oblique_Mercator: 
					</xsl:for-each>
														<xsl:apply-templates select="obqmerc"/>
														<xsl:for-each select="polycon">
		Polyconic: 
					</xsl:for-each>
														<xsl:apply-templates select="polycon"/>
													</xsl:for-each>
													<xsl:for-each select="arcsys">
		ARC_Coordinate_System: 
			<xsl:for-each select="arczone">
			ARC_System_Zone_Identifier:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="equirect">
		Equirectangular: 
			</xsl:for-each>
														<xsl:apply-templates select="equirect"/>
														<xsl:for-each select="azimequi">
		Azimuthal_Equidistant: </xsl:for-each>
														<xsl:apply-templates select="azimequi"/>
													</xsl:for-each>
													<xsl:for-each select="othergrd">
		Other_Grid_System's_Definition: <xsl:value-of select="."/>
													</xsl:for-each>
												</xsl:for-each>
												<xsl:for-each select="localp">
Local_Planar: 
	<xsl:for-each select="localpd">
	Local_Planar_Description: <xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="localpgi">
	Local_Planar_Georeference_Information: <xsl:value-of select="."/>
													</xsl:for-each>
												</xsl:for-each>
												<xsl:for-each select="planci">
	Planar_Coordinate_Information: <xsl:for-each select="plance">
		Planar_Coordinate_Encoding_Method: <xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="coordrep">
		Coordinate_Representation: <xsl:for-each select="absres">
			Abscissa_Resolution:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="ordres">
			Ordinate_Resolution:  <xsl:value-of select="."/>
														</xsl:for-each>
													</xsl:for-each>
													<xsl:for-each select="distbrep">
	Distance_and_Bearing_Representation: 
				<xsl:for-each select="distres">
			Distance_Resolution: <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="bearres">
			Bearing_Resolution:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="bearunit">
			Bearing_Units:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="bearrefd">
			Bearing_Reference_Direction:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="bearrefm">
			Bearing_Reference_Meridian:  <xsl:value-of select="."/>
														</xsl:for-each>
													</xsl:for-each>
													<xsl:for-each select="plandu">
	Planar_Distance_Units: <xsl:value-of select="."/>
													</xsl:for-each>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="local">
Local: <xsl:for-each select="localdes">
	Local_Description:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="localgeo">
	Local_Georeference_Information:  <xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="geodetic">
Geodetic_Model: <xsl:for-each select="horizdn">
	Horizontal_Datum_Name:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="ellips">
	Ellipsoid_Name:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="semiaxis">
	Semi-major_Axis: <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="denflat">
	Denominator_of_Flattening_Ratio:  <xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
										</xsl:for-each>
										<xsl:for-each select="vertdef">
Vertical_Coordinate_System_Definition: <xsl:for-each select="altsys">
		Altitude_System_Definition: <xsl:for-each select="altdatum">
			Altitude_Datum_Name:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="altres">
			Altitude_Resolution:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="altunits">
				Altitude_Distance_Units:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="altenc">
				Altitude_Encoding_Method:  <xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="depthsys">
		Depth_System_Definition: <xsl:for-each select="depthdn">
				Depth_Datum_Name:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="depthres">
				Depth_Resolution:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="depthdu">
				Depth_Distance_Units:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="depthem">
				Depth_Encoding_Method:  <xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
										</xsl:for-each>
									</xsl:for-each>
									<!-- End spatial reference section -->
									<!-- Entity and Attribute -->
									<xsl:for-each select="$var_metadataRoot/eainfo">
Entity_and_Attribute_Information: <xsl:for-each select="detailed">
Detailed_Description: <xsl:for-each select="enttyp">
Entity_Type: <xsl:for-each select="enttypl">
	Entity_Label:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="enttypd">
		Entity_Definition:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="enttypds">
		Definition_Source:  <xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="attr">
		Attribute: <xsl:for-each select="attrlabl">
			Attribute_Label:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="attrdef">
			Attribute_Definition: <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="attrdefs">
			Attribute_Definition_Source:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="attrdomv">
			Attribute_Domain_Values: <xsl:for-each select="edom">
				Enumerated_Domain: <xsl:for-each select="edomv">
					Enumerated_Domain_Value: <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="edomvd">
					Enumerated_Domain_Value_Definition:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="edomvds">
					Enumerated_Domain_Value_Definition_Source:  <xsl:value-of select="."/>
														</xsl:for-each>
						Domain Value Attribute: <xsl:apply-templates select="attr"/>
													</xsl:for-each>
													<!-- end enumerated domain -->
													<xsl:for-each select="rdom">
				Range_Domain: <xsl:for-each select="rdommin">
					Range_Domain_Minimum:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="rdommax">
					Range_Domain_Maximum:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="attrunit">
					Attribute_Units_of_Measure:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="attrmres">
					Attribute_Measurement_Resolution:  <xsl:value-of select="."/>
														</xsl:for-each>
						Range Domain Attribute: <xsl:apply-templates select="attr"/>
													</xsl:for-each>
													<xsl:for-each select="codesetd">
				Codeset_Domain: <xsl:for-each select="codesetn">
						Codeset_Name:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="codesets">
						Codeset_Source:  <xsl:value-of select="."/>
														</xsl:for-each>
													</xsl:for-each>
													<xsl:for-each select="udom">
				Unrepresentable_Domain:  <xsl:value-of select="."/>
													</xsl:for-each>
												</xsl:for-each>
												<xsl:for-each select="begdatea">
Beginning_Date_of_Attribute_Values:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="enddatea">
Ending_Date_of_Attribute_Values:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="attrvai">
Attribute_Value_Accuracy_Information: <xsl:for-each select="attrva">
	Attribute_Value_Accuracy:  <xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="attrvae">
	Attribute_Value_Accuracy_Explanation: <xsl:value-of select="."/>
													</xsl:for-each>
												</xsl:for-each>
												<xsl:for-each select="attrmfrq">
Attribute_Measurement_Frequency:  <xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
										</xsl:for-each>
										<xsl:for-each select="overview">
Overview_Description: <xsl:for-each select="eaover">
		Entity_and_Attribute_Overview:  <xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="eadetcit">
		Entity_and_Attribute_Detail_Citation:  <xsl:value-of select="."/>
											</xsl:for-each>
										</xsl:for-each>
									</xsl:for-each>
									<!-- end of Entity Attribute section text blob, end of text for abstract element -->
									<!--  /xsl:template -->
								</gco:CharacterString>
							</gmd:abstract>
							<!-- /xsl:for-each -->
							<xsl:for-each select="descript/purpose">
								<gmd:purpose>
									<gco:CharacterString>
										<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
									</gco:CharacterString>
								</gmd:purpose>
							</xsl:for-each>
							<xsl:for-each select="datacred">
								<gmd:credit>
									<gco:CharacterString>
										<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
									</gco:CharacterString>
								</gmd:credit>
							</xsl:for-each>
							<gmd:status>
								<!-- xsl:variable name="var395_map_select_status" >
									<xsl:for-each select="status/progress">
										<xsl:value-of select="xs:string(.)"/>
									</xsl:for-each>
								</xsl:variable -->
								<xsl:variable name="var_checkHasStatusProgress" >
									<xsl:choose>
										<xsl:when test="fn:exists(status/progress)">
											<xsl:variable name="var_checkStatusProgress" >
												<xsl:for-each select="status/progress">
													<xsl:variable name="var_checkStatusTypeLookup" >
														<xsl:call-template name="vmf:statusType">
															<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(.)))"/>
														</xsl:call-template>
													</xsl:variable>
													<xsl:if test="fn:exists($var_checkStatusTypeLookup)">
														<xsl:value-of select="$var_checkStatusTypeLookup"/>
													</xsl:if>
												</xsl:for-each>
											</xsl:variable>
											<xsl:if test="fn:exists($var_checkStatusProgress)">
												<xsl:value-of select="xs:string(fn:string-join($var_checkStatusProgress, ' '))"/>
											</xsl:if>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="''"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:for-each select="$var_checkHasStatusProgress">
									<gmd:MD_ProgressCode>
										<xsl:attribute name="codeList">
											<xsl:choose>
												<xsl:when test="fn:exists($var_idinfoSourceNode/status/progress)">
													<xsl:value-of select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ProgressCode')"/>
												</xsl:when>
												<xsl:otherwise><xsl:value-of select="string('http://www.opengis.net/def/nil/OGC/0/missing')"/></xsl:otherwise>
											</xsl:choose>
<!--											<xsl:variable name="var381_map_select_status" >
												<xsl:for-each select="$var_idinfoSourceNode/status/progress">
													<xsl:value-of select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var380_cond_result_exists"  select="(if (fn:exists($var381_map_select_status)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ProgressCode' else '')"/>
											<xsl:value-of select="xs:string(xs:anyURI($var380_cond_result_exists))"/>-->
										</xsl:attribute>
										<xsl:attribute name="codeListValue"><xsl:value-of select="xs:string(xs:anyURI(.))"/></xsl:attribute>
										<xsl:variable name="var387_map_select_status" >
											<xsl:for-each select="$var_idinfoSourceNode/status/progress">
												<xsl:value-of select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:variable>
										<xsl:variable name="var384_cond_result_exists" >
											<xsl:choose>
												<xsl:when test="fn:exists($var387_map_select_status)">
													<xsl:variable name="var389_map_select_status" >
														<xsl:for-each select="$var_idinfoSourceNode/status/progress">
															<xsl:variable name="var392_result_statusCode" >
																<xsl:call-template name="vmf:statusCode">
																	<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(.)))"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:if test="fn:exists($var392_result_statusCode)">
																<xsl:value-of select="$var392_result_statusCode"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:if test="fn:exists($var389_map_select_status)">
														<xsl:value-of select="xs:string(fn:string-join($var389_map_select_status, ' '))"/>
													</xsl:if>
												</xsl:when>
												<xsl:otherwise>
													<xsl:value-of select="''"/>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<xsl:for-each select="$var384_cond_result_exists">
											<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string(xs:anyURI(.))"/></xsl:attribute>
										</xsl:for-each>
										<xsl:value-of select="."/>
									</gmd:MD_ProgressCode>
								</xsl:for-each>
							</gmd:status>
							<xsl:for-each select="ptcontac">
								<gmd:pointOfContact>
									<!-- ptcontac/cntinfo -->
									<xsl:for-each select="cntinfo">
										<!-- xsl:variable name="var_ptcontac-cntinfo_node" select="."/ -->
										<gmd:CI_ResponsibleParty>
											<!-- gmd:individualName -->
											<xsl:variable name="var_cntIndividualName" >
												<xsl:choose>
													<xsl:when test="fn:exists(cntperp/cntper)">
														<xsl:for-each select="cntperp/cntper">
															<xsl:value-of select="xs:string(.)"/>
														</xsl:for-each>
													</xsl:when>
													<xsl:otherwise>
														<xsl:for-each select="cntorgp/cntper">
															<xsl:value-of select="xs:string(.)"/>
														</xsl:for-each>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:variable>
											<xsl:variable name="var_cntOrgName" >
												<xsl:choose>
													<xsl:when test="fn:exists(cntperp/cntorg)">
														<xsl:for-each select="cntperp/cntorg">
															<xsl:value-of select="xs:string(.)"/>
														</xsl:for-each>
													</xsl:when>
													<xsl:otherwise>
														<xsl:for-each select="cntorgp/cntorg">
															<xsl:value-of select="xs:string(.)"/>
														</xsl:for-each>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:variable>
											<xsl:call-template name="usgin:contactName">
												<xsl:with-param name="inputPersonNode" select="$var_cntIndividualName"/>
												<xsl:with-param name="inputOrganizationNode" select="$var_cntOrgName"/>
												<xsl:with-param name="inputPositionNode" select="cntpos"/>
											</xsl:call-template>
											<gmd:contactInfo>
												<gmd:CI_Contact>
													<xsl:call-template name="usgin:telephoneFormat">
														<xsl:with-param name="telNode" select="(.)"/>
													</xsl:call-template>
													<!--gmd:phone>
														<gmd:CI_Telephone>
															<gmd:voice>
																<xsl:for-each select="cntvoice">
																	<gco:CharacterString>
																		<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</xsl:for-each>
															</gmd:voice>
															<gmd:facsimile>
																<xsl:for-each select="cntfax">
																	<gco:CharacterString>
																		<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</xsl:for-each>
															</gmd:facsimile>
														</gmd:CI_Telephone>
													</gmd:phone -->
													<gmd:address>
														<gmd:CI_Address>
															<xsl:call-template name="usgin:addressFormat">
																<xsl:with-param name="inputAddr" select="cntaddr[1]"/>
															</xsl:call-template>
															<!-- done with postal address elements, now the e-mail. Set this up so that some value gets inserted -->
															<!-- xsl:for-each select="cntaddr/address">
																<gmd:deliveryPoint>
																	<gco:CharacterString>
																		<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</gmd:deliveryPoint>
															</xsl:for-each>
															<xsl:for-each select="cntaddr/city">
																<gmd:city>
																	<gco:CharacterString>
																		<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</gmd:city>
															</xsl:for-each>
															<xsl:for-each select="cntaddr/state">
																<gmd:administrativeArea>
																	<gco:CharacterString>
																		<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</gmd:administrativeArea>
															</xsl:for-each>
															<xsl:for-each select="cntaddr/postal">
																<gmd:postalCode>
																	<gco:CharacterString>
																		<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</gmd:postalCode>
															</xsl:for-each>
															<xsl:for-each select="cntaddr/country">
																<gmd:country>
																	<gco:CharacterString>
																		<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</gmd:coun try>
															</xsl:for-each -->
															<xsl:for-each select="cntemail">
																<xsl:call-template name="usgin:emailFormat">
																	<xsl:with-param name="emailNode" select="(.)"/>
																</xsl:call-template>
																<!-- gmd:electronicMailAddress>
																	<gco:CharacterString>
																		<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</gmd:electronicMailAddress -->
															</xsl:for-each>
														</gmd:CI_Address>
													</gmd:address>
													<xsl:for-each select="hours">
														<gmd:hoursOfService>
															<gco:CharacterString>
																<xsl:value-of select="xs:string(.)"/>
															</gco:CharacterString>
														</gmd:hoursOfService>
													</xsl:for-each>
													<xsl:for-each select="cntinst">
														<gmd:contactInstructions>
															<gco:CharacterString>
																<xsl:value-of select="xs:string(.)"/>
															</gco:CharacterString>
														</gmd:contactInstructions>
													</xsl:for-each>
												</gmd:CI_Contact>
											</gmd:contactInfo>
											<gmd:role>
												<gmd:CI_RoleCode>
													<xsl:attribute name="codeList"><xsl:value-of select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/></xsl:attribute>
													<xsl:attribute name="codeListValue"><xsl:value-of select="xs:string(xs:anyURI('pointOfContact'))"/></xsl:attribute>
													<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string(xs:anyURI('007'))"/></xsl:attribute>
													<xsl:value-of select="'pointOfContact'"/>
												</gmd:CI_RoleCode>
											</gmd:role>
										</gmd:CI_ResponsibleParty>
									</xsl:for-each>
								</gmd:pointOfContact>
							</xsl:for-each>
							<!-- +++ Resource maintenance section -->
							<gmd:resourceMaintenance>
								<gmd:MD_MaintenanceInformation>
									<gmd:maintenanceAndUpdateFrequency>
										<xsl:variable name="var338_result_vmf11_inputtoresult" >
											<xsl:call-template name="vmf:updateFrequency">
												<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(status/update)))"/>
											</xsl:call-template>
										</xsl:variable>
<!--										<xsl:variable name="var335_cond_result_exists"  select="(if (fn:exists($var338_result_vmf11_inputtoresult)) then $var338_result_vmf11_inputtoresult else ())"/>-->
										<xsl:if test="fn:exists($var338_result_vmf11_inputtoresult)">
											<gmd:MD_MaintenanceFrequencyCode>
												<xsl:attribute name="codeList">
													<xsl:value-of select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MaintenanceFrequencyCode'))"/></xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:value-of select="xs:string($var338_result_vmf11_inputtoresult)"/></xsl:attribute>
												<xsl:variable name="var337_result_vmf12_inputtoresult" >
													<xsl:call-template name="vmf:updateFrequencyCode">
														<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(idinfo/status/update))))"/>
													</xsl:call-template>
												</xsl:variable>
<!--												<xsl:variable name="var336_cond_result_exists"  select="(if (fn:exists($var337_result_vmf12_inputtoresult)) then $var337_result_vmf12_inputtoresult else ())"/>-->
												<xsl:if test="fn:exists($var337_result_vmf12_inputtoresult)">
													<xsl:attribute name="codeSpace">
														<xsl:value-of select="xs:string($var337_result_vmf12_inputtoresult)"/></xsl:attribute>
												</xsl:if>
												<xsl:value-of select="$var338_result_vmf11_inputtoresult"/>
											</gmd:MD_MaintenanceFrequencyCode>
										</xsl:if>
									</gmd:maintenanceAndUpdateFrequency>
								</gmd:MD_MaintenanceInformation>
							</gmd:resourceMaintenance>
							<xsl:for-each select="$var_metadataRoot/eainfo/detailed/attr/attrmfrq">
								<gmd:resourceMaintenance>
									<gmd:MD_MaintenanceInformation>
										<gmd:maintenanceAndUpdateFrequency>
											<xsl:variable name="var344_result_vmf11_inputtoresult" >
												<xsl:call-template name="vmf:updateFrequency">
													<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(.)))"/>
												</xsl:call-template>
											</xsl:variable>
<!--											<xsl:variable name="var341_cond_result_exists"  select="(if (fn:exists($var344_result_vmf11_inputtoresult)) then $var344_result_vmf11_inputtoresult else ())"/>-->
											<xsl:if test="fn:exists($var344_result_vmf11_inputtoresult)">
												<gmd:MD_MaintenanceFrequencyCode>
													<xsl:attribute name="codeList"><xsl:value-of select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MaintenanceFrequencyCode'))"/></xsl:attribute>
													<xsl:attribute name="codeListValue">
														<xsl:value-of select="xs:string($var344_result_vmf11_inputtoresult)"/>
													</xsl:attribute>
													<xsl:variable name="var343_result_vmf12_inputtoresult" >
														<xsl:call-template name="vmf:updateFrequencyCode">
															<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
														</xsl:call-template>
													</xsl:variable>
<!--													<xsl:variable name="var342_cond_result_exists"  select="(if (fn:exists($var343_result_vmf12_inputtoresult)) then $var343_result_vmf12_inputtoresult else ())"/>-->
													<xsl:if test="fn:exists($var343_result_vmf12_inputtoresult)">
														<xsl:attribute name="codeSpace">
															<xsl:value-of select="xs:string($var343_result_vmf12_inputtoresult)"/>
														</xsl:attribute>
													</xsl:if>
													<xsl:value-of select="$var344_result_vmf11_inputtoresult"/>
												</gmd:MD_MaintenanceFrequencyCode>
											</xsl:if>
										</gmd:maintenanceAndUpdateFrequency>
										<gmd:updateScope>
											<gmd:MD_ScopeCode>
												<xsl:attribute name="codeList"><xsl:value-of select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode'))"/></xsl:attribute>
												<xsl:attribute name="codeListValue"><xsl:value-of select="xs:string(xs:anyURI('attribute'))"/></xsl:attribute>
											</gmd:MD_ScopeCode>
										</gmd:updateScope>
									</gmd:MD_MaintenanceInformation>
								</gmd:resourceMaintenance>
							</xsl:for-each>
							<!-- Handle browse graphic if it exists -->
							<xsl:for-each select="browse">
								<gmd:graphicOverview>
									<gmd:MD_BrowseGraphic>
										<gmd:fileName>
<!--											<xsl:for-each-group select="." group-by="xs:string(browsen)">
												<xsl:variable name="var349_cur_result_groupby"  select="current-grouping-key()"/>-->
												<gco:CharacterString>
													<xsl:value-of select="xs:string(browsen)"/>											<!--		<xsl:value-of select="$var349_cur_result_groupby"/>-->
												</gco:CharacterString>
<!--											</xsl:for-each-group>-->
										</gmd:fileName>
										<gmd:fileDescription>
											<gco:CharacterString>
												<xsl:value-of select="xs:string(browsed)"/>
											</gco:CharacterString>
										</gmd:fileDescription>
										<gmd:fileType>
											<gco:CharacterString>
												<xsl:value-of select="xs:string(browset)"/>
											</gco:CharacterString>
										</gmd:fileType>
									</gmd:MD_BrowseGraphic>
								</gmd:graphicOverview>
							</xsl:for-each>
							<!-- handle Keywords, grouped by theme with a thesaurus element for each theme -->
							<!-- if ...kt (keyword thesaurus) is missing, fgdc xml should be invalid, but in real world... -->
			<!--				<xsl:choose>
								<xsl:when test="fn:exists(keywords/theme/themekt)">
									<xsl:for-each-group select="keywords/theme" group-by="(if (fn:contains(xs:string(themekt), 'ISO 19115')) then () else xs:string(themekt))">
										<xsl:variable name="var352_cur_result_groupby" as="item()+" select="current-group()"/>
										<xsl:variable name="var353_cur_result_groupby"  select="current-grouping-key()"/>
										<gmd:descriptiveKeywords>
											<gmd:MD_Keywords>
												<xsl:for-each select="$var352_cur_result_groupby/themekey">
													<gmd:keyword>
														<gco:CharacterString>
															<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
														</gco:CharacterString>
													</gmd:keyword>
												</xsl:for-each>

											</gmd:MD_Keywords>
										</gmd:descriptiveKeywords>
									</xsl:for-each-group>
								</xsl:when>
								<!-\- thesaurus name is missing... -\->
								<xsl:otherwise>-->
									<xsl:for-each select="keywords/theme">
										<gmd:descriptiveKeywords>
											<gmd:MD_Keywords>
												<xsl:for-each select="themekey">
													<gmd:keyword>
														<gco:CharacterString>
															<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
														</gco:CharacterString>
													</gmd:keyword>
												</xsl:for-each>
												<gmd:type>
													<gmd:MD_KeywordTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode" codeListValue="theme" codeSpace="005">
														<xsl:value-of select="'theme'"/>
													</gmd:MD_KeywordTypeCode>
												</gmd:type>
												<xsl:choose>
													<xsl:when test="fn:exists(themekt)">						
														<gmd:thesaurusName>
															<gmd:CI_Citation>
																<gmd:title>
																	<gco:CharacterString>
																		<xsl:value-of select="fn:normalize-space(themekt)"/>
																	</gco:CharacterString>
																</gmd:title>
																<gmd:date>
																	<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
																</gmd:date>
															</gmd:CI_Citation>
														</gmd:thesaurusName> </xsl:when>
													<xsl:otherwise><gmd:thesaurusName gco:nilReason="missing"/></xsl:otherwise>
												</xsl:choose>
												
											</gmd:MD_Keywords>
										</gmd:descriptiveKeywords>
									</xsl:for-each>
								<!--</xsl:otherwise>-->
							<!--</xsl:choose>-->
							<!-- place keywords -->
							<!--<xsl:choose>
								<xsl:when test="fn:exists(keywords/place/placekt)">
									<xsl:for-each-group select="keywords/place" group-by="xs:string(xs:string(placekt))">
										<xsl:variable name="var_placeKeywordList" as="item()+" select="current-group()"/>
										<xsl:variable name="var_placeGroupKeyValue"  select="current-grouping-key()"/>
										<gmd:descriptiveKeywords>
											<gmd:MD_Keywords>
												<xsl:for-each select="$var_placeKeywordList/placekey">
													<gmd:keyword>
														<gco:CharacterString>
															<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
														</gco:CharacterString>
													</gmd:keyword>
												</xsl:for-each>
												<gmd:type>
													<gmd:MD_KeywordTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode" codeListValue="place" codeSpace="002">
														<xsl:value-of select="'place'"/>
													</gmd:MD_KeywordTypeCode>
												</gmd:type>

											</gmd:MD_Keywords>
										</gmd:descriptiveKeywords>
									</xsl:for-each-group>
								</xsl:when>
								<xsl:otherwise>
									<!-\- no thesaurus -\->-->
									<xsl:for-each select="keywords/place">
										<gmd:descriptiveKeywords>
											<gmd:MD_Keywords>
												<xsl:for-each select="placekey">
													<gmd:keyword>
														<gco:CharacterString>
															<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
														</gco:CharacterString>
													</gmd:keyword>
												</xsl:for-each>
												<gmd:type>
													<gmd:MD_KeywordTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode" codeListValue="place" codeSpace="002">
														<xsl:value-of select="'place'"/>
													</gmd:MD_KeywordTypeCode>
												</gmd:type>
												<xsl:choose>
													<xsl:when test="fn:exists(placekt)">												<gmd:thesaurusName>
														<gmd:CI_Citation>
															<gmd:title>
																<gco:CharacterString>
																	<xsl:value-of select="fn:normalize-space(placekt)"/>
																</gco:CharacterString>
															</gmd:title>
															<gmd:date>
																<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
															</gmd:date>
														</gmd:CI_Citation>
													</gmd:thesaurusName></xsl:when>
													<xsl:otherwise><gmd:thesaurusName gco:nilReason="missing"/></xsl:otherwise>
												</xsl:choose>
												
											</gmd:MD_Keywords>
										</gmd:descriptiveKeywords>
									</xsl:for-each>
							<!--	</xsl:otherwise>
							</xsl:choose>-->
							<!-- stratum keywords -->
							<!-- alternate logic for thesaurus name -->
							<!--xsl:for-each-group select="keywords/stratum" group-by="xs:string(xs:string(stratkt))">
								<xsl:variable name="var364_cur_result_groupby" as="item()+" select="current-group()"/>
								<xsl:variable name="var365_cur_result_groupby"  select="current-grouping-key()"/ -->
							<xsl:for-each select="keywords/stratum">
								<gmd:descriptiveKeywords>
									<gmd:MD_Keywords>
										<xsl:for-each select="stratkey">
											<gmd:keyword>
												<gco:CharacterString>
													<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
												</gco:CharacterString>
											</gmd:keyword>
										</xsl:for-each>
										<gmd:type>
											<gmd:MD_KeywordTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode" codeListValue="stratum" codeSpace="003">
												<xsl:value-of select="'stratum'"/>
											</gmd:MD_KeywordTypeCode>
										</gmd:type>
										<xsl:choose>
											<xsl:when test="fn:exists(stratkt)">
												<gmd:thesaurusName>
													<gmd:CI_Citation>
														<gmd:title>
															<gco:CharacterString>
																<xsl:value-of select="fn:normalize-space(xs:string(stratkt))"/>
															</gco:CharacterString>
														</gmd:title>
														<gmd:date>
															<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string(xs:string('unknown'))"/></xsl:attribute>
														</gmd:date>
													</gmd:CI_Citation>
												</gmd:thesaurusName>
											</xsl:when>
											<xsl:otherwise>
												<gmd:thesaurusName gco:nilReason="missing"/>
											</xsl:otherwise>
										</xsl:choose>
									</gmd:MD_Keywords>
								</gmd:descriptiveKeywords>
							</xsl:for-each>
	<!--						<xsl:if test="fn:string-length(xs:string(keywords/temporal[1]/tempkey[1]))>0">-->
								<xsl:for-each select="keywords/temporal">
									<!--xsl:variable name="var370_cur_result_groupby" as="item()+" select="current-group()"/>
								<xsl:variable name="var371_cur_result_groupby"  select="current-grouping-key()"/ -->
									<gmd:descriptiveKeywords>
										<gmd:MD_Keywords>
											<xsl:for-each select="tempkey">
												<gmd:keyword>
													<gco:CharacterString>
														<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</gmd:keyword>
											</xsl:for-each>
											<gmd:type>
												<gmd:MD_KeywordTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode" codeListValue="temporal" codeSpace="004">
													<xsl:value-of select="'temporal'"/>
												</gmd:MD_KeywordTypeCode>
											</gmd:type>
											<xsl:choose>
												<xsl:when test="fn:exists(tempkt)">
													<gmd:thesaurusName>
														<gmd:CI_Citation>
															<gmd:title>
																<gco:CharacterString>
																	<xsl:value-of select="fn:normalize-space(xs:string(tempkt))"/>
																</gco:CharacterString>
															</gmd:title>
															<gmd:date>
																<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string(xs:string('unknown'))"/></xsl:attribute>
															</gmd:date>
														</gmd:CI_Citation>
													</gmd:thesaurusName>
												</xsl:when>
												<xsl:otherwise>
													<gmd:thesaurusName gco:nilReason="missing"/>
												</xsl:otherwise>
											</xsl:choose>
										</gmd:MD_Keywords>
									</gmd:descriptiveKeywords>
								</xsl:for-each>
							<!--</xsl:if>-->
							<!-- resource constraints section, distribution liability, access constraint, and use constraints get concatenated into a single gmd:useConstraint 
								text blob -->
							<xsl:variable name="var_distributionLiability_exists" >
								<xsl:if test="fn:exists($var_metadataRoot/distinfo/distliab)">
									<xsl:value-of select="fn:concat('Distribution Liability: ', fn:string-join($var_metadataRoot/distinfo/distliab, ' '))"/>
								</xsl:if>
							</xsl:variable>
							<xsl:variable name="var_accessConstraints_exists" >
								<xsl:if test="fn:exists(accconst)">
									<xsl:value-of select="fn:concat('Access Constraints: ', fn:string-join($var_metadataRoot//idinfo/accconst, ' '))"/>
								</xsl:if>
							</xsl:variable>
							<xsl:variable name="var_useLimitation_exists" >
								<xsl:if test="fn:exists(useconst)">
									<xsl:value-of select="fn:concat('Use Limitation: ', fn:string-join($var_metadataRoot/idinfo/useconst, ' '))"/>
								</xsl:if>
							</xsl:variable>
							<xsl:if test="fn:exists($var_distributionLiability_exists) or fn:exists($var_accessConstraints_exists) or fn:exists($var_useLimitation_exists)">
								<gmd:resourceConstraints>
									<gmd:MD_LegalConstraints>
										<xsl:if test="fn:exists($var_accessConstraints_exists)">
											<gmd:accessConstraints>
												<gmd:MD_RestrictionCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode" codeListValue="otherRestrictions" codeSpace="008">
													<xsl:value-of select="'otherRestrictions'"/>
												</gmd:MD_RestrictionCode>
											</gmd:accessConstraints>
										</xsl:if>
										<xsl:if test="fn:exists($var_useLimitation_exists)">
											<gmd:useConstraints>
												<gmd:MD_RestrictionCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode" codeListValue="otherRestrictions" codeSpace="008">
													<xsl:value-of select="'otherRestrictions'"/>
												</gmd:MD_RestrictionCode>
											</gmd:useConstraints>
										</xsl:if>
										<gmd:otherConstraints>
											<gco:CharacterString>
												<xsl:value-of select="fn:normalize-space(fn:concat( $var_accessConstraints_exists, ' ',   $var_useLimitation_exists, ' ',   $var_distributionLiability_exists))"/>
											</gco:CharacterString>
										</gmd:otherConstraints>
									</gmd:MD_LegalConstraints>
								</gmd:resourceConstraints>
							</xsl:if>
							<xsl:for-each select="secinfo">
								<gmd:resourceConstraints>
									<gmd:MD_SecurityConstraints>
										<gmd:classification>
											<xsl:variable name="var388_result_securityClassType" >
												<xsl:call-template name="vmf:securityClassType">
													<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(secclass)))"/>
												</xsl:call-template>
											</xsl:variable>
<!--											<xsl:variable name="var385_cond_result_exists"  select="(if (fn:exists($var388_result_securityClassType)) then $var388_result_securityClassType else ())"/>-->
											<xsl:if test="fn:exists($var388_result_securityClassType)">
												<gmd:MD_ClassificationCode>
													<xsl:attribute name="codeList"><xsl:value-of select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ClassificationCode'))"/></xsl:attribute>
													<xsl:attribute name="codeListValue"><xsl:value-of select="xs:string($var388_result_securityClassType)"/></xsl:attribute>
													<xsl:variable name="var387_result_securityClassCode" >
														<xsl:call-template name="vmf:securityClassCode">
															<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(secclass))))"/>
														</xsl:call-template>
													</xsl:variable>
<!--													<xsl:variable name="var386_cond_result_exists"  select="(if (fn:exists($var387_result_securityClassCode)) then $var387_result_securityClassCode else ())"/>-->
													<xsl:if test="fn:exists($var387_result_securityClassCode)">
														<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string($var387_result_securityClassCode)"/></xsl:attribute>
													</xsl:if>
													<xsl:value-of select="$var388_result_securityClassType"/>
												</gmd:MD_ClassificationCode>
											</xsl:if>
										</gmd:classification>
										<gmd:classificationSystem>
											<gco:CharacterString>
												<xsl:value-of select="xs:string(secsys)"/>
											</gco:CharacterString>
										</gmd:classificationSystem>
										<gmd:handlingDescription>
											<gco:CharacterString>
												<xsl:value-of select="xs:string(sechandl)"/>
											</gco:CharacterString>
										</gmd:handlingDescription>
									</gmd:MD_SecurityConstraints>
								</gmd:resourceConstraints>
							</xsl:for-each>
							<!--  put in relationships to larger work and cross references using gmd:aggregationInfo elements -->
							<xsl:if test="fn:exists(citation/citeinfo/lworkcit)">
								<xsl:for-each select="citation/citeinfo/lworkcit">
									<xsl:variable name="var_largerWorkCitationNode" select="."/>
									<gmd:aggregationInfo>
										<gmd:MD_AggregateInformation>
											<gmd:aggregateDataSetName>
												<gmd:CI_Citation>
													<gmd:title>
														<xsl:for-each select="citeinfo/title">
															<gco:CharacterString>
																<xsl:value-of select="xs:string(.)"/>
															</gco:CharacterString>
														</xsl:for-each>
													</gmd:title>
													<gmd:date>
														<gmd:CI_Date>
															<gmd:date>
																<xsl:call-template name="usgin:dateFormat">
																	<xsl:with-param name="inputDate" select="citeinfo/pubdate"/>
																	<xsl:with-param name="inputTime" select="citeinfo/pubtime"/>
																</xsl:call-template>
															</gmd:date>
															<gmd:dateType>
																<xsl:if test="fn:exists(citeinfo/pubdate)">
																	<gmd:CI_DateTypeCode>
																		<xsl:attribute name="codeList"><xsl:value-of select="xs:string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode')"/></xsl:attribute>
																		<xsl:attribute name="codeListValue"><xsl:value-of select="xs:string()"/></xsl:attribute>
																		<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string('002')"/></xsl:attribute>
																		<!--<xsl:value-of select="string(citeinfo/pubdate)"/>-->
																	</gmd:CI_DateTypeCode>
																</xsl:if>
															</gmd:dateType>
														</gmd:CI_Date>
													</gmd:date>
													<xsl:for-each select="citeinfo/edition">
														<gmd:edition>
															<gco:CharacterString>
																<xsl:value-of select="xs:string(.)"/>
															</gco:CharacterString>
													</gmd:edition>
													</xsl:for-each>
													<gmd:citedResponsibleParty>
														<gmd:CI_ResponsibleParty>
															<gmd:organisationName>
																<!-- xsl:for-each select="citeinfo/origin" -->
																<gco:CharacterString>
																	<xsl:variable name="orgCount" >
																		<xsl:value-of select="xs:integer(fn:count(citeinfo/origin))"/>
																	</xsl:variable>
																	<xsl:for-each select="citeinfo/origin">
																		<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
																		<xsl:if test="($orgCount>1)">
																			<xsl:value-of select="xs:string(' ')"/>
																		</xsl:if>
																	</xsl:for-each>
																</gco:CharacterString>
																<!-- /xsl:for-each -->
															</gmd:organisationName>
															<gmd:role>
																<gmd:CI_RoleCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode" codeListValue="originator" codeSpace="006">
																	<xsl:value-of select="'originator'"/>
																</gmd:CI_RoleCode>
															</gmd:role>
														</gmd:CI_ResponsibleParty>
													</gmd:citedResponsibleParty>
													<gmd:presentationForm>
														<xsl:variable name="var672_map_select_citeinfo" >
															<xsl:for-each select="citeinfo/geoform">
																<xsl:value-of select="xs:string(.)"/>
															</xsl:for-each>
														</xsl:variable>
														<xsl:variable name="var654_cond_result_exists" >
															<xsl:choose>
																<xsl:when test="fn:exists($var672_map_select_citeinfo)">
																	<xsl:variable name="var674_map_select_citeinfo" >
																		<xsl:for-each select="citeinfo/geoform">
																			<xsl:variable name="var677_result_statusType" >
																				<xsl:call-template name="vmf:statusType">
																					<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(.)))"/>
																				</xsl:call-template>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var677_result_statusType)">
																				<xsl:value-of select="$var677_result_statusType"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var674_map_select_citeinfo)">
																		<xsl:value-of select="xs:string(fn:string-join($var674_map_select_citeinfo, ' '))"/>
																	</xsl:if>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:value-of select="''"/>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:variable>
														<xsl:for-each select="$var654_cond_result_exists">
															<gmd:CI_PresentationFormCode>
																<xsl:attribute name="codeList">
																	<xsl:variable name="var658_map_select_citeinfo" >
																		<xsl:for-each select="$var_largerWorkCitationNode/citeinfo/geoform"><xsl:value-of select="xs:string(.)"/>
																		</xsl:for-each>
																	</xsl:variable>
<!--																	<xsl:variable name="var657_cond_result_exists"  select="(if (fn:exists($var658_map_select_citeinfo)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ProgressCode' else '')"/>-->
																	<xsl:value-of select="xs:string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ProgressCode')"/>
																</xsl:attribute>
																<xsl:attribute name="codeListValue"><xsl:value-of select="xs:string(xs:anyURI(.))"/></xsl:attribute>
																<xsl:variable name="var664_map_select_citeinfo" >
																	<xsl:for-each select="$var_largerWorkCitationNode/citeinfo/geoform">
																		<xsl:value-of select="xs:string(.)"/>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:variable name="var661_cond_result_exists" >
																	<xsl:choose>
																		<xsl:when test="fn:exists($var664_map_select_citeinfo)">
																			<xsl:variable name="var666_map_select_citeinfo" >
																				<xsl:for-each select="$var_largerWorkCitationNode/citeinfo/geoform">
																					<xsl:variable name="var669_result_statusCode" >
																						<xsl:call-template name="vmf:statusCode">
																							<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(.)))"/>
																						</xsl:call-template>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var669_result_statusCode)">
																						<xsl:value-of select="$var669_result_statusCode"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var666_map_select_citeinfo)">
																				<xsl:value-of select="xs:string(fn:string-join($var666_map_select_citeinfo, ' '))"/>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:value-of select="''"/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:for-each select="$var661_cond_result_exists">
																	<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string(xs:anyURI(.))"/></xsl:attribute>
																</xsl:for-each>
																<xsl:value-of select="."/>
															</gmd:CI_PresentationFormCode>
														</xsl:for-each>
													</gmd:presentationForm>
													<xsl:for-each select="citeinfo/serinfo">
														<gmd:series>
															<gmd:CI_Series>
																<gmd:name>
																	<xsl:for-each select="sername">
																		<gco:CharacterString>
																			<xsl:value-of select="xs:string(.)"/>
																		</gco:CharacterString>
																	</xsl:for-each>
																</gmd:name>
																<gmd:issueIdentification>
																	<xsl:for-each select="issue">
																		<gco:CharacterString>
																			<xsl:value-of select="xs:string(.)"/>
																		</gco:CharacterString>
																	</xsl:for-each>
																</gmd:issueIdentification>
															</gmd:CI_Series>
														</gmd:series>
													</xsl:for-each>
													<gmd:otherCitationDetails>
														<xsl:for-each select="citeinfo/othercit">
															<gco:CharacterString>
																<xsl:value-of select="xs:string(.)"/>
															</gco:CharacterString>
														</xsl:for-each>
													</gmd:otherCitationDetails>
												</gmd:CI_Citation>
											</gmd:aggregateDataSetName>
											<gmd:associationType>
												<!-- xsl:variable name="var688_cond_result_exists"  select="(if (fn:exists(citeinfo/origin)) then 'largerWorkCitation' else ())"/>
												<xsl:if test="fn:exists($var688_cond_result_exists)" -->
												<gmd:DS_AssociationTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode" codeListValue="largerWorkCitation" codeSpace="002">
													<!--xsl:variable name="var689_cond_result_exists" >
															<xsl:if test="fn:exists(citeinfo/origin)">
																<xsl:variable name="var691_cond_result_exists"  select="(if (fn:exists(citeinfo/origin)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode' else ())"/>
																<xsl:if test="fn:exists($var691_cond_result_exists)">
																	<xsl:value-of select="$var691_cond_result_exists"/>
																</xsl:if>
															</xsl:if>
														</xsl:variable>
														<xsl:if test="fn:exists($var689_cond_result_exists)">
															<xsl:attribute name="codeList"><xsl:value-of select="xs:string(xs:anyURI($var689_cond_result_exists))"/></xsl:attribute>
														</xsl:if>
														<xsl:attribute name="codeListValue"><xsl:value-of select="xs:string(xs:anyURI($var688_cond_result_exists))"/></xsl:attribute>
														<xsl:variable name="var692_cond_result_exists"  select="(if (fn:exists(citeinfo/origin)) then '002' else ())"/>
														<xsl:if test="fn:exists($var692_cond_result_exists)">
															<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string(xs:anyURI($var692_cond_result_exists))"/></xsl:attribute>
														</xsl:if -->
													<xsl:value-of select="largerWorkCitation"/>
												</gmd:DS_AssociationTypeCode>
												<!--/xsl:if -->
											</gmd:associationType>
										</gmd:MD_AggregateInformation>
									</gmd:aggregationInfo>
								</xsl:for-each>
							</xsl:if>
							<xsl:if test="fn:exists(crossref)">
								<xsl:for-each select="crossref">
									<gmd:aggregationInfo>
										<gmd:MD_AggregateInformation>
											<xsl:variable name="var693_crossref" select="."/>
											<gmd:aggregateDataSetName>
												<gmd:CI_Citation>
													<gmd:title>
														<xsl:for-each select="citeinfo/title">
															<gco:CharacterString>
																<xsl:value-of select="xs:string(.)"/>
															</gco:CharacterString>
														</xsl:for-each>
													</gmd:title>
													<gmd:date>
														<gmd:CI_Date>
															<gmd:date>
																<xsl:call-template name="usgin:dateFormat">
																	<xsl:with-param name="inputDate" select="citeinfo/pubdate"/>
																	<xsl:with-param name="inputTime" select="citeinfo/pubtime"/>
																</xsl:call-template>
															</gmd:date>
															<gmd:dateType>
												<xsl:variable name="var733_cond_result_exists">
												<xsl:choose>
												<xsl:when test="(fn:exists(citeinfo/pubdate))">
												<xsl:value-of select="string('publication')"/>
												</xsl:when>
												<xsl:otherwise>
												<xsl:value-of select="''"/>
												</xsl:otherwise>
												</xsl:choose>
												</xsl:variable>
																<xsl:if test="fn:exists($var733_cond_result_exists)">
																	<gmd:CI_DateTypeCode>
														<!--				<xsl:variable name="var734_cond_result_exists"  select="(if (fn:exists(citeinfo/pubdate)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode' else ())"/>
																		<xsl:if test="fn:exists($var734_cond_result_exists)">-->
																			<xsl:attribute name="codeList">
																				<xsl:value-of select="xs:string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode')"/>
																			</xsl:attribute>
																	<!--	</xsl:if>-->
																		<xsl:attribute name="codeListValue"><xsl:value-of select="xs:string(xs:anyURI($var733_cond_result_exists))"/></xsl:attribute>
																	<!--	<xsl:variable name="var735_cond_result_exists"  select="(if (fn:exists(citeinfo/pubdate)) then '002' else ())"/>-->
																		<!--<xsl:if test="fn:exists($var735_cond_result_exists)">-->
																			<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string('002')"/></xsl:attribute>
																	<!--	</xsl:if>-->
																		<!--<xsl:value-of select="$var733_cond_result_exists"/>-->
																	</gmd:CI_DateTypeCode>
																</xsl:if>
															</gmd:dateType>
														</gmd:CI_Date>
													</gmd:date>
													<gmd:edition>
														<xsl:for-each select="citeinfo/edition">
															<gco:CharacterString>
																<xsl:value-of select="xs:string(.)"/>
															</gco:CharacterString>
														</xsl:for-each>
													</gmd:edition>
													<gmd:citedResponsibleParty>
														<gmd:CI_ResponsibleParty>
															<gmd:organisationName>
																<!--	<xsl:for-each select="citeinfo/origin"> -->
																<gco:CharacterString>
																	<xsl:variable name="orgCount" >
																		<xsl:value-of select="xs:integer(fn:count(citeinfo/origin))"/>
																	</xsl:variable>
																	<xsl:for-each select="citeinfo/origin">
																		<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
																		<xsl:if test="($orgCount>1)">
																			<xsl:value-of select="xs:string(' ')"/>
																		</xsl:if>
																	</xsl:for-each>
																</gco:CharacterString>
																<!--/xsl:for-each> -->
															</gmd:organisationName>
															<gmd:role>
																<gmd:CI_RoleCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode" codeListValue="originator" codeSpace="006">
																	<xsl:value-of select="'originator'"/>
																</gmd:CI_RoleCode>
															</gmd:role>
														</gmd:CI_ResponsibleParty>
													</gmd:citedResponsibleParty>
													<gmd:presentationForm>
														<xsl:variable name="var740_cond_result_exists" >
															<xsl:choose>
																<xsl:when test="fn:exists(citeinfo/geoform)">
																	<xsl:variable name="var754_map_select_citeinfo" >
																		<xsl:for-each select="citeinfo/geoform">
																			<xsl:variable name="var757_result_docType" >
																				<xsl:call-template name="vmf:docType">
																					<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																				</xsl:call-template>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var757_result_docType)">
																				<xsl:value-of select="$var757_result_docType"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var754_map_select_citeinfo)">
																		<xsl:value-of select="xs:string(fn:string-join($var754_map_select_citeinfo, ' '))"/>
																	</xsl:if>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:variable name="var758_map_select_citeinfo" >
																		<xsl:for-each select="citeinfo/geoform">
																			<xsl:value-of select="fn:normalize-space(xs:string(xs:string(.)))"/>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var758_map_select_citeinfo)">
																		<xsl:value-of select="xs:string(fn:string-join($var758_map_select_citeinfo, ' '))"/>
																	</xsl:if>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:variable>
														<xsl:for-each select="$var740_cond_result_exists">
															<gmd:CI_PresentationFormCode>
																<!--<xsl:variable name="var743_cond_result_exists"  select="(if (fn:exists($var693_crossref/citeinfo/geoform)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode' else ())"/>-->
																<!--<xsl:if test="fn:exists($var743_cond_result_exists)">-->
																	<xsl:attribute name="codeList"><xsl:value-of select="xs:string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode')"/></xsl:attribute>
																<!--</xsl:if>-->
																<xsl:attribute name="codeListValue"><xsl:value-of select="xs:string(xs:anyURI(.))"/></xsl:attribute>
																<xsl:variable name="var744_cond_result_exists" >
																	<xsl:if test="fn:exists($var693_crossref/citeinfo/geoform)">
																		<xsl:variable name="var748_map_select_citeinfo" >
																			<xsl:for-each select="$var693_crossref/citeinfo/geoform">
																				<xsl:variable name="var751_result_docCode" >
																					<xsl:call-template name="vmf:docCode">
																						<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var751_result_docCode)">
																					<xsl:value-of select="$var751_result_docCode"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var748_map_select_citeinfo)">
																			<xsl:value-of select="xs:string(fn:string-join($var748_map_select_citeinfo, ' '))"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:variable>
																<xsl:for-each select="$var744_cond_result_exists">
																	<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string(xs:anyURI(.))"/></xsl:attribute>
																</xsl:for-each>
																<xsl:value-of select="."/>
															</gmd:CI_PresentationFormCode>
														</xsl:for-each>
													</gmd:presentationForm>
													<gmd:series>
														<gmd:CI_Series>
															<gmd:name>
																<xsl:for-each select="citeinfo/serinfo/sername">
																	<gco:CharacterString>
																		<xsl:value-of select="xs:string(.)"/>
																	</gco:CharacterString>
																</xsl:for-each>
															</gmd:name>
															<gmd:issueIdentification>
																<xsl:for-each select="citeinfo/serinfo/issue">
																	<gco:CharacterString>
																		<xsl:value-of select="xs:string(.)"/>
																	</gco:CharacterString>
																</xsl:for-each>
															</gmd:issueIdentification>
														</gmd:CI_Series>
													</gmd:series>
													<gmd:otherCitationDetails>
														<xsl:for-each select="citeinfo/othercit">
															<gco:CharacterString>
																<xsl:value-of select="xs:string(.)"/>
															</gco:CharacterString>
														</xsl:for-each>
													</gmd:otherCitationDetails>
												</gmd:CI_Citation>
											</gmd:aggregateDataSetName>
											<!-- /xsl:for-each -->
											<gmd:associationType>
												<xsl:variable name="var767_cond_result_exists">
													<xsl:choose>
														<xsl:when test="fn:exists($var_idinfoSourceNode/crossref/citeinfo/origin)"> 
															<xsl:value-of select="string('crossReference')"/>
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="string('')"/>
														</xsl:otherwise>
													</xsl:choose>
												</xsl:variable>  
												<xsl:if test="fn:exists($var_idinfoSourceNode/crossref/citeinfo/origin)">
													<gmd:DS_AssociationTypeCode>
<!--														<xsl:variable name="var768_cond_result_exists" >
															<xsl:if test="fn:exists($var_idinfoSourceNode/crossref/citeinfo/origin)">
																<xsl:variable name="var770_cond_result_exists"  select="(if (fn:exists(citeinfo/origin)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode' else ())"/>
																<xsl:if test="fn:exists($var770_cond_result_exists)">
																	<xsl:value-of select="$var770_cond_result_exists"/>
																</xsl:if>
															</xsl:if>
														</xsl:variable>
														<xsl:if test="fn:exists($var768_cond_result_exists)">-->
															<xsl:attribute name="codeList"><xsl:value-of select="xs:string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode')"/></xsl:attribute>
														<!--</xsl:if>-->
														<xsl:attribute name="codeListValue"><xsl:value-of select="xs:string($var_idinfoSourceNode/crossref/citeinfo/origin)"/></xsl:attribute>
													<!--	<xsl:variable name="var771_cond_result_exists"  select="(if (fn:exists($var_idinfoSourceNode/crossref/citeinfo/origin)) then '001' else ())"/>
														<xsl:if test="fn:exists($var771_cond_result_exists)">-->
															<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string('001')"/></xsl:attribute>
														<!--</xsl:if>-->
														<xsl:value-of select="$var767_cond_result_exists"/>
													</gmd:DS_AssociationTypeCode>
												</xsl:if>
											</gmd:associationType>
										</gmd:MD_AggregateInformation>
									</gmd:aggregationInfo>
								</xsl:for-each>
							</xsl:if>
							<!-- ******************************************************************************************************************* -->
							<!-- Spatial Representation -->
							<xsl:for-each select="$var_metadataRoot/spdoinfo">
								<gmd:spatialRepresentationType>
									<xsl:for-each select="direct">
										<xsl:variable name="var563_result_spatialRepresentationType" >
											<xsl:call-template name="vmf:spatialRepresentationType">
												<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
											</xsl:call-template>
										</xsl:variable>
										<xsl:if test="fn:exists($var563_result_spatialRepresentationType)">
											<gmd:MD_SpatialRepresentationTypeCode>
												<xsl:attribute name="codeList"><xsl:value-of select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_SpatialRepresentationTypeCode'))"/></xsl:attribute>
												<xsl:attribute name="codeListValue"><xsl:value-of select="xs:string(xs:anyURI($var563_result_spatialRepresentationType))"/></xsl:attribute>
												<xsl:variable name="var564_result_spatialRepresentationCode" >
													<xsl:call-template name="vmf:spatialRepresentationCode">
														<xsl:with-param name="input" select="$var563_result_spatialRepresentationType"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:if test="fn:exists($var564_result_spatialRepresentationCode)">
													<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string(xs:anyURI($var564_result_spatialRepresentationCode))"/></xsl:attribute>
												</xsl:if>
												<xsl:value-of select="$var563_result_spatialRepresentationType"/>
											</gmd:MD_SpatialRepresentationTypeCode>
										</xsl:if>
									</xsl:for-each>
								</gmd:spatialRepresentationType>
							</xsl:for-each>
							<!-- resource language -->
							<gmd:language>
								<gco:CharacterString>
									<xsl:value-of select="'eng'"/>
								</gco:CharacterString>
							</gmd:language>
							<!-- messy logic to extract ISO topic category  -->
							<xsl:variable name="hasISOtopic">
								<xsl:for-each select="keywords/theme">
									<xsl:for-each select="themekey">
										<xsl:if test="fn:contains(' biota boundaries climatologyMeteorologyAtmosphere 
economy elevation environment farming geoscientificInformation 
health imageryBaseMapsEarthCover inlandWaters intelligenceMilitary 
location oceans planningCadastre society structure transportation 
utilitiesCommunication', concat(' ',string(.)))">
											<!-- set hasISOtopic variable -->
											<xsl:value-of select="string(.)"/>
										</xsl:if>
									</xsl:for-each>
									<!--		</xsl:if>  -->
								</xsl:for-each>
								<!--	 flag to indicate if catch an ISO topic -->
							</xsl:variable>
							<xsl:choose>
								<xsl:when test="string-length($hasISOtopic)>0">
									<gmd:topicCategory>
										<gmd:MD_TopicCategoryCode>
											<xsl:value-of select="string($hasISOtopic)"/>
										</gmd:MD_TopicCategoryCode>
									</gmd:topicCategory>
									<xsl:value-of select="$hasISOtopic"/>
								</xsl:when>
								<xsl:otherwise>
									<gmd:topicCategory gco:nilReason="missing">
										<gmd:MD_TopicCategoryCode>
											<!-- put in a dummy value so will pass profile rules -->
											<xsl:value-of select="string('geoscientificInformation')"/>
										</gmd:MD_TopicCategoryCode>
									</gmd:topicCategory>
								</xsl:otherwise>
							</xsl:choose>
							<!-- end topic category section -->
							<xsl:for-each select="native">
								<xsl:variable name="var_nativeEnvironmentNode" select="."/>
								<gmd:environmentDescription>
									<xsl:variable name="var574_cond_result_exists" >
										<xsl:choose>
											<xsl:when test="fn:exists($var_metadataRoot/distinfo/techpreq)">
												<xsl:variable name="var579_map_select_distinfo" >
													<xsl:for-each select="$var_metadataRoot/distinfo/techpreq">
														<xsl:value-of select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:variable>
												<xsl:if test="fn:exists($var579_map_select_distinfo)">
													<xsl:value-of select="fn:string-join($var579_map_select_distinfo, ' ')"/>
												</xsl:if>
											</xsl:when>
											<xsl:otherwise>
												<xsl:value-of select="' '"/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:for-each select="$var574_cond_result_exists">
										<gco:CharacterString>
											<xsl:variable name="var577_cond_result_exists">
												<xsl:if test="(fn:exists($var_metadataRoot/distinfo/techpreq))"> 
													<xsl:value-of select="string(' Technical Prerequisites: ')"/>
												</xsl:if>
											</xsl:variable>  
											<xsl:value-of select="fn:string(fn:concat('Native Dataset Environment: ', xs:string($var_nativeEnvironmentNode), $var577_cond_result_exists, .))"/>
										</gco:CharacterString>
									</xsl:for-each>
								</gmd:environmentDescription>
							</xsl:for-each>
							<!-- Extent section, geographic, vertical, temporal... -->
							<gmd:extent>
								<gmd:EX_Extent>
									<xsl:attribute name="id"><xsl:value-of select="generate-id()"/></xsl:attribute>
									<gmd:geographicElement>
										<!-- bounding box is mandatory, spatial reference should be EPSG 4326, ie WGS 84 -->
										<!-- geographic extent, lat long bounding box required for USGIN -->
										<gmd:EX_GeographicBoundingBox>
											<xsl:attribute name="id"><xsl:value-of select="fn:concat('gbb.', generate-id())"/></xsl:attribute>
											<gmd:westBoundLongitude>
												<gco:Decimal>
													<xsl:choose>
														<xsl:when test="number(spdom/bounding/westbc)=number(spdom/bounding/westbc)">
															<xsl:value-of select="xs:string(xs:decimal(spdom/bounding/westbc))"/>
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="xs:string(-179.9)"/>
														</xsl:otherwise>
													</xsl:choose>
												</gco:Decimal>
											</gmd:westBoundLongitude>
											<gmd:eastBoundLongitude>
												<gco:Decimal>
													<xsl:choose>
														<xsl:when test="number(spdom/bounding/eastbc) = number(spdom/bounding/eastbc)">
															<xsl:value-of select="xs:string(xs:decimal(spdom/bounding/eastbc))"/>
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="xs:string(-60)"/>
														</xsl:otherwise>
													</xsl:choose>
												</gco:Decimal>
											</gmd:eastBoundLongitude>
											<gmd:southBoundLatitude>
												<gco:Decimal>
													<xsl:choose>
														<xsl:when test="number(spdom/bounding/southbc)=number(spdom/bounding/southbc)">
															<xsl:value-of select="xs:string(xs:decimal(spdom/bounding/southbc))"/>
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="xs:string(14)"/>
														</xsl:otherwise>
													</xsl:choose>
												</gco:Decimal>
											</gmd:southBoundLatitude>
											<gmd:northBoundLatitude>
												<gco:Decimal>
													<xsl:choose>
														<xsl:when test="number(spdom/bounding/northbc)=number(spdom/bounding/northbc)">
															<xsl:value-of select="xs:string(xs:decimal(spdom/bounding/northbc))"/>
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="xs:string(170)"/>
														</xsl:otherwise>
													</xsl:choose>
												</gco:Decimal>
											</gmd:northBoundLatitude>
										</gmd:EX_GeographicBoundingBox>
									</gmd:geographicElement>
									<xsl:for-each select="spdom/dsgpoly">
										<gmd:geographicElement>
											<!-- handle extent encoded as a polygon -->
											<xsl:variable name="var582_dsgpoly" select="."/>
											<gmd:EX_BoundingPolygon>
												<gmd:polygon>
													<gml:Polygon>
														<xsl:attribute name="gml:id"><xsl:value-of select="fn:concat('boundingPoly.',generate-id())"/></xsl:attribute>
														<gml:interior>
															<gml:LinearRing>
																<gml:coordinates>
																	<xsl:variable name="var587_map_select_grngpoin" >
																		<xsl:for-each select="dsgpolyo/grngpoin">
																			<xsl:value-of select="fn:concat(xs:string(gringlat), ', ', xs:string(gringlon), '; ')"/>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var584_cond_result_exists" >
																		<xsl:choose>
																			<xsl:when test="fn:exists($var587_map_select_grngpoin)">
																				<xsl:for-each select="dsgpolyo/grngpoin">
																					<xsl:value-of select="fn:concat(xs:string(gringlat), ', ', xs:string(gringlon), '; ')"/>
																				</xsl:for-each>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:for-each select="dsgpolyo/gring">
																					<xsl:value-of select="xs:string(.)"/>
																				</xsl:for-each>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:for-each select="$var584_cond_result_exists">
																		<xsl:attribute name="decimal"><xsl:value-of select="fn:normalize-space(.)"/></xsl:attribute>
																	</xsl:for-each>
																</gml:coordinates>
															</gml:LinearRing>
														</gml:interior>
													</gml:Polygon>
												</gmd:polygon>
											</gmd:EX_BoundingPolygon>
										</gmd:geographicElement>
									</xsl:for-each>
									<!-- temporal extent, single date -->
									<xsl:for-each select="timeperd/timeinfo/sngdate">
										<xsl:variable name="var_extentSingleDate" select="."/>
										<gmd:temporalElement>
											<gmd:EX_TemporalExtent>
												<xsl:attribute name="id"><xsl:value-of select="fn:concat('TempEx.', generate-id())"/></xsl:attribute>
												<gmd:extent>
													<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished'))">
														<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(caldate)))))"/></xsl:attribute>
													</xsl:if>
													<gml:TimeInstant>
														<xsl:attribute name="gml:id"><xsl:value-of select="fn:concat('TInst.',generate-id())"/></xsl:attribute>
														<gml:description>
															<xsl:value-of select="xs:string(xs:string($var_metadataRoot/idinfo/timeperd/current))"/>
														</gml:description>
														<!-- now process the dates -->
														<!--						<xsl:variable name="var_DateTemp"> -->
														<xsl:variable name="var_TimePos" >
															<xsl:call-template name="usgin:TimePositionFormat">
																<xsl:with-param name="inputDate" select="(caldate)"/>
																<xsl:with-param name="inputTime" select="(time)"/>
															</xsl:call-template>
														</xsl:variable>
														<gml:timePosition>
															<xsl:variable name="castableAsDateTime">
																<xsl:value-of select="(substring($var_TimePos,5,1)='-') and (substring($var_TimePos,8,1)='-') and (substring($var_TimePos,11,1)='T') and (substring($var_TimePos,14,1)=':') and (substring($var_TimePos,17,1)=':')"/>
															</xsl:variable>
															<xsl:choose>
																<xsl:when test="$castableAsDateTime">
																	<xsl:value-of select="$var_TimePos"/>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:attribute name="indeterminatePosition"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
																</xsl:otherwise>
															</xsl:choose>
														</gml:timePosition>
														<!-- /xsl:for-each -->
													</gml:TimeInstant>
												</gmd:extent>
											</gmd:EX_TemporalExtent>
										</gmd:temporalElement>
									</xsl:for-each>
									<!-- temmporal extent, multiple individual dates and times. 
						 guess the idea is there might be multple mdattim/sngdate elements?-->
									<xsl:for-each select="timeperd/timeinfo/mdattim/sngdate">
										<xsl:variable name="var713_sngdate" select="."/>
										<gmd:temporalElement>
											<gmd:EX_TemporalExtent>
												<xsl:attribute name="id"><xsl:value-of select="fn:concat('TimePeriodEx.', generate-id())"/></xsl:attribute>
												<gmd:extent>
													<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished'))">
														<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(caldate)))))"/></xsl:attribute>
													</xsl:if>
													<gml:TimeInstant>
														<xsl:attribute name="gml:id"><xsl:value-of select="fn:concat('ATimeInstant.',generate-id())"/></xsl:attribute>
														<gml:description>
															<xsl:value-of select="xs:string(xs:string($var_metadataRoot/idinfo/timeperd/current))"/>
														</gml:description>
														<gml:timePosition>
														<!--	<xsl:variable name="var718_cond_result_exists"  select="(if (fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var713_sngdate/caldate))), 'present')) then 'now' else ()))) then (if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var713_sngdate/caldate))), 'present')) then 'now' else ()) else 'unknown')"/>-->
															<xsl:if test="fn:exists($var713_sngdate/caldate)">
																<xsl:attribute name="indeterminatePosition"><xsl:value-of select="string('now')"/></xsl:attribute>
															</xsl:if>
															<xsl:value-of select="xs:string(xs:string(.))"/>
														</gml:timePosition>
														<!-- /xsl:for-each -->
														<!-- can't use tempalate because that puts date in a gco:DateTime elelent, but needs to be gml:TimePosition here -->
														<xsl:variable name="var_DateTemp">
															<xsl:call-template name="usgin:dateFormat">
																<xsl:with-param name="inputDate" select="(caldate)"/>
																<xsl:with-param name="inputTime" select="(time)"/>
															</xsl:call-template>
														</xsl:variable>
														<gml:timePosition>
															<xsl:for-each select="var_DateTemp">
																<xsl:choose>
																	<xsl:when test="fn:exists(gco:DateTime)">
																		<xsl:value-of select="fn:string(gco:DateTime)"/>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:attribute name="indeterminatePosition"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:for-each>
														</gml:timePosition>
													</gml:TimeInstant>
												</gmd:extent>
											</gmd:EX_TemporalExtent>
										</gmd:temporalElement>
									</xsl:for-each>
									<!-- temporal extent, range of dates and time -->
									<!-- each rngdates has a rngdates/begdate begtime, and /enddate /endtime -->
									<xsl:for-each select="timeperd/timeinfo/rngdates">
										<xsl:variable name="var_rngdatesNode" select="."/>
										<gmd:temporalElement>
											<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished'))">
												<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(begdate)))))"/></xsl:attribute>
											</xsl:if>
											<gmd:EX_TemporalExtent>
												<xsl:attribute name="id"><xsl:value-of select="fn:concat('DateRngEx.', generate-id())"/></xsl:attribute>
												<gmd:extent>
													<gml:TimePeriod>
														<xsl:attribute name="gml:id"><xsl:value-of select="fn:concat('bndTimePeriod.',generate-id())"/></xsl:attribute>
														<gml:description>
															<xsl:value-of select="xs:string(xs:string($var_metadataRoot/idinfo/timeperd/current))"/>
														</gml:description>
														<gml:beginPosition>
															<xsl:if test="fn:contains(fn:lower-case(fn:normalize-space(fn:string($var_rngdatesNode/begdate))), 'present')"> 
																<xsl:attribute name="indeterminatePosition"><xsl:value-of select="string('now')"/></xsl:attribute>
															</xsl:if>
															<!-- xsl:value-of select="xs:string(xs:string(.))"/ -->
															<!-- can't use tempalate because that puts date in a gco:DateTime elelent, but needs to be gml:TimePosition here -->
															<xsl:variable name="var_DateTemp">
																<xsl:call-template name="usgin:dateFormat">
																	<xsl:with-param name="inputDate" select="(begdate)"/>
																	<xsl:with-param name="inputTime" select="(begtime)"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:for-each select="var_DateTemp">
																<xsl:choose>
																	<xsl:when test="fn:exists(gco:DateTime)">
																		<xsl:value-of select="fn:string(gco:DateTime)"/>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:attribute name="indeterminatePosition"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:for-each>
														</gml:beginPosition>
														<!-- /xsl:for-each -->
														<gml:endPosition>
															<xsl:if test="fn:contains(fn:lower-case(fn:normalize-space(fn:string($var_rngdatesNode/enddate))), 'present')"> 
																<xsl:attribute name="indeterminatePosition"><xsl:value-of select="string('now')"/></xsl:attribute>
															</xsl:if>
															<xsl:variable name="var_DateTemp">
																<xsl:call-template name="usgin:dateFormat">
																	<xsl:with-param name="inputDate" select="(enddate)"/>
																	<xsl:with-param name="inputTime" select="(endtime)"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:for-each select="var_DateTemp">
																<xsl:choose>
																	<xsl:when test="fn:exists(gco:DateTime)">
																		<xsl:value-of select="fn:string(gco:DateTime)"/>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:attribute name="indeterminatePosition"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:for-each>
														</gml:endPosition>
													</gml:TimePeriod>
												</gmd:extent>
											</gmd:EX_TemporalExtent>
										</gmd:temporalElement>
									</xsl:for-each>
								</gmd:EX_Extent>
							</gmd:extent>
							<!-- supplemental information text blob... -->
							<xsl:for-each select="descript/supplinf">
								<gmd:supplementalInformation>
									<gco:CharacterString>
										<xsl:value-of select="xs:string(.)"/>
									</gco:CharacterString>
								</gmd:supplementalInformation>
							</xsl:for-each>
						</gmd:MD_DataIdentification>
					</gmd:identificationInfo>
				</xsl:for-each>
			</xsl:for-each>
			<!-- content information section -->
			<!-- replaced contentInfo with choose -->
			<gmd:contentInfo>
				<xsl:choose>
					<xsl:when test="(fn:exists($var_metadataRoot/eainfo/detailed))">
						<gmd:MD_FeatureCatalogueDescription>
							<gmd:includedWithDataset>
								<gco:Boolean>
							<!--		<xsl:variable name="var1068_cond_result_exists" as="xs:decimal" select="(if (fn:exists($var_metadataRoot/eainfo/detailed)) then xs:decimal(1) else xs:decimal(0))"/>-->
									<xsl:value-of select="xs:string(fn:boolean(fn:exists($var_metadataRoot/eainfo/detailed)))"/>
								</gco:Boolean>
							</gmd:includedWithDataset>
							<xsl:for-each select="$var_metadataRoot/eainfo/detailed">
								<gmd:featureTypes>
									<gco:LocalName>
										<xsl:attribute name="codeSpace"><xsl:value-of select="fn:normalize-space(xs:string(enttyp/enttypl))"/></xsl:attribute>
									</gco:LocalName>
								</gmd:featureTypes>
							</xsl:for-each>
							<gmd:featureCatalogueCitation>
								<!--<xsl:variable name="var_eainfoDetailedExists" as="xs:decimal" select="(if (fn:exists($var_metadataRoot/eainfo/detailed)) then xs:decimal(1) else xs:decimal(0))"/>-->
								<xsl:if test="fn:exists($var_metadataRoot/eainfo/detailed)">
									<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
								</xsl:if>
								<xsl:variable name="var_eainfoEaoverLabel">  
									<xsl:choose>
										<xsl:when test="fn:exists($var_metadataRoot/eainfo/overview/eaover)"> 
											<xsl:value-of select="string('Entity and Attribute Overview: ')"/>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="string('')"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:if test="fn:exists($var_eainfoEaoverLabel)">
									<xsl:variable name="var_eainfoEaoverText" >
										<xsl:variable name="var_eainfoEaoverTextSeq" >
											<xsl:for-each select="$var_metadataRoot/eainfo/overview">
												<xsl:value-of select="xs:string(eaover)"/>
											</xsl:for-each>
										</xsl:variable>
										<xsl:if test="fn:exists($var_eainfoEaoverTextSeq)">
											<xsl:value-of select="fn:string-join($var_eainfoEaoverTextSeq, ' ')"/>
										</xsl:if>
									</xsl:variable>
									<xsl:for-each select="$var_eainfoEaoverText">
										<!-- xsl:variable name="var1074_cur_cond_result_exists"  select="."/ -->
										<xsl:variable name="var_eainfoEadetcitLabel">
											<xsl:choose>
												<xsl:when test="fn:exists($var_metadataRoot/eainfo/overview/eadetcit)"> 
													<xsl:value-of select="string('   Entity and Attribute Detail Citation: ')"/>
												</xsl:when>
												<xsl:otherwise>
													<xsl:value-of select="string('')"/>
												</xsl:otherwise>
											</xsl:choose>
									</xsl:variable> 
										<xsl:if test="fn:exists($var_eainfoEadetcitLabel)">
											<xsl:variable name="var_eainfoEadetcitText" >
												<xsl:if test="fn:exists($var_metadataRoot/eainfo/overview/eadetcit)">
													<xsl:variable name="var1081_map_select_metadata" >
														<xsl:for-each select="$var_metadataRoot/eainfo/overview/eadetcit">
															<xsl:value-of select="xs:string(.)"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:if test="fn:exists($var1081_map_select_metadata)">
														<xsl:value-of select="fn:string-join($var1081_map_select_metadata, ' ')"/>
													</xsl:if>
												</xsl:if>
											</xsl:variable>
											<gmd:CI_Citation>
												<gmd:title>
													<gco:CharacterString>
														<xsl:value-of select="'Entity and Attribute Information'"/>
													</gco:CharacterString>
												</gmd:title>
												<gmd:date>
													<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
												</gmd:date>
												<gmd:otherCitationDetails>
													<gco:CharacterString>
														<xsl:value-of select="fn:normalize-space(fn:concat($var_eainfoEaoverLabel, $var_eainfoEaoverText, $var_eainfoEadetcitLabel, $var_eainfoEadetcitText))"/>
													</gco:CharacterString>
												</gmd:otherCitationDetails>
											</gmd:CI_Citation>
											<!-- /xsl:for-each -->
										</xsl:if>
									</xsl:for-each>
								</xsl:if>
							</gmd:featureCatalogueCitation>
						</gmd:MD_FeatureCatalogueDescription>
					</xsl:when>
					<xsl:otherwise>
						<xsl:if test="fn:exists($var_metadataRoot/dataqual/cloud)">
							<gmd:MD_ImageDescription>
								<gmd:cloudCoverPercentage>
									<xsl:choose>
										<xsl:when test="fn:contains(fn:lower-case(xs:string($var_metadataRoot/dataqual/cloud)), 'unknown')">
											<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
										</xsl:when>
										<xsl:when test="number($var_metadataRoot/dataqual/cloud[1])=number($var_metadataRoot/dataqual/cloud[1])">
											<gco:Real>
												<xsl:value-of select="xs:string($var_metadataRoot/dataqual/cloud[1])"/>
											</gco:Real>
										</xsl:when>
										<xsl:otherwise>
											<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string('missing')"/></xsl:attribute>
										</xsl:otherwise>
									</xsl:choose>
								</gmd:cloudCoverPercentage>
							</gmd:MD_ImageDescription>
						</xsl:if>
						<!--/xsl:value-of> -->
					</xsl:otherwise>
				</xsl:choose>
			</gmd:contentInfo>
			<!-- for FGDC record, assume only a single distribution distributor/transferOption/format will be specified -->
			<gmd:distributionInfo>
				<gmd:MD_Distribution>
					<xsl:for-each select="$var_metadataRoot/distinfo/stdorder/digform">
						<xsl:variable name="var1090_digform" select="."/>
						<!-- distribution format -->
						<gmd:distributionFormat>
							<gmd:MD_Format>
								<gmd:name>
									<gco:CharacterString>
										<xsl:value-of select="fn:normalize-space(xs:string(digtinfo/formname))"/>
									</gco:CharacterString>
								</gmd:name>
								<gmd:version>
									<xsl:variable name="var1092_cond_result_exists" >
										<xsl:choose>
											<xsl:when test="$var1090_digform/digtinfo/formvern">
												<xsl:for-each select="digtinfo/formvern">
													<xsl:value-of select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:when>
											<xsl:otherwise>
												<xsl:value-of select="'unknown'"/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:if test="fn:exists($var1092_cond_result_exists)">
										<xsl:if test="($var1092_cond_result_exists = 'unknown')">
											<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
										</xsl:if>
									</xsl:if>
									<xsl:for-each select="digtinfo/formvern">
										<xsl:variable name="var1099_cond_result_equal" >
											<xsl:if test="not((fn:lower-case(xs:string(.)) = 'unknown'))">
												<xsl:variable name="var1103_map_select_formverd" >
													<xsl:for-each select="$var1090_digform/digtinfo/formverd">
														<xsl:value-of select="fn:string(.)"/>
													</xsl:for-each>
												</xsl:variable>
												<xsl:variable name="var1102_cond_result_exists" >
													<xsl:choose>
														<xsl:when test="fn:exists($var1103_map_select_formverd)">
															<xsl:for-each select="$var1090_digform/digtinfo/formverd">
																<xsl:value-of select="fn:string(.)"/>
															</xsl:for-each>
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="' '"/>
														</xsl:otherwise>
													</xsl:choose>
												</xsl:variable>
												<xsl:if test="fn:exists($var1102_cond_result_exists)">
													<xsl:value-of select="fn:normalize-space(fn:string(fn:concat(xs:string(.), $var1102_cond_result_exists)))"/>
												</xsl:if>
											</xsl:if>
										</xsl:variable>
										<xsl:if test="fn:exists($var1099_cond_result_equal)">
											<gco:CharacterString>
												<xsl:value-of select="$var1099_cond_result_equal"/>
											</gco:CharacterString>
										</xsl:if>
									</xsl:for-each>
								</gmd:version>
								<xsl:for-each select="digtinfo/formspec">
									<gmd:specification>
										<gco:CharacterString>
											<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
										</gco:CharacterString>
									</gmd:specification>
								</xsl:for-each>
								<xsl:for-each select="digtinfo/filedec">
									<gmd:fileDecompressionTechnique>
										<gco:CharacterString>
											<xsl:value-of select="fn:normalize-space(xs:string(xs:string(.)))"/>
										</gco:CharacterString>
									</gmd:fileDecompressionTechnique>
								</xsl:for-each>
							</gmd:MD_Format>
						</gmd:distributionFormat>
					</xsl:for-each>
					<xsl:for-each select="$var_metadataRoot/distinfo">
						<xsl:variable name="var1113_distinfo" select="."/>
						<!-- distributor information -->
						<gmd:distributor>
							<gmd:MD_Distributor>
								<gmd:distributorContact>
									<gmd:CI_ResponsibleParty>
										<xsl:variable name="var_contactIndividual_exists" >
											<xsl:choose>
												<xsl:when test="fn:exists(distrib/cntinfo/cntperp/cntper)">
													<!-- old xsl:when test="fn:exists($var5_map_select_metadata)" -->
													<xsl:for-each select="distrib/cntinfo/cntperp/cntper">
														<xsl:value-of select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:when>
												<xsl:otherwise>
													<xsl:for-each select="distrib/cntinfo/cntorgp/cntper">
														<xsl:value-of select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<xsl:variable name="var_contactOrganisation_exists" >
											<xsl:choose>
												<xsl:when test="fn:exists(distrib/cntinfo/cntperp/cntorg)">
													<xsl:for-each select="distrib/cntinfo/cntperp/cntorg">
														<xsl:value-of select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:when>
												<xsl:otherwise>
													<xsl:for-each select="distrib/cntinfo/cntorgp/cntorg">
														<xsl:value-of select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<!-- done scraping content for contact name -->
										<!-- now populate the elements count(individualName + OrganisationName + positionName) must be >0 -->
										<xsl:call-template name="usgin:contactName">
											<xsl:with-param name="inputPersonNode" select="$var_contactIndividual_exists"/>
											<xsl:with-param name="inputOrganizationNode" select="($var_contactOrganisation_exists)"/>
											<xsl:with-param name="inputPositionNode" select="(distrib/cntinfo/cntpos)"/>
										</xsl:call-template>
										<gmd:contactInfo>
											<gmd:CI_Contact>
												<xsl:call-template name="usgin:telephoneFormat">
													<xsl:with-param name="telNode" select="(distrib/cntinfo)"/>
												</xsl:call-template>
												<gmd:address>
													<gmd:CI_Address>
														<xsl:call-template name="usgin:addressFormat">
															<xsl:with-param name="inputAddr" select="distrib/cntinfo/cntaddr[1]"/>
														</xsl:call-template>
														<!-- done with postal address elements, now the e-mail. Set this up so that some value gets inserted -->
														<xsl:call-template name="usgin:emailFormat">
															<xsl:with-param name="emailNode" select="distrib/cntinfo"/>
														</xsl:call-template>
													</gmd:CI_Address>
												</gmd:address>
												<!-- /xsl:for-each -->
												<xsl:for-each select="distrib/cntinfo/hours">
													<gmd:hoursOfService>
														<gco:CharacterString>
															<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
														</gco:CharacterString>
													</gmd:hoursOfService>
												</xsl:for-each>
												<xsl:for-each select="distrib/cntinfo/cntinst">
													<gmd:contactInstructions>
														<gco:CharacterString>
															<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
														</gco:CharacterString>
													</gmd:contactInstructions>
												</xsl:for-each>
											</gmd:CI_Contact>
										</gmd:contactInfo>
										<gmd:role>
											<gmd:CI_RoleCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode" codeListValue="distributor" codeSpace="005">
												<xsl:value-of select="xs:string('distributor')"/>
											</gmd:CI_RoleCode>
										</gmd:role>
									</gmd:CI_ResponsibleParty>
								</gmd:distributorContact>
								<!-- ordering process information -->
								<xsl:for-each select="stdorder">
									<xsl:variable name="var1159_stdorder" select="."/>
									<gmd:distributionOrderProcess>
										<gmd:MD_StandardOrderProcess>
											<gmd:fees>
												<gco:CharacterString>
													<xsl:value-of select="fn:normalize-space(xs:string(fees))"/>
												</gco:CharacterString>
											</gmd:fees>
											<xsl:for-each select="$var1113_distinfo/availabl">
												<xsl:if test="fn:exists(timeinfo/sngdate)">
													<gmd:plannedAvailableDateTime>
														<xsl:call-template name="usgin:dateFormat">
															<xsl:with-param name="inputDate" select="caldate"/>
															<xsl:with-param name="inputTime" select="(time)"/>
														</xsl:call-template>
													</gmd:plannedAvailableDateTime>
												</xsl:if>
											</xsl:for-each>
											<xsl:for-each select="ordering">
												<xsl:variable name="var1542_ordering" select="."/>
												<gmd:orderingInstructions>
													<xsl:variable name="var1544_cond_result_exists" >
														<xsl:choose>
															<xsl:when test="fn:exists($var1159_stdorder/digform/digtopt/onlinopt/accinstr)">
																<xsl:variable name="var1559_map_select_digform" >
																	<xsl:for-each select="$var1159_stdorder/digform/digtopt/onlinopt/accinstr">
																		<xsl:value-of select="xs:string(.)"/>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:if test="fn:exists($var1559_map_select_digform)">
																	<xsl:value-of select="fn:string-join($var1559_map_select_digform, ' ')"/>
																</xsl:if>
															</xsl:when>
															<xsl:otherwise>
																<xsl:value-of select="' '"/>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:for-each select="$var1544_cond_result_exists">
														<xsl:variable name="var1547_cond_result_exists" >
															<xsl:choose>
																<xsl:when test="$var1159_stdorder/nondig">
																	<xsl:for-each select="$var1159_stdorder/nondig">
																		<xsl:value-of select="xs:string(.)"/>
																	</xsl:for-each>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:value-of select="' '"/>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:variable>
														<xsl:if test="fn:exists($var1547_cond_result_exists)">
															<xsl:variable name="var1548_cond_result_exists" >
																<xsl:choose>
																	<xsl:when test="$var1113_distinfo/custom">
																		<xsl:for-each select="$var1113_distinfo/custom">
																			<xsl:value-of select="xs:string(.)"/>
																		</xsl:for-each>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:value-of select="' '"/>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:if test="fn:exists($var1548_cond_result_exists)">
																<gco:CharacterString>
																	<xsl:variable name="var1549_cond_result_exists">  
																		<xsl:choose>
																			<xsl:when test="fn:exists($var1159_stdorder/digform/digtopt/onlinopt/accinstr)"> 
																				<xsl:value-of select="string('Access Instructions: ' )"/>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:value-of select="string('')"/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>	
																	<xsl:variable name="var1550_cond_result_exists">
																		<xsl:choose>
																			<xsl:when test="fn:exists($var1159_stdorder/nondig)"> 
																				<xsl:value-of select="string('Non-Digital Form: ')"/>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:value-of select="string('')"/>
																			</xsl:otherwise>
																		</xsl:choose>
																		
																	</xsl:variable>
																	<xsl:variable name="var1551_cond_result_exists">
																		<xsl:choose>
																			<xsl:when test="fn:exists($var1113_distinfo/custom)"> 
																				<xsl:value-of select="string(' Custom Order Process: ')"/>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:value-of select="string('')"/>
																			</xsl:otherwise>
																		</xsl:choose>
																		
																	</xsl:variable>																	<xsl:value-of select="fn:normalize-space(fn:concat($var1549_cond_result_exists, ., $var1550_cond_result_exists, ' ', $var1547_cond_result_exists, ' ', 'Ordering Instructions: ', xs:string($var1542_ordering), $var1551_cond_result_exists, $var1548_cond_result_exists))"/>
																</gco:CharacterString>
															</xsl:if>
														</xsl:if>
													</xsl:for-each>
												</gmd:orderingInstructions>
											</xsl:for-each>
											<xsl:for-each select="turnarnd">
												<gmd:turnaround>
													<gco:CharacterString>
														<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</gmd:turnaround>
											</xsl:for-each>
										</gmd:MD_StandardOrderProcess>
									</gmd:distributionOrderProcess>
								</xsl:for-each>
							</gmd:MD_Distributor>
						</gmd:distributor>
					</xsl:for-each>
					<gmd:transferOptions>
						<gmd:MD_DigitalTransferOptions>
							<xsl:for-each select="$var_metadataRoot/distinfo/stdorder/digform/digtinfo/transize">
								<gmd:transferSize>
									<gco:Real>
										<xsl:value-of select="xs:string(xs:double(.))"/>
									</gco:Real>
								</gmd:transferSize>
							</xsl:for-each>
							<!-- find text to put in online linkage description and name -->
							<xsl:variable name="var_networkResourceName" >
								<xsl:for-each select="$var_metadataRoot/distinfo/stdorder/digform/digtopt/onlinopt/computer/networka/networkr">
									<!-- The name of the data set on the network. When appropriate, Uniform Resource Locators (URL) should be provided. -->
									<xsl:value-of select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:variable>
							<xsl:variable name="var_ResourceIdentifer" >
								<xsl:for-each select="$var_metadataRoot/distinfo/resdesc">
									<!-- the identifier by which the distributor knows the data set. -->
									<xsl:value-of select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:variable>
							<xsl:variable name="var_OnlineName" >
								<xsl:choose>
									<xsl:when test="fn:exists($var_ResourceIdentifer)">
										<xsl:value-of select="$var_ResourceIdentifer"/>
									</xsl:when> 
									<xsl:otherwise> 
										<xsl:value-of select="string('NoResdesc')"/>
									</xsl:otherwise>
								</xsl:choose>
								<xsl:choose>
									<xsl:when test="fn:exists($var_networkResourceName)">
										<xsl:value-of select="concat(' ',string($var_networkResourceName))"/>
									</xsl:when> 
									<xsl:otherwise> 
										<xsl:value-of select="string(' NoNetworkr')"/>
									</xsl:otherwise>
								</xsl:choose>
							</xsl:variable>
							<xsl:for-each select="$var_metadataRoot/idinfo/citation/citeinfo/onlink">
								<gmd:onLine>
									<gmd:CI_OnlineResource>
										<gmd:linkage>
											<gmd:URL>
												<xsl:value-of select="xs:string(xs:anyURI(fn:normalize-space(.)))"/>
											</gmd:URL>
										</gmd:linkage>
										<gmd:name>
											<gco:CharacterString>
												<xsl:value-of select=" concat($var_OnlineName,substring(.,string-length(.)-3, 4))"/>
												<!-- if theres a 3 char file extension, it will help figure out the link -->
											</gco:CharacterString>
										</gmd:name>
										<gmd:description>
											<gco:CharacterString>
												<xsl:value-of select="$var_OnlineName"/>
											</gco:CharacterString>
										</gmd:description>
									</gmd:CI_OnlineResource>
								</gmd:onLine>
							</xsl:for-each>
						</gmd:MD_DigitalTransferOptions>
					</gmd:transferOptions>
					<xsl:for-each select="$var_metadataRoot/distinfo/stdorder/digform/digtopt/offoptn" >
						<gmd:transferOptions>
							<gmd:MD_DigitalTransferOptions>
								<gmd:offLine>
									<gmd:MD_Medium>
										<gmd:name>
											<xsl:variable name="var1618_mediaTypes">
												<xsl:for-each select="offmedia">
													<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
												</xsl:for-each>
										</xsl:variable>
											<xsl:variable name="var1617_map_mediaTypeValues" >
												<xsl:for-each select="offmedia">
														<xsl:call-template name="vmf:mediumType">
															<xsl:with-param name="input" select="fn:upper-case(.)"/>
														</xsl:call-template>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var1581_joinedMappedMediaTypes" >
												<xsl:if test="fn:exists($var1617_map_mediaTypeValues)">
													<xsl:value-of select="fn:string-join(var1617_map_mediaTypeValues, ' ')"/>
													</xsl:if>
											</xsl:variable>
											<xsl:if test="fn:exists($var1581_joinedMappedMediaTypes)">
												<gmd:MD_MediumNameCode>
														<xsl:attribute name="codeList"><xsl:value-of select="xs:string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MediumNameCode')"/></xsl:attribute>
													<xsl:attribute name="codeListValue">
														<xsl:value-of select="xs:string($var1618_mediaTypes)"/>
													</xsl:attribute>
													
													<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string($var1581_joinedMappedMediaTypes)"/></xsl:attribute>
											<xsl:value-of select="string('$var1618_mediaTypess')"/>
												</gmd:MD_MediumNameCode>
											</xsl:if>
										</gmd:name>
										<xsl:for-each select="$var_offlineMediaOptionGroup/reccap/recden">
											<gmd:density>
												<gco:Real>
													<xsl:value-of select="xs:string(xs:double(.))"/>
												</gco:Real>
											</gmd:density>
										</xsl:for-each>
										<xsl:for-each select="$var_offlineMediaOptionGroup/reccap">
											<gmd:densityUnits>
												<gco:CharacterString>
													<xsl:value-of select="xs:string(recdenu)"/>
												</gco:CharacterString>
											</gmd:densityUnits>
										</xsl:for-each>
										<gmd:mediumFormat>
											<xsl:variable name="var1638_map_result_groupitems" >
												<xsl:for-each select="$var_offlineMediaOptionGroup/recfmt">
													<xsl:variable name="var1641_result_encodingType" >
														<xsl:call-template name="vmf:encodingType">
															<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
														</xsl:call-template>
													</xsl:variable>
													<xsl:if test="fn:exists($var1641_result_encodingType)">
														<xsl:value-of select="$var1641_result_encodingType"/>
													</xsl:if>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var1628_cond_result_exists"  select="(if (fn:exists($var1638_map_result_groupitems)) then fn:string-join($var1638_map_result_groupitems, ' ') else ())"/>
											<xsl:for-each select="$var1628_cond_result_exists">
												<gmd:MD_MediumFormatCode>
													<xsl:attribute name="codeList"><xsl:value-of select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MediumFormatCode'))"/></xsl:attribute>
													<xsl:attribute name="codeListValue"><xsl:value-of select="xs:string(xs:anyURI(.))"/></xsl:attribute>
													<xsl:variable name="var1634_map_result_groupitems" >
														<xsl:for-each select="$var_offlineMediaOptionGroup/recfmt">
															<xsl:variable name="var1637_result_encodingCode" >
																<xsl:call-template name="vmf:encodingCode">
																	<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:if test="fn:exists($var1637_result_encodingCode)">
																<xsl:value-of select="$var1637_result_encodingCode"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var1631_cond_result_exists"  select="(if (fn:exists($var1634_map_result_groupitems)) then fn:string-join($var1634_map_result_groupitems, ' ') else ())"/>
													<xsl:for-each select="$var1631_cond_result_exists">
														<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string(xs:anyURI(.))"/></xsl:attribute>
													</xsl:for-each>
													<xsl:value-of select="."/>
												</gmd:MD_MediumFormatCode>
											</xsl:for-each>
										</gmd:mediumFormat>
										<xsl:variable name="var1642_cond_result_exists"  select="(if (fn:exists($var_metadataRoot/distinfo/stdorder/digform/digtinfo/formcont)) then 'Format Information Content:  ' else ())"/>
										<xsl:if test="fn:exists($var1642_cond_result_exists)">
											<xsl:for-each select="$var_metadataRoot/distinfo/stdorder/digform/digtinfo/formcont">
												<xsl:variable name="var1643_formcont" select="."/>
												<xsl:variable name="var1645_cond_result_exists"  select="(if (fn:exists($var_offlineMediaOptionGroup/compat)) then ' Compatibility Information: ' else ())"/>
												<xsl:if test="fn:exists($var1645_cond_result_exists)">
													<xsl:for-each select="$var_offlineMediaOptionGroup/compat">
														<gmd:mediumNote>
															<gco:CharacterString>
																<xsl:value-of select="fn:concat(fn:concat(fn:concat($var1642_cond_result_exists, fn:normalize-space(xs:string($var1643_formcont))), $var1645_cond_result_exists), xs:string(.))"/>
															</gco:CharacterString>
														</gmd:mediumNote>
													</xsl:for-each>
												</xsl:if>
											</xsl:for-each>
										</xsl:if>
									</gmd:MD_Medium>
								</gmd:offLine>
							</gmd:MD_DigitalTransferOptions>
						</gmd:transferOptions>
					</xsl:for-each>
				</gmd:MD_Distribution>
			</gmd:distributionInfo>
			<!-- data quality section -->
			<xsl:for-each select="$var_metadataRoot">
				<xsl:for-each select="dataqual">
					<gmd:dataQualityInfo>
						<gmd:DQ_DataQuality>
							<gmd:scope>
								<gmd:DQ_Scope>
									<gmd:level>
										<gmd:MD_ScopeCode codeListValue="dataset" codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode">
										</gmd:MD_ScopeCode>
									</gmd:level>
								</gmd:DQ_Scope>
							</gmd:scope>
							<xsl:for-each select="posacc/horizpa">
								<xsl:if test="fn:exists(qhorizpa/horizpav)">
									<gmd:report>
										<gmd:DQ_AbsoluteExternalPositionalAccuracy>
											<gmd:nameOfMeasure>
												<gco:CharacterString>
													<xsl:value-of select="'Horizontal Positional Accuracy'"/>
												</gco:CharacterString>
											</gmd:nameOfMeasure>
											<gmd:measureDescription>
												<gco:CharacterString>
													<xsl:variable name="DQMeasureDesc" >
														<xsl:value-of select="xs:integer(fn:count(/metadata/dataqual/posacc/horizpa/qhorizpa/horizpae))"/>
													</xsl:variable>
													<xsl:for-each select="/metadata/dataqual/posacc/horizpa/qhorizpa[1]/horizpae">
														<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
														<xsl:if test="($DQMeasureDesc>1)">
															<xsl:value-of select="xs:string(' ')"/>
														</xsl:if>
													</xsl:for-each>
												</gco:CharacterString>
											</gmd:measureDescription>
											<gmd:evaluationMethodDescription>
												<gco:CharacterString>
													<xsl:value-of select="fn:normalize-space(xs:string(horizpar))"/>
												</gco:CharacterString>
											</gmd:evaluationMethodDescription>
											<gmd:result>
												<gmd:DQ_QuantitativeResult>
													<gmd:valueUnit>
														<gml:BaseUnit>
															<xsl:attribute name="gml:id"><xsl:value-of select="fn:concat('uom.',generate-id())"/></xsl:attribute>
															<gml:identifier>
																<xsl:attribute name="codeSpace"><xsl:value-of select="fn:concat('uom.',generate-id())"/></xsl:attribute>
															</gml:identifier>
															<gml:unitsSystem>
																<xsl:attribute name="xlink:href"><xsl:value-of select="xs:string(xs:anyURI('http://www.bipm.org/en/si/'))"/></xsl:attribute>
															</gml:unitsSystem>
														</gml:BaseUnit>
													</gmd:valueUnit>
													<gmd:value>
														<gco:Record>
															<xsl:value-of select="xs:string(xs:double(/metadata/dataqual/posacc/horizpa/qhorizpa[1]/horizpav[1]))"/>
														</gco:Record>
													</gmd:value>
												</gmd:DQ_QuantitativeResult>
											</gmd:result>
										</gmd:DQ_AbsoluteExternalPositionalAccuracy>
									</gmd:report>
								</xsl:if>
							</xsl:for-each>
							<xsl:for-each select="posacc/vertacc">
								<xsl:if test="fn:exists(qvertpa/vertaccv)">
									<gmd:report>
										<gmd:DQ_AbsoluteExternalPositionalAccuracy>
											<gmd:nameOfMeasure>
												<gco:CharacterString>
													<xsl:value-of select="'Vertical Positional Accuracy'"/>
												</gco:CharacterString>
											</gmd:nameOfMeasure>
											<gmd:measureDescription>
												<gco:CharacterString>
													<xsl:variable name="DQMeasureDesc" >
														<xsl:value-of select="xs:integer(fn:count(/metadata/dataqual/posacc/vertacc/qvertpa/vertacce[1]))"/>
													</xsl:variable>
													<xsl:for-each select="/metadata/dataqual/posacc/vertacc/qvertpa/vertacce[1]">
														<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
														<xsl:if test="($DQMeasureDesc>1)">
															<xsl:value-of select="xs:string(' ')"/>
														</xsl:if>
													</xsl:for-each>
												</gco:CharacterString>
											</gmd:measureDescription>
											<gmd:evaluationMethodDescription>
												<gco:CharacterString>
													<xsl:value-of select="fn:normalize-space(xs:string(vertaccr))"/>
												</gco:CharacterString>
											</gmd:evaluationMethodDescription>
											<gmd:result>
												<gmd:DQ_QuantitativeResult>
													<gmd:valueUnit>
														<gml:BaseUnit>
															<xsl:attribute name="gml:id"><xsl:value-of select="fn:concat('uom.',generate-id())"/></xsl:attribute>
															<gml:identifier>
																<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string(xs:anyURI('meters'))"/></xsl:attribute>
															</gml:identifier>
															<gml:unitsSystem>
																<xsl:attribute name="xlink:href"><xsl:value-of select="xs:string(xs:anyURI('http://www.bipm.org/en/si/'))"/></xsl:attribute>
															</gml:unitsSystem>
														</gml:BaseUnit>
													</gmd:valueUnit>
													<gmd:value>
														<gco:Record>
															<xsl:value-of select="xs:string(/metadata/dataqual/posacc/vertacc/qvertpa[1]/vertaccv[2])"/>
														</gco:Record>
													</gmd:value>
												</gmd:DQ_QuantitativeResult>
											</gmd:result>
										</gmd:DQ_AbsoluteExternalPositionalAccuracy>
									</gmd:report>
								</xsl:if>
							</xsl:for-each>
							<xsl:if test="fn:exists($var_metadataRoot/eainfo/detailed) or fn:exists(complete)">
								<gmd:report>
									<gmd:DQ_CompletenessOmission>
										<gmd:evaluationMethodDescription>
											<gco:CharacterString>
												<xsl:choose>
													<xsl:when test="fn:exists(complete)">
														<xsl:value-of select="fn:normalize-space(xs:string(complete))"/>
													</xsl:when>
													<xsl:otherwise>
														<xsl:value-of select="xs:string('missing')"/>
													</xsl:otherwise>
												</xsl:choose>
											</gco:CharacterString>
										</gmd:evaluationMethodDescription>
										<gmd:result>
											<xsl:variable name="var1664_cond_result_exists" as="xs:decimal" select="(if (fn:exists($var_metadataRoot/eainfo/detailed)) then xs:decimal(1) else xs:decimal(0))"/>
											<xsl:if test="fn:exists((if ((xs:string($var1664_cond_result_exists) = 'false')) then () else 'unknown'))">
												<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string(xs:string((if ((xs:string($var1664_cond_result_exists) = 'false')) then () else 'unknown')))"/></xsl:attribute>
											</xsl:if>
										</gmd:result>
									</gmd:DQ_CompletenessOmission>
								</gmd:report>
							</xsl:if>
							<!-- conceptual consistency report -->
							<xsl:if test="fn:exists(logic)">
								<gmd:report>
									<gmd:DQ_ConceptualConsistency>
										<gmd:measureDescription>
											<gco:CharacterString>
												<xsl:value-of select="fn:normalize-space(xs:string(logic))"/>
											</gco:CharacterString>
										</gmd:measureDescription>
										<gmd:result>
											<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string(xs:string('unknown'))"/></xsl:attribute>
										</gmd:result>
									</gmd:DQ_ConceptualConsistency>
								</gmd:report>
							</xsl:if>
							<!-- attribute accuracy information -->
							<xsl:for-each select="attracc">
								<xsl:variable name="var_attributeAccuracyNode" select="."/>
								<xsl:for-each select="qattracc">
									<xsl:if test="fn:exists(attraccv)">
										<gmd:report>
											<gmd:DQ_QuantitativeAttributeAccuracy>
												<gmd:nameOfMeasure>
													<gco:CharacterString>
														<xsl:value-of select="'Quantitative Attribute Accuracy Assessment'"/>
													</gco:CharacterString>
												</gmd:nameOfMeasure>
												<gmd:measureDescription>
													<gco:CharacterString>
														<xsl:value-of select="xs:string(attracce)"/>
													</gco:CharacterString>
												</gmd:measureDescription>
												<gmd:evaluationMethodDescription>
													<xsl:for-each select="$var_attributeAccuracyNode/attraccr">
														<gco:CharacterString>
															<xsl:value-of select="xs:string(.)"/>
														</gco:CharacterString>
													</xsl:for-each>
												</gmd:evaluationMethodDescription>
												<gmd:result>
													<gmd:DQ_QuantitativeResult>
														<gmd:valueUnit gco:nilReason="inapplicable"/>
														<gmd:value>
															<!--<xsl:for-each select="attraccv"> -->
															<gco:Record>
																<xsl:variable name="DataQualResult" >
																	<xsl:value-of select="xs:integer(fn:count(/metadata/dataqual/attracc/qattracc/attraccv))"/>
																</xsl:variable>
																<xsl:for-each select="/metadata/dataqual/attracc/qattracc/attraccv">
																	<xsl:value-of select="fn:normalize-space(xs:string(.))"/>
																	<xsl:if test="($DataQualResult>1)">
																		<xsl:value-of select="xs:string(' ')"/>
																	</xsl:if>
																</xsl:for-each>
															</gco:Record>
															<!--</xsl:for-each> -->
														</gmd:value>
													</gmd:DQ_QuantitativeResult>
												</gmd:result>
											</gmd:DQ_QuantitativeAttributeAccuracy>
										</gmd:report>
									</xsl:if>
								</xsl:for-each>
							</xsl:for-each>
							<!-- now handle the lineage/provenance information -->
							<xsl:if test="fn:exists(lineage/procstep) or fn:exists(lineage/srcinfo)">
								<gmd:lineage>
									<gmd:LI_Lineage>
										<gmd:statement>
											<gco:CharacterString>missing</gco:CharacterString>
										</gmd:statement>
										<xsl:for-each select="lineage/procstep">
											<xsl:variable name="var_lineageProcessingStepNode" select="."/>
											<gmd:processStep>
												<gmd:LI_ProcessStep>
													<gmd:description>
														<gco:CharacterString>
															<xsl:value-of select="xs:string(procdesc)"/>
														</gco:CharacterString>
													</gmd:description>
													<gmd:dateTime>
														<xsl:call-template name="usgin:dateFormat">
															<xsl:with-param name="inputDate" select="procdate"/>
															<xsl:with-param name="inputTime" select="proctime"/>
														</xsl:call-template>
													</gmd:dateTime>
													<xsl:for-each select="proccont">
														<gmd:processor>
															<gmd:CI_ResponsibleParty>
																<xsl:variable name="var_contactIndividual_exists" >
																	<xsl:choose>
																		<xsl:when test="fn:exists(cntinfo/cntperp/cntper)">
																			<xsl:for-each select="cntinfo/cntperp/cntper">
																				<xsl:value-of select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:for-each select="cntinfo/cntorgp/cntper">
																				<xsl:value-of select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:variable name="var_contactOrganisation_exists" >
																	<xsl:choose>
																		<xsl:when test="fn:exists(cntinfo/cntperp/cntorg)">
																			<xsl:for-each select="cntinfo/cntperp/cntorg">
																				<xsl:value-of select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:for-each select="cntinfo/cntorgp/cntorg">
																				<xsl:value-of select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<!-- done scraping content for contact name -->
																<!-- now populate the elements count(individualName + OrganisationName + positionName) must be >0 -->
																<xsl:call-template name="usgin:contactName">
																	<xsl:with-param name="inputPersonNode" select="$var_contactIndividual_exists"/>
																	<xsl:with-param name="inputOrganizationNode" select="($var_contactOrganisation_exists)"/>
																	<xsl:with-param name="inputPositionNode" select="(cntinfo/cntpos)"/>
																</xsl:call-template>
																<gmd:contactInfo>
																	<gmd:CI_Contact>
																		<!-- do the phone number(s) -->
																		<xsl:call-template name="usgin:telephoneFormat">
																			<xsl:with-param name="telNode" select="(cntinfo)"/>
																		</xsl:call-template>
																		<!-- xsl:for-each select="cntinfo/cntaddr"  -->
																		<gmd:address>
																			<gmd:CI_Address>
																				<xsl:call-template name="usgin:addressFormat">
																					<xsl:with-param name="inputAddr" select="cntinfo/cntaddr[1]"/>
																				</xsl:call-template>
																				<!-- done with postal address elements, now the e-mail. Set this up so that some value gets inserted -->
																				<xsl:call-template name="usgin:emailFormat">
																					<xsl:with-param name="emailNode" select="cntinfo"/>
																				</xsl:call-template>
																			</gmd:CI_Address>
																		</gmd:address>
																		<gmd:hoursOfService>
																			<xsl:for-each select="cntinfo/hours">
																				<gco:CharacterString>
																					<xsl:value-of select="xs:string(.)"/>
																				</gco:CharacterString>
																			</xsl:for-each>
																		</gmd:hoursOfService>
																		<gmd:contactInstructions>
																			<xsl:for-each select="cntinfo/cntinst">
																				<gco:CharacterString>
																					<xsl:value-of select="xs:string(.)"/>
																				</gco:CharacterString>
																			</xsl:for-each>
																		</gmd:contactInstructions>
																	</gmd:CI_Contact>
																</gmd:contactInfo>
																<gmd:role>
																	<gmd:CI_RoleCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode" codeListValue="processor" codeSpace="009">
																		<xsl:value-of select="xs:string('processor')"/>
																	</gmd:CI_RoleCode>
																	<!-- /xsl:if -->
																</gmd:role>
															</gmd:CI_ResponsibleParty>
														</gmd:processor>
													</xsl:for-each>
													<xsl:for-each-group select="." group-by="grp:sourcesUsed(.)">
														<xsl:variable name="var1800_cur_result_groupby" as="item()+" select="current-group()"/>
														<xsl:variable name="var1801_cur_result_groupby"  select="current-grouping-key()"/>
														<gmd:source>
															<gmd:LI_Source>
																<gmd:sourceCitation>
																	<gmd:CI_Citation>
																		<gmd:title>
																			<gco:CharacterString>
																				<xsl:value-of select="$var1801_cur_result_groupby"/>
																			</gco:CharacterString>
																		</gmd:title>
																		<xsl:for-each select="$var1800_cur_result_groupby/srcprod">
																			<gmd:alternateTitle>
																				<gco:CharacterString>
																					<xsl:value-of select="xs:string(.)"/>
																				</gco:CharacterString>
																			</gmd:alternateTitle>
																		</xsl:for-each>
																		<gmd:date>
																			<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string(xs:string('unknown'))"/></xsl:attribute>
																		</gmd:date>
																	</gmd:CI_Citation>
																</gmd:sourceCitation>
															</gmd:LI_Source>
														</gmd:source>
													</xsl:for-each-group>
												</gmd:LI_ProcessStep>
											</gmd:processStep>
										</xsl:for-each>
										<xsl:for-each select="lineage/srcinfo">
											<xsl:variable name="var_lineageSourceInfoNode" select="."/>
											<gmd:source>
												<gmd:LI_Source>
													<xsl:if test="fn:exists(strcontr) or fn:exists(typesrc)">
														<gmd:description>
															<gco:CharacterString>
																<xsl:value-of select="fn:concat('Source Contribution: ', xs:string(srccontr), ' ', xs:string(typesrc))"/>
															</gco:CharacterString>
														</gmd:description>
													</xsl:if>
													<xsl:if test="fn:exists(srcscale) and ((fn:lower-case(fn:string(srcscale)) = 'unknown') or (number(srcscale)=number(srcscale)))">
														<gmd:scaleDenominator>
															<gmd:MD_RepresentativeFraction>
																<gmd:denominator>
																	<xsl:choose>
																		<xsl:when test="(fn:lower-case(fn:string(srcscale)) = 'unknown')">
																			<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
																		</xsl:when>
																		<xsl:when test="number(srcscale)=number(srcscale)">
																			<gco:Integer>
																				<xsl:value-of select="xs:string(xs:integer(srcscale))"/>
																			</gco:Integer>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string('missing')"/></xsl:attribute>
																		</xsl:otherwise>
																	</xsl:choose>
																</gmd:denominator>
															</gmd:MD_RepresentativeFraction>
														</gmd:scaleDenominator>
													</xsl:if>
													<gmd:sourceCitation>
														<gmd:CI_Citation>
															<gmd:title>
																<gco:CharacterString>
																	<xsl:value-of select="xs:string(srccite/citeinfo/title)"/>
																</gco:CharacterString>
															</gmd:title>
															<xsl:if test="fn:exists(srccitea)">
																<gmd:alternateTitle>
																	<gco:CharacterString>
																		<xsl:value-of select="xs:string(srccitea)"/>
																	</gco:CharacterString>
																</gmd:alternateTitle>
															</xsl:if>
															<gmd:date>
																<gmd:CI_Date>
																	<gmd:date>
																		<xsl:call-template name="usgin:dateFormat">
																			<xsl:with-param name="inputDate" select="srccite/citeinfo/pubdate"/>
																			<xsl:with-param name="inputTime" select="srccite/citeinfo/pubtime"/>
																		</xsl:call-template>
																	</gmd:date>
																	<gmd:dateType>
																		<gmd:CI_DateTypeCode>
																			<xsl:attribute name="codeList"><xsl:value-of select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode'))"/></xsl:attribute>
																			<xsl:attribute name="codeListValue"><xsl:value-of select="xs:string(xs:anyURI('publication'))"/></xsl:attribute>
																			<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string(xs:anyURI('002'))"/></xsl:attribute>
																			<xsl:value-of select="'publication'"/>
																		</gmd:CI_DateTypeCode>
																	</gmd:dateType>
																</gmd:CI_Date>
															</gmd:date>
															<xsl:if test="fn:exists(srccite/citeinfo/edition)">
																<gmd:edition>
																	<gco:CharacterString>
																		<xsl:value-of select="xs:string(srccite/citeinfo/edition)"/>
																	</gco:CharacterString>
																</gmd:edition>
															</xsl:if>
															<xsl:for-each-group select="srccite/citeinfo" group-by="grp:origins(.)">
																<xsl:variable name="var1881_cur_result_groupby"  select="current-grouping-key()"/>
																<gmd:citedResponsibleParty>
																	<gmd:CI_ResponsibleParty>
																		<gmd:organisationName>
																			<gco:CharacterString>
																				<xsl:value-of select="$var1881_cur_result_groupby"/>
																			</gco:CharacterString>
																		</gmd:organisationName>
																		<gmd:role>
																			<gmd:CI_RoleCode>
																				<xsl:attribute name="codeList"><xsl:value-of select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/></xsl:attribute>
																				<xsl:attribute name="codeListValue"><xsl:value-of select="xs:string(xs:anyURI('resourceProvider'))"/></xsl:attribute>
																				<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string(xs:anyURI('001'))"/></xsl:attribute>
																				<xsl:value-of select="'resourceProvider'"/>
																			</gmd:CI_RoleCode>
																		</gmd:role>
																	</gmd:CI_ResponsibleParty>
																</gmd:citedResponsibleParty>
															</xsl:for-each-group>
															<xsl:if test="fn:exists(srccite/citeinfo/geoform) ">
																<gmd:presentationForm>
																	<xsl:variable name="var1883_cond_result_exists" >
																		<xsl:choose>
																			<xsl:when test="$var_lineageSourceInfoNode/srccite/citeinfo/geoform">
																				<!--xsl:for-each select="srccite/citeinfo/geoform" -->
																				<xsl:variable name="var_sourceDocTypeLookup" >
																					<xsl:call-template name="vmf:docType">
																						<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(srccite/citeinfo/geoform)))"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var_sourceDocTypeLookup)">
																					<xsl:value-of select="$var_sourceDocTypeLookup"/>
																				</xsl:if>
																				<!-- /xsl:for-each -->
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:for-each select="srccite/citeinfo/geoform">
																					<xsl:value-of select="fn:normalize-space(xs:string(xs:string(.)))"/>
																				</xsl:for-each>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<gmd:CI_PresentationFormCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode">
																		<xsl:attribute name="codeListValue"><xsl:value-of select="xs:string($var1883_cond_result_exists)"/></xsl:attribute>
																		<xsl:variable name="var_presentationFormCodespaceLookup" >
																			<xsl:call-template name="vmf:docCode">
																				<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(srccite/citeinfo/geoform)))"/>
																			</xsl:call-template>
																		</xsl:variable>
																		<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string($var_presentationFormCodespaceLookup)"/></xsl:attribute>
																		<xsl:value-of select="$var1883_cond_result_exists"/>
																	</gmd:CI_PresentationFormCode>
																</gmd:presentationForm>
															</xsl:if>
															<xsl:if test="fn:exists(srccite/citeinfo/serinfo)">
																<gmd:series>
																	<gmd:CI_Series>
																		<gmd:name>
																			<xsl:for-each select="srccite/citeinfo/serinfo">
																				<gco:CharacterString>
																					<xsl:value-of select="xs:string(sername)"/>
																				</gco:CharacterString>
																			</xsl:for-each>
																		</gmd:name>
																		<gmd:issueIdentification>
																			<xsl:for-each select="srccite/citeinfo/serinfo">
																				<gco:CharacterString>
																					<xsl:value-of select="xs:string(issue)"/>
																				</gco:CharacterString>
																			</xsl:for-each>
																		</gmd:issueIdentification>
																	</gmd:CI_Series>
																</gmd:series>
															</xsl:if>
															<xsl:if test="fn:exists(srccite/citeinfo/othercit)">
																<gmd:otherCitationDetails>
																	<!--xsl:for-each select="srccite/citeinfo/othercit" -->
																	<gco:CharacterString>
																		<xsl:value-of select="xs:string(srccite/citeinfo/othercit)"/>
																	</gco:CharacterString>
																	<!-- /xsl:for-each -->
																</gmd:otherCitationDetails>
															</xsl:if>
														</gmd:CI_Citation>
													</gmd:sourceCitation>
													<xsl:if test="fn:exists(srctime/timeinfo)">
														<gmd:sourceExtent>
															<gmd:EX_Extent>
																<xsl:for-each select="srctime/timeinfo/sngdate">
																	<gmd:temporalElement>
																		<gmd:EX_TemporalExtent>
																			<gmd:extent>
																				<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished'))">
																					<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(caldate)))))"/></xsl:attribute>
																				</xsl:if>
																				<gml:TimeInstant>
																					<xsl:attribute name="gml:id"><xsl:value-of select="fn:concat('TempEx.',generate-id())"/></xsl:attribute>
																					<gml:description>
																						<xsl:value-of select="xs:string(xs:string($var_lineageSourceInfoNode/srctime/srccurr))"/>
																					</gml:description>
																					<xsl:variable name="var_DateTemp">
																						<xsl:call-template name="usgin:dateFormat">
																							<xsl:with-param name="inputDate" select="(caldate)"/>
																							<xsl:with-param name="inputTime" select="(time)"/>
																						</xsl:call-template>
																					</xsl:variable>
																					<gml:timePosition>
																						<xsl:for-each select="var_DateTemp">
																							<xsl:choose>
																								<xsl:when test="fn:exists(gco:DateTime)">
																									<xsl:value-of select="fn:string(gco:DateTime)"/>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:attribute name="indeterminatePosition"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</gml:timePosition>
																				</gml:TimeInstant>
																			</gmd:extent>
																		</gmd:EX_TemporalExtent>
																	</gmd:temporalElement>
																</xsl:for-each>
																<xsl:for-each select="srctime/timeinfo/mdattim/sngdate">
																	<gmd:temporalElement>
																		<gmd:EX_TemporalExtent>
																			<gmd:extent>
																				<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished'))">
																					<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(caldate)))))"/></xsl:attribute>
																				</xsl:if>
																				<gml:TimeInstant>
																					<xsl:attribute name="gml:id"><xsl:value-of select="fn:concat('sourceTimeInst.',generate-id())"/></xsl:attribute>
																					<gml:description>
																						<xsl:value-of select="xs:string(xs:string($var_lineageSourceInfoNode/srctime/srccurr))"/>
																					</gml:description>
																					<xsl:variable name="var_DateTemp">
																						<xsl:call-template name="usgin:dateFormat">
																							<xsl:with-param name="inputDate" select="(caldate)"/>
																							<xsl:with-param name="inputTime" select="(time)"/>
																						</xsl:call-template>
																					</xsl:variable>
																					<gml:timePosition>
																						<xsl:for-each select="var_DateTemp">
																							<xsl:choose>
																								<xsl:when test="fn:exists(gco:DateTime)">
																									<xsl:value-of select="fn:string(gco:DateTime)"/>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:attribute name="indeterminatePosition"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</gml:timePosition>
																				</gml:TimeInstant>
																			</gmd:extent>
																		</gmd:EX_TemporalExtent>
																	</gmd:temporalElement>
																</xsl:for-each>
																<xsl:for-each select="srctime/timeinfo/rngdates">
																	<xsl:variable name="var_rngdatesNode" select="."/>
																	<gmd:temporalElement>
																		<gmd:EX_TemporalExtent>
																			<gmd:extent>
																				<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished'))">
																					<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(begdate)))))"/></xsl:attribute>
																				</xsl:if>
																				<gml:TimePeriod>
																					<xsl:attribute name="gml:id"><xsl:value-of select="fn:concat('srcTempEx.',generate-id())"/></xsl:attribute>
																					<gml:description>
																						<xsl:value-of select="xs:string(xs:string($var_lineageSourceInfoNode/srctime/srccurr))"/>
																					</gml:description>
																					<gml:beginPosition>
																						<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var_rngdatesNode/begdate))), 'present')) then 'now' else ()))">
																							<xsl:attribute name="indeterminatePosition"><xsl:value-of select="(if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var_rngdatesNode/begdate))), 'present')) then 'now' else ())"/></xsl:attribute>
																						</xsl:if>
																						<!-- can't use tempalate because that puts date in a gco:DateTime elelent, but needs to be gml:TimePosition here -->
																						<xsl:variable name="var_DateTemp">
																							<xsl:call-template name="usgin:dateFormat">
																								<xsl:with-param name="inputDate" select="(begdate)"/>
																								<xsl:with-param name="inputTime" select="(begtime)"/>
																							</xsl:call-template>
																						</xsl:variable>
																						<xsl:for-each select="var_DateTemp">
																							<xsl:choose>
																								<xsl:when test="fn:exists(gco:DateTime)">
																									<xsl:value-of select="fn:string(gco:DateTime)"/>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:attribute name="indeterminatePosition"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</gml:beginPosition>
																					<gml:endPosition>
																						<xsl:if test="fn:contains(fn:string($var_rngdatesNode/enddate), 'present')">
																							<xsl:attribute name="indeterminatePosition">
																								<xsl:value-of select="string('now')"/>
																							</xsl:attribute>
																						</xsl:if>
																						<xsl:variable name="var_DateTemp">
																							<xsl:call-template name="usgin:dateFormat">
																								<xsl:with-param name="inputDate" select="(enddate)"/>
																								<xsl:with-param name="inputTime" select="(endtime)"/>
																							</xsl:call-template>
																						</xsl:variable>
																						<xsl:for-each select="var_DateTemp">
																							<xsl:choose>
																								<xsl:when test="fn:exists(gco:DateTime)">
																									<xsl:value-of select="fn:string(gco:DateTime)"/>
																								</xsl:when>
																								<xsl:otherwise>
	lineab																							<xsl:attribute name="indeterminatePosition"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</gml:endPosition>
																				</gml:TimePeriod>
																			</gmd:extent>
																		</gmd:EX_TemporalExtent>
																	</gmd:temporalElement>
																</xsl:for-each>
															</gmd:EX_Extent>
														</gmd:sourceExtent>
													</xsl:if>
												</gmd:LI_Source>
											</gmd:source>
										</xsl:for-each>
									</gmd:LI_Lineage>
								</gmd:lineage>
							</xsl:if>
						</gmd:DQ_DataQuality>
					</gmd:dataQualityInfo>
				</xsl:for-each>
			</xsl:for-each>
			<!-- metadata constraints -->
			<xsl:for-each select="$var_metadataRoot">
				<xsl:variable name="var2374_metadata" select="."/>
				<xsl:for-each select="metainfo/metac">
					<gmd:metadataConstraints>
						<gmd:MD_LegalConstraints>
							<gmd:accessConstraints>
								<gmd:MD_RestrictionCode>
									<xsl:attribute name="codeList"><xsl:value-of select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode'))"/></xsl:attribute>
									<xsl:attribute name="codeListValue"><xsl:value-of select="xs:string(xs:anyURI('otherRestrictions'))"/></xsl:attribute>
									<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string(xs:anyURI('008'))"/></xsl:attribute>
								</gmd:MD_RestrictionCode>
							</gmd:accessConstraints>
							<gmd:useConstraints>
								<gmd:MD_RestrictionCode>
									<xsl:if test="$var2374_metadata/metainfo/metuc">
										<xsl:attribute name="codeList"><xsl:value-of select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode'))"/></xsl:attribute>
									</xsl:if>
									<xsl:if test="$var2374_metadata/metainfo/metuc">
										<xsl:attribute name="codeListValue"><xsl:value-of select="xs:string(xs:anyURI('otherRestrictions'))"/></xsl:attribute>
									</xsl:if>
									<xsl:if test="$var2374_metadata/metainfo/metuc">
										<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string(xs:anyURI('008'))"/></xsl:attribute>
									</xsl:if>
								</gmd:MD_RestrictionCode>
							</gmd:useConstraints>
							<gmd:otherConstraints>
								<xsl:variable name="var2378_cond_result_exists" >
									<xsl:choose>
										<xsl:when test="$var2374_metadata/metainfo/metuc">
											<xsl:for-each select="$var2374_metadata/metainfo/metuc">
												<xsl:value-of select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="' '"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:if test="fn:exists($var2378_cond_result_exists)">
									<gco:CharacterString>
										<xsl:variable name="var2379_cond_result_exists"  select="(if (fn:exists($var2374_metadata/metainfo/metuc)) then ' Metadata Use Constraints: ' else ' ')"/>
										<xsl:value-of select="fn:normalize-space(fn:concat(fn:concat(fn:concat('Metadata Access Constraints: ', xs:string(.)), $var2379_cond_result_exists), $var2378_cond_result_exists))"/>
									</gco:CharacterString>
								</xsl:if>
							</gmd:otherConstraints>
						</gmd:MD_LegalConstraints>
					</gmd:metadataConstraints>
				</xsl:for-each>
			</xsl:for-each>
			<!-- security constraints -->
			<xsl:for-each select="$var_metadataRoot/metainfo/metsi">
				<xsl:variable name="var_lookupSecurityClassType" >
					<xsl:call-template name="vmf:securityClassType">
						<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(metsc)))"/>
					</xsl:call-template>
				</xsl:variable>
				<gmd:metadataConstraints>
					<gmd:MD_SecurityConstraints>
						<xsl:choose>
							<xsl:when test="fn:exists($var_lookupSecurityClassType) and string-length(xs:string($var_lookupSecurityClassType))>0">
								<gmd:classification>
									<gmd:MD_ClassificationCode>
										<xsl:attribute name="codeListValue"><xsl:value-of select="xs:string($var_lookupSecurityClassType)"/></xsl:attribute>
										<xsl:attribute name="codeList"><xsl:value-of select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ClassificationCode'))"/></xsl:attribute>
										<xsl:variable name="var2388_result_securityClassCode" >
											<xsl:call-template name="vmf:securityClassCode">
												<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(metsc)))"/>
											</xsl:call-template>
										</xsl:variable>
										<xsl:variable name="var2387_cond_result_exists"  select="(if (fn:exists($var2388_result_securityClassCode)) then $var2388_result_securityClassCode else ())"/>
										<xsl:if test="fn:exists($var2387_cond_result_exists)">
											<xsl:attribute name="codeSpace"><xsl:value-of select="xs:string($var2387_cond_result_exists)"/></xsl:attribute>
										</xsl:if>
									</gmd:MD_ClassificationCode>
								</gmd:classification>
							</xsl:when>
							<xsl:otherwise>
								<gmd:classification gco:nilReason="missing"/>
							</xsl:otherwise>
						</xsl:choose>
						<xsl:if test="fn:exists(metscs) and string-length(xs:string(metscs))>0">
							<gmd:classificationSystem>
								<gco:CharacterString>
									<xsl:value-of select="xs:string(metscs)"/>
								</gco:CharacterString>
							</gmd:classificationSystem>
						</xsl:if>
					</gmd:MD_SecurityConstraints>
				</gmd:metadataConstraints>
			</xsl:for-each>
			<!-- metadata maintenance -->
			<gmd:metadataMaintenance>
				<gmd:MD_MaintenanceInformation>
					<gmd:maintenanceAndUpdateFrequency>
						<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string(xs:string('unknown'))"/></xsl:attribute>
					</gmd:maintenanceAndUpdateFrequency>
					<xsl:for-each select="$var_metadataRoot/metainfo/metfrd">
						<gmd:dateOfNextUpdate>
							<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unpublished'))">
								<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(xs:string(.))))))"/></xsl:attribute>
							</xsl:if>
							<xsl:variable name="var2392_cond_result_logicalor" >
								<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'present')))">
									<xsl:variable name="var2397_map_result_distinctvalues" >
										<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
											<xsl:choose>
												<xsl:when test="fn:ends-with(., '-')">
													<xsl:if test="fn:ends-with(., '-')">
														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
															<xsl:value-of select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
														</xsl:if>
													</xsl:if>
												</xsl:when>
												<xsl:otherwise>
													<xsl:value-of select="."/>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:for-each>
									</xsl:variable>
									<xsl:variable name="var2396_map_result_distinctvalues" >
										<xsl:for-each select="fn:distinct-values($var2397_map_result_distinctvalues)">
											<xsl:variable name="var2402_cond_result_endswith" >
												<xsl:choose>
													<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
														<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
															<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																<xsl:value-of select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
															</xsl:if>
														</xsl:if>
													</xsl:when>
													<xsl:otherwise>
														<xsl:value-of select="."/>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:variable>
											<xsl:if test="fn:exists($var2402_cond_result_endswith)">
												<xsl:value-of select="$var2402_cond_result_endswith"/>
											</xsl:if>
										</xsl:for-each>
									</xsl:variable>
									<xsl:if test="fn:exists($var2396_map_result_distinctvalues)">
										<xsl:value-of select="fn:string-join($var2396_map_result_distinctvalues, ' ')"/>
									</xsl:if>
								</xsl:if>
							</xsl:variable>
							<xsl:for-each select="$var2392_cond_result_logicalor">
								<gco:Date>
									<xsl:value-of select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
								</gco:Date>
							</xsl:for-each>
						</gmd:dateOfNextUpdate>
					</xsl:for-each>
					<gmd:maintenanceNote>
						<xsl:for-each select="$var_metadataRoot">
							<!-- metadata review date; if present will be concatenated with the maintenance note -->:
							<xsl:variable name="metRevDateRept">
								<xsl:choose>
									<xsl:when test="fn:exists(metainfo/metrd)">
								<xsl:variable name="var_DateTemp" >
									<xsl:call-template name="usgin:TimePositionFormat">
										<xsl:with-param name="inputDate" select="(metainfo/metrd)"/>
										<xsl:with-param name="inputTime"/>
									</xsl:call-template>
								</xsl:variable>
										<xsl:value-of select="concat(string(' Most recent metadata content review date: '), fn:string($var_DateTemp))"/> </xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="''"/>
									</xsl:otherwise>
								</xsl:choose>
							</xsl:variable>
								<gco:CharacterString>
								<xsl:value-of select="fn:normalize-space(fn:concat('This metadata was automatically generated from the ', xs:string(metainfo/metstdn), ' standard, version ', xs:string(metainfo/metstdv), ' using the August 2011-REH version of the FGDC CSDGM to ISO 19115-2 transform modified and updatated by SMR 2012-02-02 to generate USGIN compatible ISO19139 XML, and 2014-11-23 to work with xslt 1.0 in GeoPortal. ', $metRevDateRept))"/>
								</gco:CharacterString>
						</xsl:for-each>
					</gmd:maintenanceNote>
					<gmd:contact>
						<gmd:CI_ResponsibleParty>
							<gmd:positionName>
								<gco:CharacterString>USGIN/NGDS metadata editor</gco:CharacterString>
							</gmd:positionName>
							<gmd:contactInfo>
								<gmd:CI_Contact>
									<gmd:address>
										<gmd:CI_Address>
											<gmd:electronicMailAddress>
												<gco:CharacterString>metadata@usgin.org</gco:CharacterString>
											</gmd:electronicMailAddress>
										</gmd:CI_Address>
									</gmd:address>
								</gmd:CI_Contact>
							</gmd:contactInfo>
							<gmd:role>
								<gmd:CI_RoleCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode" codeListValue="processor" codeSpace="007">processor</gmd:CI_RoleCode>
							</gmd:role>
						</gmd:CI_ResponsibleParty>
					</gmd:contact>
				</gmd:MD_MaintenanceInformation>
			</gmd:metadataMaintenance>
		</gmd:MD_Metadata>
	</xsl:template>
	<!-- Map projection display handlers, this stuff gets put in the abstract -->
	<!-- Map Projections -->
	<xsl:template match="albers | equicon | lambertc">
		<xsl:apply-templates select="stdparll"/>
		<xsl:apply-templates select="longcm"/>
		<xsl:apply-templates select="latprjo"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="gnomonic | lamberta | orthogr | stereo | gvnsp">
		<xsl:for-each select="../gvnsp">
			<xsl:apply-templates select="heightpt"/>
		</xsl:for-each>
		<xsl:apply-templates select="longpc"/>
		<xsl:apply-templates select="latprjc"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="azimequi | polycon | transmer">
		<xsl:for-each select="../transmer">
			<xsl:apply-templates select="sfctrmer"/>
		</xsl:for-each>
		<xsl:apply-templates select="longcm"/>
		<xsl:apply-templates select="latprjo"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="miller | sinusoid | vdgrin">
		<xsl:for-each select="../equirect">
			<xsl:apply-templates select="stdparll"/>
		</xsl:for-each>
		<xsl:for-each select="../mercator">
			<xsl:apply-templates select="stdparll"/>
			<xsl:apply-templates select="sfequat"/>
		</xsl:for-each>
		<xsl:apply-templates select="longcm"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="equirect">
		<xsl:apply-templates select="stdparll"/>
		<xsl:apply-templates select="longcm"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="mercator">
		<xsl:apply-templates select="stdparll"/>
		<xsl:apply-templates select="sfequat"/>
		<xsl:apply-templates select="longcm"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="polarst">
		<xsl:apply-templates select="svlong"/>
		<xsl:apply-templates select="stdparll"/>
		<xsl:apply-templates select="sfprjorg"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="obqmerc">
		<xsl:apply-templates select="sfctrlin"/>
		<xsl:apply-templates select="obqlazim"/>
		<xsl:apply-templates select="obqlpt"/>
		<xsl:apply-templates select="latprjo"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="spaceobq">
		<xsl:apply-templates select="landsat"/>
		<xsl:apply-templates select="pathnum"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="robinson">
		<xsl:apply-templates select="longpc"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="modsak">
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<!-- Map Projection Parameters -->
	<xsl:template match="stdparll">
			Standard_Parallel: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="longcm">
			Longitude_of_Central_Meridian: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="latprjo">
			Latitude_of_Projection_Origin: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="feast">
			False_Easting: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="fnorth">
			False_Northing: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="sfequat">
			Scale_Factor_at_Equator: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="heightpt">
			Height_of_Perspective_Point_Above_Surface: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="longpc">
			Longitude_of_Projection_Center: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="latprjc">
			Latitude_of_Projection_Center: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="sfctrlin">
			Scale_Factor_at_Center_Line: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="obqlazim">
			Oblique_Line_Azimuth: <xsl:value-of select="."/>
		<xsl:for-each select="azimangl">
				Azimuthal_Angle:  <xsl:value-of select="."/>
		</xsl:for-each>
		<xsl:for-each select="azimptl">
				Azimuthal_Measure_Point_Longitude:  <xsl:value-of select="."/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template match="obqlpt">
			Oblique_Line_Point: 
			<xsl:value-of select="."/>
		<xsl:for-each select="obqllat">
				Oblique_Line_Latitude:  <xsl:value-of select="."/>
		</xsl:for-each>
		<xsl:for-each select="obqllong">
				Oblique_Line_Longitude:  <xsl:value-of select="."/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template match="svlong">
			Straight_Vertical_Longitude_from_Pole: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="sfprjorg">
			Scale_Factor_at_Projection_Origin: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="landsat">
			Landsat_Number: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="pathnum">
			Path_Number: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="sfctrmer">
			Scale_Factor_at_Central_Meridian: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="otherprj">
	Other_Projection's_Definition: 
<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="attr">
		<!-- template to handle attributes of attributes, don't allow recursion -->
			Attribute Label: <xsl:value-of select="attrlabl"/>
				Definition: <xsl:value-of select="attrdef"/>
				Source: <xsl:value-of select="attrdefs"/>
				Attribute of Attribute Domain: <xsl:for-each select="attrdomv">
					Attribute_Domain_Values: <xsl:for-each select="edom">
							Enumerated_Domain: <xsl:for-each select="edomv">
									Value: <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="edomvd">
									Value_Definition:  <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="edomvds">
									Value_Definition_Source:  <xsl:value-of select="."/>
				</xsl:for-each>
			</xsl:for-each>
			<!-- end enumerated domain -->
			<xsl:for-each select="rdom">
							Range_Domain: <xsl:for-each select="rdommin">
									Range_Minimum:  <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="rdommax">
									Range_Maximum:  <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="attrunit">
										Units_of_Measure:  <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="attrmres">
										Attribute_Measurement_Resolution:  <xsl:value-of select="."/>
				</xsl:for-each>
			</xsl:for-each>
			<xsl:for-each select="codesetd">
							Codeset Domain: <xsl:for-each select="codesetn">
								Codeset Name:  <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="codesets">
								Codeset Source:  <xsl:value-of select="."/>
				</xsl:for-each>
			</xsl:for-each>
			<xsl:for-each select="udom">
							Unrepresentable Domain:  <xsl:value-of select="."/>
			</xsl:for-each>
		</xsl:for-each>
	</xsl:template>
</xsl:stylesheet>
