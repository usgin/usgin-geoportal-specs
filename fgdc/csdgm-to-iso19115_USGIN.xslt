<?xml version="1.0" encoding="UTF-8"?>
<!--
======================================================================
	 FGDC CSDGM to ISO 19115 Transform version 2014 using XPath 1.0 and XSLT v1.0
	USGIN v2.0

	 This is the XML Style sheet that transforms metadata conforming to the Content Standards for 
	 Digital Geospatial Metadata of the Federal Geographic Data Committee June 1998 FGDC-STD-001-1998
	 version to the ISO 19115:2003(E) that conforms with the USGIN metadata profile.  
	 This stylesheet can be applied to FGDC CSDGM XML to generate ISO 19115 XML.

	 Original XSLT was generated by Altova MapForce 2009sp1 by the Metadata Transform Working Group NOAA 
	 National Coastal Data Development Center (NCDDC). 	 This xslt was forked from the NOAA transform in 2009. 
	 The current NOAA version does CSDGM to ISO1911-2, 
	 at http://service.ncddc.noaa.gov/rdn/www/metadata-standards/metadata-xml/documents/csdgm2iso19115-2.xslt)
	 This autogenerated XSLT is difficult to understand and maintain, and uses xslt v2.0.  
	 Original auto-generated XSLT extensively modified by Stephen Richard and Leahanna Musil, USGIN, 
	 to adopt for USGIN ISO metadata conventions and use with ESRI Geoportal, which can only do xslt v1.0 
	 transforms. Most of the autogenerated code has been reworked and refactored using XSLT v1.0 for 
	 better maintainability, including creation of various sub-templates for various common patterns. 
	 Some logical problems in the original transformation have also been revised. Spatial reference 
	 and entity-attribute information is put into the abstract as free text.
	 
	 Contributions to the code base are welcome via pull requests at 
	 https://github.com/usgin/usgin-geoportal-specs/tree/master/fgdc

	 Distribution liability:
		Neither USGIN nor NOAA make any warranty regarding these data, expressed or implied, nor does the 
		fact of distribution constitute such a warranty. NOAA, NESDIS, NODC, NCDDC, and USGIN cannot 
		assume liability for any damages caused by any errors or omissions in these data, nor as a 
		result of the failure of these data to function on a particular system. 
		These files were developed for opensource uses.
		
	License: CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
	http://creativecommons.org/publicdomain/zero/1.0/

 Revisions:
 20091028 (JLM) Namespaces were corrected to avoid duplicates.
 20091120 (JLM) CodeLists were edited to remove extra quotes and other undesired characters. 
 	CodeLists were checked to ensure inclusion of domian codes. 
 	Edits were also made to remove un-used elements. 
 	FGDC CSDGM elements horizpa/horizpar and vertacc/vertaccr were changed from being mapped to gml:id to gml:CoventionalUnit. 
 	Single Date Time Period of contect was added to mapping. 
 	Multiple Dates will replace if single date is empty. 
 	Duplicates of axisDimensionsProperties is not allowed to repeat. To solve this, MD_GridSpatialRepresentation
							 was repeated.
	Cell Geometry Code information was also added.
SMR 2012-01-27 comment out gmd:extendedElementInformation
SMR 2012-01-28 edit XSLT to make it more intelligible and maintainable. Give variables more 
							reasonable names, remove spurious type casting, add comments	
SMR 2014-11-20  This XSLT does not transform Extensions for Remote Sensing Metadata, FGDC-STD-012-2002
							To Do- add tests to recognize and handle remote sensing extensions.
SMR 2014-11-23 Start painful conversion to work with XSLT v1.0 for geoportal. 
SMR 2014-11-30 version 2.0 for use in NGDS geoportals
SMR 2014-12-01	remove all upper-case, lower-case, replace, exists function calls, they are xslt2
-->
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:gco="http://www.isotc211.org/2005/gco" xmlns:gfc="http://www.isotc211.org/2005/gfc"
	xmlns:gmd="http://www.isotc211.org/2005/gmd" xmlns:gmx="http://www.isotc211.org/2005/gmx"
	xmlns:gsr="http://www.isotc211.org/2005/gsr" xmlns:gss="http://www.isotc211.org/2005/gss"
	xmlns:gts="http://www.isotc211.org/2005/gts" xmlns:gml="http://www.opengis.net/gml"
	xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xmlns:vmf="http://www.altova.com/MapForce/UDF/vmf"
	xmlns:grp="http://www.altova.com/Mapforce/grouping"
	xmlns:usgin="http://resources.usgin.org/xslt/FGDC2ISO"
	exclude-result-prefixes="grp vmf xs xsi xsl" >
	
<!--	xmlns:fn="http://www.w3.org/2005/xpath-functions"-->
	
	<xsl:template name="ucase">
		<xsl:param name="theString"></xsl:param>
	<xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'" />
	<xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'" />
	<xsl:value-of select="string(translate(normalize-space(string($theString)), $smallcase, $uppercase))" />
	</xsl:template>
	
	<xsl:template name="lcase">
		<xsl:param name="theString"></xsl:param>
		<xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'" />
		<xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'" />
		<xsl:value-of select="string(translate(normalize-space(string($theString)), $uppercase, $smallcase))" />
	</xsl:template>
	
	<!-- ********************** templates by SMR   **************************** -->
	<!-- ********************************************************************** -->
	<xsl:template name="usgin:TimePositionFormat">
		<!-- given two strings (inputDate, inputTime), runs through a variety of tests for different formats,
			returns dateTime 8601 string, or nilXXXXXX 
		where XXXXXX is the nil reason -->
<!--		<xsl:variable name="inputDate" select="caldate"/>
		<xsl:variable name="inputTime" select="time"/>-->
		<xsl:param name="inputDate"/>
        <xsl:param name="inputTime"/>
		
		<!-- var_DateString will contain either 'nilAAAAA' where AAAA is a nilReason, a valid xs:dateTime, 
			or it will contain a valid Date in format YYYY-MM-DD -->
		<xsl:variable name="currentDateTime">
			<!-- kludge to replace xslt 2.0 current time function -->
			<xsl:value-of select="string('2014-12-31T12:00:00Z')"/>
		</xsl:variable>
		<!-- a brute force, incomplete test for DateTime for xslt 1.0; replaces xslt 2.0 castable as xs:DateTime -->
		<xsl:variable name="castableAsDateTime">
			<xsl:value-of
				select="(substring($inputDate,5,1)='-') and (substring($inputDate,8,1)='-') and (substring($inputDate,11,1)='T') and (substring($inputDate,14,1)=':') and (substring($inputDate,17,1)=':')"
			/>
		</xsl:variable>
		<xsl:variable name="var_DateString">
			<xsl:variable name="var_lcdate">
				<xsl:call-template name="lcase">
					<xsl:with-param name="theString" select="$inputDate"/>
				</xsl:call-template>
			</xsl:variable>
			<xsl:choose>
				<xsl:when
					test="(contains(string($var_lcdate), 'unknown')) or (contains(string($var_lcdate), 'unpublished'))">
					<xsl:value-of select="concat('nil',string($inputDate))"/>
				</xsl:when>
				<xsl:when test="contains(string($var_lcdate), 'present') or contains(string($var_lcdate), 'now')">
					<!-- proxy for xslt 2.0 currentdate function -->
					<xsl:value-of select="$currentDateTime"/>
				</xsl:when>
				<xsl:when test="string($castableAsDateTime)='true'">
					<xsl:value-of select="string($inputDate)"/>
				</xsl:when>
				<!-- convert YYYYMMDD format to YYYY-MM-DD format -->
				<xsl:otherwise>
					<!--                 <xsl:variable name="var_dateWork">-->
					<xsl:choose>
						<xsl:when
							test="string-length(normalize-space(string($inputDate)))=8">
							<xsl:value-of select="concat(substring(normalize-space(string($inputDate)), 0, 5), '-', substring(normalize-space(string($inputDate)), 5, 2), '-',substring(normalize-space(string($inputDate)), 7, 2))"
							/>
						</xsl:when>
						<xsl:when
							test="string-length(normalize-space(string($inputDate)))=6">
							<xsl:value-of
								select="concat(substring(normalize-space(string($inputDate)), 0, 5), '-', substring(normalize-space(string($inputDate)), 5, 2), '-01')"
							/>
						</xsl:when>
						<xsl:when
							test="string-length(normalize-space(string($inputDate)))=4">
							<xsl:value-of
								select="concat(substring(normalize-space(string($inputDate)), 0, 5), '-01-01')"
							/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="string('nilmissing')"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<!-- update the test to see if put in current date -->
		<xsl:variable name="castableAsDateTime2">
			<xsl:value-of
				select="(substring($var_DateString,5,1)='-') and (substring($var_DateString,8,1)='-') and (substring($var_DateString,11,1)='T') and (substring($var_DateString,14,1)=':') and (substring($var_DateString,17,1)=':')"
			/>
		</xsl:variable>       
		
		<!-- done with date, either is nilAAAAA, 0000, a valid xs:dateTime, or a valid xs:date -->
		<!-- now need to process input time  -->
		<xsl:variable name="var_timeString">
			<xsl:variable name="var_ucinputtime">
				<xsl:call-template name="ucase">
					<xsl:with-param name="theString" select="$inputTime"/>
				</xsl:call-template>
			</xsl:variable>
			<xsl:choose>
				<xsl:when test="($var_ucinputtime='UNKNOWN')">
					<xsl:value-of select="string('12:00:00')"/>
				</xsl:when>
				<xsl:when test="string-length($inputTime) &gt; 6">
					<!-- has decimal seconds, put everything after the 6th digit in decimal seconds -->
					<xsl:value-of
						select="concat(substring(string($inputTime), 0, 3), ':', substring(string($inputTime),3,2), ':', substring(string($inputTime), 5, 2),'.',substring(string($inputTime), 7, (string-length($inputTime)-6)))"
					/>
				</xsl:when>
				<xsl:when test="string-length($inputTime)=6">
					<!-- HHMMSS -->
					<xsl:value-of
						select="concat(substring(string($inputTime), 0, 3), ':', substring(string($inputTime),3,2), ':', substring(string($inputTime), 5, 2))"
					/>
				</xsl:when>
				<xsl:when test="string-length($inputTime)=4">
					<xsl:value-of
						select="concat(substring(string($inputTime), 0, 3), ':', substring(string($inputTime),3,2), ':00')"
					/>
				</xsl:when>
				<xsl:when test="string-length($inputTime)=2">
					<xsl:value-of
						select="concat(substring(string($inputTime), 0, 3), ':00:00')"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="string('12:00:00')"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<!-- now merge date string with time string (if it exists) -->
		<xsl:choose>
			<xsl:when test="starts-with(string($var_DateString),'nil')">
				<xsl:value-of select="string($var_DateString)"/>
			</xsl:when>
			<xsl:when test="string($castableAsDateTime2)='true'">
				<xsl:value-of select="string($var_DateString)"/>
			</xsl:when>
			<xsl:when
				test="string-length($var_DateString)>0 and (string-length($var_DateString)=10) and (string-length($var_timeString)&gt; 0)">
				<xsl:value-of
					select="concat(string($var_DateString),'T',string($var_timeString))"
				/>
			</xsl:when>
			<xsl:when
				test="string-length($var_DateString)>0 and (string-length($var_DateString)=10)  and (string-length($var_timeString)= 0)">
				<xsl:value-of select="concat(string($var_DateString),'T12:00:00')"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="string('nilinapplicable')"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<!-- ************************************************************************************* -->
	<xsl:template name="usgin:contactName">
		<!-- processes name part of a gmd:CI_ResponsibleParty -->
		<!-- handler for individual, organization, position name -->
		<!-- now populate the elements count(individualName + OrganisationName + positionName) must be >0 -->
		<!-- check that at least one got populated -->
		<xsl:param name="the-cntinfo"/>
		<!-- input is a csdgm xml cntinfo node -->
		<xsl:for-each select="$the-cntinfo">
		<xsl:variable name="inputPersonNode">
			<xsl:choose>
				<xsl:when test="cntperp/cntper">
					<xsl:value-of select="cntperp/cntper"/>
				</xsl:when>
				<xsl:when test="cntorgp/cntper">
					<xsl:value-of select="cntorgp/cntper"/>
				</xsl:when>
			</xsl:choose>
<!--				<xsl:value-of select="concat(string(cntorgp/cntper),string(cntperp/cntper))"/>-->
		</xsl:variable>
		<xsl:variable name="inputOrganizationNode">
			<xsl:choose>
				<xsl:when test="cntperp/cntorg">
					<xsl:value-of select="cntperp/cntorg"/>
				</xsl:when>
				<xsl:when test="cntorgp/cntorg">
					<xsl:value-of select="cntorgp/cntorg"/>
				</xsl:when>
			</xsl:choose>
		</xsl:variable>

		<xsl:choose>
			<xsl:when
				test="string-length($inputPersonNode)>0 or string-length($inputOrganizationNode)>0 or string-length(cntpos)>0">
				<xsl:if test="string-length($inputPersonNode)>0">
					<gmd:individualName>
						<gco:CharacterString>
<!--							<xsl:for-each select="$inputPersonNode">-->
							<xsl:value-of select="normalize-space(string($inputPersonNode))"/>
								<!--<xsl:if test="(count($inputPersonNode)>1)">
									<xsl:value-of select="string(' ')"/>
								</xsl:if>
							</xsl:for-each>-->
						</gco:CharacterString>
					</gmd:individualName>
				</xsl:if>
				<xsl:if test="string-length($inputOrganizationNode)>0">
					<gmd:organisationName>
						<gco:CharacterString>
					<!--		<xsl:for-each select="$inputOrganizationNode">-->
							<xsl:value-of select="normalize-space(string($inputOrganizationNode))"/>

							<!--</xsl:for-each>-->
						</gco:CharacterString>
					</gmd:organisationName>
				</xsl:if>
				<xsl:if test="count(cntpos)>0">
					<!-- only one allowed by csdgm -->
					<gmd:positionName>
						<gco:CharacterString>
							<!--<xsl:for-each select="./cntpos">-->
							<xsl:value-of select="normalize-space(string(cntpos))"/>
								<!--<xsl:if test="(count(./cntpos)>1)">
									<xsl:value-of select="string(' ')"/>
								</xsl:if>
							</xsl:for-each>-->
						</gco:CharacterString>
					</gmd:positionName>
				</xsl:if>
			</xsl:when>
			<!-- if at least one is present check -->
			<!-- no contact name -->
			<xsl:otherwise>
				<gmd:organisationName>
					<gco:CharacterString>metadata contact name, organisation and position are
						missing</gco:CharacterString>
				</gmd:organisationName>
			</xsl:otherwise>
		</xsl:choose>
		</xsl:for-each>
	</xsl:template>
	<!-- contact name handler -->

	<!-- ***************************************************************************** -->
	<xsl:template name="usgin:contactHandler">
		<xsl:param name="the-cntinfo"/>
		<gmd:CI_Contact>
			<xsl:if test="count($the-cntinfo/cntvoice)>0 or count($the-cntinfo/cntfax)>0">
				<gmd:phone>
					<gmd:CI_Telephone>
						<xsl:for-each select="$the-cntinfo/cntvoice">
							<gmd:voice>
								<gco:CharacterString>
									<xsl:value-of select="concat(normalize-space(.),' ')"/>
								</gco:CharacterString>
							</gmd:voice>
						</xsl:for-each>
						<xsl:for-each select="$the-cntinfo/cntfax">
							<gmd:facsimile>
								<gco:CharacterString>
									<xsl:value-of select="concat(normalize-space(.),' ')"/>
								</gco:CharacterString>
							</gmd:facsimile>
						</xsl:for-each>
					</gmd:CI_Telephone>
				</gmd:phone>
			</xsl:if>
			<gmd:address>
				<gmd:CI_Address>
					<xsl:call-template name="usgin:addressFormat">
						<!-- take the first address if there is more than one; ISO only allows one address on a contact-->
						<xsl:with-param name="inputAddr" select="$the-cntinfo/cntaddr[1]"/>
					</xsl:call-template>
					<!-- done with postal address elements, now the e-mail. Set this up so that some value gets inserted -->
					<xsl:choose>
						<xsl:when test="count($the-cntinfo/cntemail)>0">
							<xsl:for-each select="$the-cntinfo/cntemail">
								<gmd:electronicMailAddress>
									<gco:CharacterString>
										<xsl:value-of select="normalize-space(.)"/>
									</gco:CharacterString>
								</gmd:electronicMailAddress>
							</xsl:for-each>
						</xsl:when>
						<xsl:otherwise>
							<gmd:electronicMailAddress>
								<gco:CharacterString>eMail@missing.org</gco:CharacterString>
							</gmd:electronicMailAddress>
						</xsl:otherwise>
					</xsl:choose>
				</gmd:CI_Address>
			</gmd:address>
			
			<xsl:for-each select="$the-cntinfo/hours">
				<gmd:hoursOfService>
					<gco:CharacterString>
						<xsl:value-of select="normalize-space(string(.))"/>
					</gco:CharacterString>
				</gmd:hoursOfService>
			</xsl:for-each>
			<xsl:for-each select="$the-cntinfo/cntinst">
				<gmd:contactInstructions>
					<gco:CharacterString>
						<xsl:value-of select="normalize-space(string(.))"/>
					</gco:CharacterString>
				</gmd:contactInstructions>
			</xsl:for-each>
		</gmd:CI_Contact>
	</xsl:template>
	<!-- *************************************************** -->
	<xsl:template name="usgin:addressFormat">
		<xsl:param name="inputAddr"/>
		<!-- don't put in postal address elements unless at least one has a value -->
		<xsl:if
			test="count($inputAddr/address)>0 or count($inputAddr/city)>0 or count($inputAddr/state)>0 or count($inputAddr/postal)>0 or count($inputAddr/country)>0">
			<xsl:for-each select="$inputAddr/address">
				<gmd:deliveryPoint>
					<gco:CharacterString>
						<xsl:value-of select="normalize-space(string(.))"/>
					</gco:CharacterString>
				</gmd:deliveryPoint>
			</xsl:for-each>
			<xsl:for-each select="$inputAddr/city">
				<gmd:city>
					<gco:CharacterString>
						<xsl:value-of select="normalize-space(string(.))"/>
					</gco:CharacterString>
				</gmd:city>
			</xsl:for-each>
			<xsl:for-each select="$inputAddr/state">
				<gmd:administrativeArea>
					<gco:CharacterString>
						<xsl:value-of select="normalize-space(string(.))"/>
					</gco:CharacterString>
				</gmd:administrativeArea>
			</xsl:for-each>
			<xsl:for-each select="$inputAddr/postal">
				<gmd:postalCode>
					<gco:CharacterString>
						<xsl:value-of select="normalize-space(string(.))"/>
					</gco:CharacterString>
				</gmd:postalCode>
			</xsl:for-each>
			<xsl:for-each select="$inputAddr/country">
				<gmd:country>
					<gco:CharacterString>
						<xsl:value-of select="normalize-space(string(.))"/>
					</gco:CharacterString>
				</gmd:country>
			</xsl:for-each>
		</xsl:if>
	</xsl:template>
	<!-- ********************************************************** -->
	<xsl:template name="usgin:citinfoHandler">
		<xsl:param name="theciteinfo"/>
		<xsl:variable name="var_citeinfoSourceNode" select="."/>
		<gmd:CI_Citation>
			<gmd:title>
				<xsl:for-each select="title">
					<gco:CharacterString>
						<xsl:value-of select="normalize-space(string(.))"/>
					</gco:CharacterString>
				</xsl:for-each>
			</gmd:title>
			<gmd:date>
				<xsl:choose>
					<xsl:when test="count(pubdate)>0">
						<gmd:CI_Date>
							<gmd:date>
								<!-- content for USGIN is gco:DateTime -->
									<xsl:variable name="var_formatPubdate">
										<xsl:call-template name="usgin:TimePositionFormat">
											<xsl:with-param name="inputDate" select="pubdate"/>
											<xsl:with-param name="inputTime" select="pubtime"/>
										</xsl:call-template>
									</xsl:variable>
									<xsl:choose>
										<xsl:when test="starts-with($var_formatPubdate,'nil')">
											<xsl:attribute name="gco:nilReason">
												<xsl:value-of select="'unknown'"/>
											</xsl:attribute>
										</xsl:when>
										<xsl:otherwise>
											<gco:DateTime>
												<xsl:value-of select="string($var_formatPubdate)"/>
											</gco:DateTime>
										</xsl:otherwise>
									</xsl:choose>
							</gmd:date>
							<gmd:dateType>
								<gmd:CI_DateTypeCode
									codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode"
									codeListValue="publication" codeSpace="002"
									>publication</gmd:CI_DateTypeCode>
							</gmd:dateType>
						</gmd:CI_Date>
					</xsl:when>
					<xsl:otherwise>
						<xsl:attribute name="gco:nilReason">
							<xsl:value-of select="'missing'"/>
						</xsl:attribute>
					</xsl:otherwise>
				</xsl:choose>
			</gmd:date>
			<xsl:for-each select="edition">
				<gmd:edition>
					<gco:CharacterString>
						<xsl:value-of select="string(.)"/>
					</gco:CharacterString>
				</gmd:edition>
			</xsl:for-each>
			<gmd:identifier>
				<gmd:MD_Identifier>
					<gmd:authority>
						<gmd:CI_Citation>
							<gmd:title>
								<gco:CharacterString>USGIN convention</gco:CharacterString>
							</gmd:title>
							<gmd:date gco:nilReason="inapplicable"/>
						</gmd:CI_Citation>
					</gmd:authority>
					<gmd:code>
						<gco:CharacterString>
							<xsl:for-each select="onlink">
								<xsl:value-of
									select="concat(normalize-space(string(.)),' ')"/>
							</xsl:for-each>
						</gco:CharacterString>
					</gmd:code>
				</gmd:MD_Identifier>
			</gmd:identifier>
			<gmd:citedResponsibleParty>
				<gmd:CI_ResponsibleParty>
					<xsl:if test="count(origin)>0">
						<xsl:variable name="var_countOrigin">
							<xsl:value-of select="count(origin)"/>
						</xsl:variable>
						<!-- assume that csdgm originators are all individuals -->
						<gmd:individualName>
							<gco:CharacterString>
								<xsl:for-each select="origin">
									<xsl:value-of select="normalize-space(string(.))"/>
									<xsl:if test="$var_countOrigin &gt; 1">
										<xsl:value-of select="';  '"/>
									</xsl:if>
								</xsl:for-each>
							</gco:CharacterString>
						</gmd:individualName>
					</xsl:if>
					<xsl:if test="count(origin) = 0">
						<gmd:individualName>
							<gco:CharacterString>
								<xsl:value-of select="'No originator name provided'"/>
							</gco:CharacterString>
						</gmd:individualName>
					</xsl:if>
					<gmd:role>
						<gmd:CI_RoleCode
							codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode"
							codeListValue="originator" codeSpace="006">originator</gmd:CI_RoleCode>
					</gmd:role>
				</gmd:CI_ResponsibleParty>
			</gmd:citedResponsibleParty>
			<xsl:if test="count(geoform)>0">
				<gmd:presentationForm>
					<xsl:variable name="var_geoformDocType">
						<xsl:call-template name="vmf:docType">
							<xsl:with-param name="input"
								select="geoform"/>
						</xsl:call-template>
					</xsl:variable>
					<xsl:variable name="var_geoformDocCode">
						<xsl:call-template name="vmf:docCode">
							<xsl:with-param name="input"
								select="geoform"/>
						</xsl:call-template>
					</xsl:variable>
					<gmd:CI_PresentationFormCode>
						<xsl:attribute name="codeList">
							<xsl:choose>
								<xsl:when test="$var_geoformDocType ='unknown'">
									<xsl:value-of
										select="string('http://www.opengis.net/def/nil/OGC/0/unknown/')"
									/>
								</xsl:when>
								<xsl:otherwise>
									<xsl:value-of
										select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode')"
									/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:attribute>
						<xsl:attribute name="codeListValue">
							<xsl:value-of select="string($var_geoformDocType)"/>
						</xsl:attribute>
						<xsl:attribute name="codeSpace">
							<xsl:value-of select="string($var_geoformDocCode)"/>
						</xsl:attribute>
						<xsl:value-of select="normalize-space(string(geoform))"/>
					</gmd:CI_PresentationFormCode>
				</gmd:presentationForm>
			</xsl:if>
			<xsl:for-each select="serinfo">
				<gmd:series>
					<gmd:CI_Series>
						<gmd:name>
							<gco:CharacterString>
								<xsl:value-of select="string(sername)"/>
							</gco:CharacterString>
						</gmd:name>
						<gmd:issueIdentification>
							<gco:CharacterString>
								<xsl:value-of select="string(issue)"/>
							</gco:CharacterString>
						</gmd:issueIdentification>
					</gmd:CI_Series>
				</gmd:series>
			</xsl:for-each>
			<xsl:for-each select="othercit">
				<gmd:otherCitationDetails>
					<gco:CharacterString>
						<xsl:value-of select="string(.)"/>
					</gco:CharacterString>
				</gmd:otherCitationDetails>
			</xsl:for-each>
		</gmd:CI_Citation>
	</xsl:template>
	<!-- citeinfo handler -->

	<!-- ************************************************** -->
	<!-- MD_Format handler -->
	<xsl:template name="usgin:format">
		<xsl:param name="thedigform"/>
		<xsl:param name="theFmtID"/>
		<!-- each digform has one digtinfo, which includes one format 
		each of which has formname, one of version number or date, specification, informationContent
		decompressionTechnique and transferSize.-->
		<gmd:MD_Format>
			<xsl:if test="string-length(string($theFmtID)) &gt; 0">
				<xsl:attribute name="id">
					<xsl:value-of select="$theFmtID"/>
				</xsl:attribute>
			</xsl:if>
			<gmd:name>
				<!-- name is mandatory -->
				<gco:CharacterString>
					<xsl:value-of select="normalize-space(string($thedigform/digtinfo/formname))"/>
				</gco:CharacterString>
			</gmd:name>
			<gmd:version>
				<!-- version is mandatory; in source will be either version number or version date; 
				if neither present, make nil:unknown-->
				<xsl:choose>
					<xsl:when test="count($thedigform/digtinfo/formvern)>0">
						<gco:CharacterString>
							<xsl:value-of select="string($thedigform/digtinfo/formvern)"/>
						</gco:CharacterString>
					</xsl:when>
					<xsl:when test="count($thedigform/digtinfo/formverd)>0">
						<gco:CharacterString>
							<xsl:value-of select="string($thedigform/digtinfo/formverd)"/>
						</gco:CharacterString>
					</xsl:when>
					<xsl:otherwise>
						<xsl:attribute name="gco:nilReason">
							<xsl:value-of select="string('unknown')"/>
						</xsl:attribute>
					</xsl:otherwise>
				</xsl:choose>
			</gmd:version>
			<xsl:if
				test="count($thedigform/digtinfo/formspec)>0 or count($thedigform/digtinfo/formcont)>0 or count($thedigform/digtinfo/transize)>0">
				<gmd:specification>
					<gco:CharacterString>
						<xsl:for-each select="$thedigform/digtinfo">
							<xsl:if test="count(formspec)>0">
							<xsl:value-of
								select="concat('Format specification:',normalize-space(string(formspec)),'. ')"
							/>
						</xsl:if>
							<xsl:if test="count(formcont)>0">
							<xsl:value-of
								select="concat('Format Information Content:',normalize-space(string(formcont)),'. ')"
							/>
						</xsl:if>
							<xsl:if test="count(transize)>0">
							<xsl:value-of
								select="concat('File transfer size:',normalize-space(string(transize)),'. ')"
							/>
						</xsl:if>
						</xsl:for-each>
					</gco:CharacterString>
				</gmd:specification>
			</xsl:if>
			<xsl:for-each select="$thedigform/digtinfo/filedec">
				<gmd:fileDecompressionTechnique>
					<gco:CharacterString>
						<xsl:value-of select="normalize-space(string(.))"/>
					</gco:CharacterString>
				</gmd:fileDecompressionTechnique>
			</xsl:for-each>
		</gmd:MD_Format>
	</xsl:template>

	<xsl:template name="usgin:digTransferOption">
		<xsl:param name="thedigform"/>
		<xsl:param name="theOptionID"/>
		<!-- input is a single $var_metadataRoot/distinfo/stdorder/digform node  -->
		<!-- handler for digital transfer options -->
		<gmd:MD_DigitalTransferOptions>
			<xsl:if test="count(theOptionID)>0">
				<xsl:attribute name="id">
					<xsl:value-of select="string($theOptionID)"/>
				</xsl:attribute>
			</xsl:if>
			<xsl:if test="count(digtinfo/transize)>0">
				<gmd:transferSize>
					<xsl:choose>
						<!-- trick to check if its a number -->
						<xsl:when test="number(digtinfo/transize)=number(digtinfo/transize)">
							<gco:Real>
								<xsl:value-of select="string(number(digtinfo/transize))"/>
							</gco:Real>
						</xsl:when>
						<xsl:otherwise>
							<xsl:attribute name="gco:nilReason">
								<xsl:value-of select="'inapplicable'"/>
							</xsl:attribute>
						</xsl:otherwise>
					</xsl:choose>
				</gmd:transferSize>
			</xsl:if>
			<!-- find text to put in online linkage description and name -->
			<!-- csdgm allows multipl onlinopt for each collection of formats 
				each of these becomes a gmd:CI_OnlineResource-->
			<xsl:for-each select="digtopt">
				<xsl:variable name="var_oncomp">
					<xsl:value-of select="onlinopt/oncomp"/>
				</xsl:variable>
				<xsl:variable name="var_accinstr">
					<xsl:value-of select="onlinopt/accinstr"/>
				</xsl:variable>
				<xsl:for-each select="computer">
					<xsl:variable name="var-count-networkr">
						<xsl:value-of select="count(networkr)"/>
					</xsl:variable>
					<xsl:for-each select="networkr">
						<gmd:onLine>
							<gmd:CI_OnlineResource>
								<gmd:linkage>
									<gmd:URL>
										<xsl:value-of select="string(.)"/>
									</gmd:URL>
								</gmd:linkage>
								<xsl:if test="contains(.,':')">
									<gmd:protocol>
										<gco:CharacterString>
											<xsl:value-of select="substring-before(.,':')"/>
										</gco:CharacterString>
									</gmd:protocol>
								</xsl:if>
								<gmd:name>
									<gco:CharacterString>
										<xsl:value-of select="concat($var_oncomp,', ',string(.))"
										/>
									</gco:CharacterString>
								</gmd:name>
								<gmd:description>
									<gco:CharacterString>
										<xsl:value-of
											select="concat($var_accinstr,' Link from csdgm:networkr.')"
										/>
									</gco:CharacterString>
								</gmd:description>
								<gmd:function>
									<gmd:CI_OnLineFunctionCode
										codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_OnLineFunctionCode"
										codeListValue="download"
										>download</gmd:CI_OnLineFunctionCode>
								</gmd:function>
							</gmd:CI_OnlineResource>
						</gmd:onLine>
					</xsl:for-each>
					<!-- networkr -->
				</xsl:for-each>
				<!-- computer -->
			</xsl:for-each>
			<!-- digtopt -->
			<!-- process offline distribution -->
			<!-- csdgm allows online one offline distribution per digtopt, 
					but stdorder may have multiple digtopt/offoptn; process only the first one here, 
					others would have to be in separate transferOption elements-->
			<xsl:for-each select="digtopt/offoptn[1]">
				<!-- just use for-each to set context node -->
				<gmd:offLine>
					<gmd:MD_Medium>
						<gmd:name>
							<!-- csdgm only allows one offmedia value -->
							<xsl:variable name="var_mediaType">
								<xsl:call-template name="vmf:mediumType">
									<xsl:with-param name="input" select="offmedia"/>
								</xsl:call-template>
							</xsl:variable>
							<xsl:variable name="var_mediaCode">
								<xsl:call-template name="vmf:mediumCode">
									<xsl:with-param name="input" select="offmedia"/>
								</xsl:call-template>
							</xsl:variable>
							<gmd:MD_MediumNameCode>
								<xsl:attribute name="codeList">
									<xsl:value-of
										select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MediumNameCode')"
									/>
								</xsl:attribute>
								<xsl:attribute name="codeListValue">
									<xsl:value-of select="string($var_mediaType)"/>
								</xsl:attribute>
								<xsl:attribute name="codeSpace">
									<xsl:value-of select="string($var_mediaCode)"/>
								</xsl:attribute>
								<xsl:value-of select="string(offmedia)"/>
							</gmd:MD_MediumNameCode>
						</gmd:name>
						<xsl:for-each select="reccap/recden">
							<gmd:density>
								<xsl:choose>
									<xsl:when test="number(.)=number(.)">
										<gco:Real>
											<xsl:value-of select="string(number(.))"/>
										</gco:Real>
									</xsl:when>
									<xsl:otherwise>
										<!-- bogus trick to get whatever is in the source into the output... -->
										<xsl:attribute name="gco:nilReason">
											<xsl:value-of select="'inapplicable'"/>
										</xsl:attribute>
										<xsl:element name="gco:Real">
											<xsl:attribute name="uuidref">
												<xsl:value-of select="string(.)"/>
											</xsl:attribute>
										</xsl:element>
									</xsl:otherwise>
								</xsl:choose>
							</gmd:density>
						</xsl:for-each>
						<xsl:if test="count(reccap/recdenu)>0">
							<gmd:densityUnits>
								<gco:CharacterString>
									<xsl:value-of select="string(recdenu)"/>
								</gco:CharacterString>
							</gmd:densityUnits>
						</xsl:if>
						<xsl:for-each select="recfmt">
							<gmd:mediumFormat>
								<!-- csdgm allows multiple formats on one offoptn -->
								<!-- formats are mapped to ISO mediumCodes -->
								<xsl:variable name="var_recFormatName">
									<xsl:call-template name="vmf:encodingType">
										<xsl:with-param name="input"
											select="."
										/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="var_recFormatCode">
									<xsl:call-template name="vmf:encodingCode">
										<xsl:with-param name="input"
											select="."
										/>
									</xsl:call-template>
								</xsl:variable>
								<gmd:MD_MediumFormatCode>
									<xsl:attribute name="codeList">
										<xsl:value-of
											select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MediumFormatCode')"
										/>
									</xsl:attribute>
									<xsl:attribute name="codeListValue">
										<xsl:value-of select="$var_recFormatName"/>
									</xsl:attribute>
									<xsl:attribute name="codeSpace">
										<xsl:value-of select="$var_recFormatCode"/>
									</xsl:attribute>
									<xsl:value-of select="."/>
								</gmd:MD_MediumFormatCode>
							</gmd:mediumFormat>
						</xsl:for-each>
						<xsl:if test="count(compat)>0">
							<gmd:mediumNote>
								<gco:CharacterString>
									<xsl:value-of select="normalize-space(string(.))"/>
								</gco:CharacterString>
							</gmd:mediumNote>
						</xsl:if>
					</gmd:MD_Medium>
				</gmd:offLine>
			</xsl:for-each>
		</gmd:MD_DigitalTransferOptions>
	</xsl:template>
	<!-- transfer options -->

	<!--  section 1, functions to translate generic codelist terms into ISO codeListValue and codelist code -->
	<xsl:template name="vmf:geometryType">
		<xsl:param name="input"/>
		<xsl:variable name="var_ucinput">
			<xsl:call-template name="ucase">
				<xsl:with-param name="theString" select="$input"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$var_ucinput='POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='PIXEL'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='GRID CELL'">
				<xsl:value-of select="'area'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='VOXEL'">
				<xsl:value-of select="'area'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:geometryCode">
		<xsl:param name="input"/>
		<xsl:variable name="var_ucinput">
			<xsl:call-template name="ucase">
				<xsl:with-param name="theString" select="$input"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$var_ucinput='POINT'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='PIXEL'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='GRID CELL'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='VOXEL'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:geometryType2">
		<xsl:param name="input"/>
		<xsl:variable name="var_ucinput">
			<xsl:call-template name="ucase">
				<xsl:with-param name="theString" select="$input"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$var_ucinput='POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ENTITY POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='LABEL POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='AREA POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='NODE, PLANAR GRAPH'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='NODE, NETWORK'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='STRING'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='LINK'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='COMPLETE CHAIN'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='AREA CHAIN'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='NETWORK CHAIN, PLANAR GRAPH'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='NETWORK CHAIN, NONPLANAR GRAPH'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='CIRCULAR ARC, THREE POINT CENTER'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ELLIPTICAL ARC'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='UNIFORM B-SPLINE'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='PIECEWISE BEZIER'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='RING WITH MIXED COMPOSITION'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='RING COMPOSED OF STRINGS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='RING COMPOSED OF CHAINS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='RING COMPOSED OF ARCS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='G-POLYGON'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='GT-POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='GT-POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='UNIVERSE POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='UNIVERSE POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:geometryCode2">
		<xsl:param name="input"/>
		<xsl:variable name="var_ucinput">
			<xsl:call-template name="ucase">
				<xsl:with-param name="theString" select="$input"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$var_ucinput='POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ENTITY POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='LABEL POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='AREA POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='NODE, PLANAR GRAPH'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='NODE, NETWORK'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='STRING'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='LINK'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='COMPLETE CHAIN'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='AREA CHAIN'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='NETWORK CHAIN, PLANAR GRAPH'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='NETWORK CHAIN, NONPLANAR GRAPH'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='CIRCULAR ARC, THREE POINT CENTER'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ELLIPTICAL ARC'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='UNIFORM B-SPLINE'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='PIECEWISE BEZIER'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='RING WITH MIXED COMPOSITION'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='RING COMPOSED OF STRINGS'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='RING COMPOSED OF CHAINS'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='RING COMPOSED OF ARCS'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='G-POLYGON'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='GT-POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='GT-POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='UNIVERSE POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='UNIVERSE POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<!--not used	<xsl:template name="vmf:unknown">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$var_ucinput='UNKNOWN'">
				<xsl:value-of select="'unknown'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>-->
	<xsl:template name="vmf:docType">
		<xsl:param name="input"/>
		<xsl:variable name="var_ucinput">
			<xsl:call-template name="ucase">
				<xsl:with-param name="theString" select="$input"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$var_ucinput='ATLAS'">
				<xsl:value-of select="'mapHardcopy'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='AUDIO'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='DIAGRAM'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='DOCUMENT'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='GLOBE'">
				<xsl:value-of select="'documentHardcopy'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='MAP'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='PRINTED MAP'">
				<xsl:value-of select="'mapHardcopy'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='MODEL'">
				<xsl:value-of select="'modelDigital'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='PHYSICAL MODELl'">
				<xsl:value-of select="'modelHardcopy'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='MULTIMEDIA PRESENTATION'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='PROFILE'">
				<xsl:value-of select="'profileDigital'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='CROSS-SECTION'">
				<xsl:value-of select="'profileHardcopy'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='RASTER DIGITAL DATA'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='REMOTE-SENSING IMAGE'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='SECTION'">
				<xsl:value-of select="'profileHardcopy'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='SPREADSHEET'">
				<xsl:value-of select="'tableDigital'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='TABULAR DIGITAL DATA'">
				<xsl:value-of select="'tableDigital'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='VECTOR DIGITAL DATA'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='VIDEO'">
				<xsl:value-of select="'videoDigital'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='VIEW'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='DATABASE'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:docCode">
		<xsl:param name="input"/>
		<xsl:variable name="var_ucinput">
			<xsl:call-template name="ucase">
				<xsl:with-param name="theString" select="$input"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$var_ucinput='ATLAS'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='AUDIO'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='DIAGRAM'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='DOCUMENT'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='GLOBE'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='MAP'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='PRINTED MAP'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='MODEL'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='PHYSICAL MODELl'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='MULTIMEDIA PRESENTATION'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='PROFILE'">
				<xsl:value-of select="'009'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='CROSS-SECTION'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='RASTER DIGITAL DATA'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='REMOTE-SENSING IMAGE'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='SECTION'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='SPREADSHEET'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='TABULAR DIGITAL DATA'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='VECTOR DIGITAL DATA'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='VIDEO'">
				<xsl:value-of select="'013'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='VIEW'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='DATABASE'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:statusType">
		<xsl:param name="input"/>
		<xsl:variable name="var_ucinput">
			<xsl:call-template name="ucase">
				<xsl:with-param name="theString" select="$input"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$var_ucinput='COMPLETED'">
				<xsl:value-of select="'completed'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='COMPLETE'">
				<xsl:value-of select="'completed'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ARCHIVED'">
				<xsl:value-of select="'historicalArchive'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='OBSOLETE'">
				<xsl:value-of select="'obsolete'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ON GOING'">
				<xsl:value-of select="'onGoing'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='CONTINUALLY'">
				<xsl:value-of select="'onGoing'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='PLANNED'">
				<xsl:value-of select="'planned'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='REQUIRED'">
				<xsl:value-of select="'required'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='IN PROGRESS'">
				<xsl:value-of select="'underDevelopment'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='IN WORK'">
				<xsl:value-of select="'underDevelopment'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:statusCode">
		<xsl:param name="input"/>
		<xsl:variable name="var_ucinput">
			<xsl:call-template name="ucase">
				<xsl:with-param name="theString" select="$input"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$var_ucinput='COMPLETED'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='COMPLETE'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ARCHIVED'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='OBSOLETE'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ON GOING'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='CONTINUALLY'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='PLANNED'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='REQUIRED'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='IN PROGRESS'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='IN WORK'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:updateFrequency">
		<xsl:param name="input"/>
		<xsl:variable name="var_ucinput">
			<xsl:call-template name="ucase">
				<xsl:with-param name="theString" select="$input"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$var_ucinput='CONTINUALLY'">
				<xsl:value-of select="'continual'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='DAILY'">
				<xsl:value-of select="'daily'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='WEEKLY'">
				<xsl:value-of select="'weekly'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='TWO WEEKS'">
				<xsl:value-of select="'fortnightly'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='MONTHLY'">
				<xsl:value-of select="'monthly'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='QUARTERLY'">
				<xsl:value-of select="'quarterly'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='BIANNUALLY'">
				<xsl:value-of select="'biannually'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ANNUALLY'">
				<xsl:value-of select="'annually'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='YEARLY'">
				<xsl:value-of select="'annually'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='AS NEEDED'">
				<xsl:value-of select="'asNeeded'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='IRREGULAR'">
				<xsl:value-of select="'irregular'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='NOT PLANNED'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='NONE PLANNED'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='UNKNOWN'">
				<xsl:value-of select="'unknown'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='NONE'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:updateFrequencyCode">
		<xsl:param name="input"/>
		<xsl:variable name="var_ucinput">
			<xsl:call-template name="ucase">
				<xsl:with-param name="theString" select="$input"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$var_ucinput='CONTINUALLY'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='DAILY'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='WEEKLY'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='TWO WEEKS'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='MONTHLY'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='QUARTERLY'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='BIANNUALLY'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ANNUALLY'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='YEARLY'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='AS NEEDED'">
				<xsl:value-of select="'009'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='IRREGULAR'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='NOT PLANNED'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='NONE PLANNED'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='UNKNOWN'">
				<xsl:value-of select="'012'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='NONE'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'012'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:securityClassType">
		<xsl:param name="input"/>
		<xsl:variable name="var_ucinput">
			<xsl:call-template name="ucase">
				<xsl:with-param name="theString" select="$input"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$var_ucinput='CONFIDENTIAL'">
				<xsl:value-of select="'confidential'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='SECRET'">
				<xsl:value-of select="'secret'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='TOP SECRET'">
				<xsl:value-of select="'topSecret'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='UNCLASSIFIED'">
				<xsl:value-of select="'unclassified'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='RESTRICTED'">
				<xsl:value-of select="'restricted'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='SECERT'">
				<xsl:value-of select="'secret'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:securityClassCode">
		<xsl:param name="input"/>
		<xsl:variable name="var_ucinput">
			<xsl:call-template name="ucase">
				<xsl:with-param name="theString" select="$input"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$var_ucinput='CONFIDENTIAL'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='SECRET'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='TOP SECRET'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='UNCLASSIFIED'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='RESTRICTED'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='SECERT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:spatialRepresentationType">
		<xsl:param name="input"/>
		<xsl:variable name="var_ucinput">
			<xsl:call-template name="ucase">
				<xsl:with-param name="theString" select="$input"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$var_ucinput='POINT'">
				<xsl:value-of select="'vector'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='VECTOR'">
				<xsl:value-of select="'vector'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='RASTER'">
				<xsl:value-of select="'grid'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:spatialRepresentationCode">
		<xsl:param name="input"/>
		<xsl:variable name="var_ucinput">
			<xsl:call-template name="ucase">
				<xsl:with-param name="theString" select="$input"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$var_ucinput='VECTOR'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='GRID'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:mediumType">
		<xsl:param name="input"/>
		<xsl:variable name="var_ucinput">
			<xsl:call-template name="ucase">
				<xsl:with-param name="theString" select="$input"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$var_ucinput='CD-ROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='DVD'">
				<xsl:value-of select="'dvd'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='DVD-ROM'">
				<xsl:value-of select="'dvdRom'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='3-1/2 INCH FLOPPY DISK'">
				<xsl:value-of select="'3halfInchFloppy'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='5-1/4 INCH FLOPPY'">
				<xsl:value-of select="'5quarterInchFloppy'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='7-TRACK TAPE'">
				<xsl:value-of select="'7trackTape'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='9-TRACK TAPE'">
				<xsl:value-of select="'9trackType'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='9-TRACK'">
				<xsl:value-of select="'9trackTape'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='3480 CARTRIDGE'">
				<xsl:value-of select="'3480Cartridge'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='3490 CARTRIDGE'">
				<xsl:value-of select="'3490Cartridge'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='3580 CARTRIDGE'">
				<xsl:value-of select="'3580Cartridge'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='4 MM CARTRIDGE'">
				<xsl:value-of select="'4mmCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='8 MM CARTRIDGE'">
				<xsl:value-of select="'8mmCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='1/4 INCH CARTRIDGE'">
				<xsl:value-of select="'1quarterInchCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='DIGITAL LINEAR TAPE'">
				<xsl:value-of select="'digitalLinearTape'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ONLINE'">
				<xsl:value-of select="'onLine'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='SATELLITE'">
				<xsl:value-of select="'satellite'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='TELEPHONE LINK'">
				<xsl:value-of select="'telephoneLink'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='HARDCOPY'">
				<xsl:value-of select="'hardcopy'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='CD ROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='CDROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:mediumCode">
		<xsl:param name="input"/>
		<xsl:variable name="var_ucinput">
			<xsl:call-template name="ucase">
				<xsl:with-param name="theString" select="$input"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$var_ucinput='CD-ROM'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='DVD'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='DVD-ROM'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='3-1/2 INCH FLOPPY DISK'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='5-1/4 INCH FLOPPY'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='7-TRACK TAPE'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='9-TRACK TAPE'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='9-TRACK'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='3480 CARTRIDGE'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='3490 CARTRIDGE'">
				<xsl:value-of select="'009'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='3580 CARTRIDGE'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='4 MM CARTRIDGE'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='8 MM CARTRIDGE'">
				<xsl:value-of select="'012'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='1/4 INCH CARTRIDGE'">
				<xsl:value-of select="'013'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='DIGITAL LINEAR TAPE'">
				<xsl:value-of select="'014'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ONLINE'">
				<xsl:value-of select="'015'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='SATELLITE'">
				<xsl:value-of select="'016'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='TELEPHONE LINK'">
				<xsl:value-of select="'017'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='HARDCOPY'">
				<xsl:value-of select="'018'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='CD ROM'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='CDROM'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:encodingType">
		<xsl:param name="input"/>
		<xsl:variable name="var_ucinput">
			<xsl:call-template name="ucase">
				<xsl:with-param name="theString" select="$input"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$var_ucinput='CPIO'">
				<xsl:value-of select="'cpio'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='TAR'">
				<xsl:value-of select="'tar'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='HIGH SEIRRA'">
				<xsl:value-of select="'highSierra'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ISO 9660'">
				<xsl:value-of select="'iso9660'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ISO 9660 WITH ROCK RIDGE'">
				<xsl:value-of select="'iso9660RockRidge'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ISO 9660 UNIX'">
				<xsl:value-of select="'iso9660RockRidge'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ISO 9660 WITH APPLE HFS'">
				<xsl:value-of select="'iso9660AppleHFS'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ISO 9660 MAC'">
				<xsl:value-of select="'iso9660AppleHFS'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:encodingCode">
		<xsl:param name="input"/>
		<xsl:variable name="var_ucinput">
			<xsl:call-template name="ucase">
				<xsl:with-param name="theString" select="$input"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$var_ucinput='CPIO'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='TAR'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='HIGH SEIRRA'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ISO 9660'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ISO 9660 WITH ROCK RIDGE'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ISO 9660 UNIX'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ISO 9660 WITH APPLE HFS'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$var_ucinput='ISO 9660 MAC'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<!-- end of codelist lookup functions -->
	<!--   ***** -->
	<!-- xml header stuff -->
<!--	<xsl:namespace-alias stylesheet-prefix="gml" result-prefix="#default"/>-->

	<xsl:output method="xml" encoding="UTF-8" indent="yes"/>

	<!--  ******************************************************************** -->
	<!--                   **************************                          -->
	<!-- ********************************************************************* -->
	<!-- Start actual output metadata record here, let's get down to business -->
	<xsl:template match="metadata">
		<xsl:variable name="currentDateTime">
			<xsl:value-of select="string('2014-12-31T12:00:00Z')"/>
		</xsl:variable>
		<gmd:MD_Metadata xmlns:gml="http://www.opengis.net/gml">
			<xsl:attribute name="xsi:schemaLocation">
				<xsl:value-of
					select="'http://www.isotc211.org/2005/gmd http://schemas.opengis.net/iso/19139/20060504/gmd/gmd.xsd'"/>
			</xsl:attribute>
			<xsl:variable name="var_metadataRoot" select="."/>

			<gmd:fileIdentifier>
				<gco:CharacterString>
					<xsl:choose>
						<xsl:when
							test="count($var_metadataRoot/idinfo/citation/citeinfo/onlink[1])>0">
							<xsl:value-of
								select="normalize-space(substring-after(string($var_metadataRoot/idinfo/citation/citeinfo/onlink[1]),'//'))"
							/>
						</xsl:when>
						<xsl:when test="count($var_metadataRoot/distinfo[1]/resdesc)>0">
							<xsl:value-of
								select="translate(normalize-space(string($var_metadataRoot/distinfo[1]/resdesc)),' ','')"
							/>
						</xsl:when>
						<xsl:otherwise>
							<!-- put in something, USGIN profile requires... -->
							<xsl:value-of
								select="concat(string('http://www.opengis.net/def/nil/OGC/0/missing/'),$currentDateTime)"
							/>
						</xsl:otherwise>
					</xsl:choose>
				</gco:CharacterString>
			</gmd:fileIdentifier>
			<!-- these all have fixed values for now -->
			<gmd:language>
				<gco:CharacterString>eng</gco:CharacterString>
			</gmd:language>
			<gmd:characterSet>
				<gmd:MD_CharacterSetCode
					codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CharacterSetCode"
					codeListValue="utf8" codeSpace="004">utf8</gmd:MD_CharacterSetCode>
			</gmd:characterSet>
			<gmd:hierarchyLevel>
				<gmd:MD_ScopeCode
					codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode"
					codeListValue="dataset" codeSpace="005">dataset</gmd:MD_ScopeCode>
			</gmd:hierarchyLevel>
			<!-- end fixed values, now start pulling stuff from input record -->
			<gmd:hierarchyLevelName>
				<gco:CharacterString>
					<xsl:value-of select="$var_metadataRoot/distinfo/resdesc"/>
				</gco:CharacterString>
			</gmd:hierarchyLevelName>
			<gmd:contact>
				<gmd:CI_ResponsibleParty>

					<xsl:call-template name="usgin:contactName">
						<xsl:with-param name="the-cntinfo"
							select="$var_metadataRoot/metainfo/metc/cntinfo"/>
						<!--						<xsl:with-param name="inputOrganizationNode" select="($var_contactOrganisation_exists)"/>
						<xsl:with-param name="inputPositionNode"	select="($var_metadataRoot/metainfo/metc/cntinfo/cntpos)"/>
-->
					</xsl:call-template>
					<gmd:contactInfo>
						<xsl:call-template name="usgin:contactHandler">
							<xsl:with-param name="the-cntinfo"
								select="$var_metadataRoot/metainfo/metc/cntinfo"/>
						</xsl:call-template>

					</gmd:contactInfo>
					<!-- role gets a fixed value; FGDC doesn't allow for different roles, so assume point of contact -->
					<gmd:role>
						<gmd:CI_RoleCode
							codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode"
							codeListValue="pointOfContact" codeSpace="007"
							>pointOfContact</gmd:CI_RoleCode>
					</gmd:role>
				</gmd:CI_ResponsibleParty>
			</gmd:contact>
			<gmd:dateStamp>
				<!-- content is gco:DateTime; don't put in multiple dates (would be invalid in csdgm and iso19115) -->
				<xsl:for-each select="$var_metadataRoot/metainfo[1]/metd[1]">
					<xsl:variable name="var_formatMetd">
					<xsl:call-template name="usgin:TimePositionFormat">
						<xsl:with-param name="inputDate" select="."/>
					</xsl:call-template>
					</xsl:variable>
				<xsl:choose>
					<xsl:when test="starts-with($var_formatMetd,'nil')">
						<xsl:attribute name="gco:nilReason">
							<xsl:value-of select="'unknown'"/>
						</xsl:attribute>
					</xsl:when>
					<xsl:otherwise>
						<gco:DateTime>
							<xsl:value-of select="string($var_formatMetd)"/>
						</gco:DateTime>
					</xsl:otherwise>
				</xsl:choose>
				</xsl:for-each>
			</gmd:dateStamp>
			<gmd:metadataStandardName>
				<gco:CharacterString>
					<xsl:value-of select="'ISO-USGIN'"/>
				</gco:CharacterString>
			</gmd:metadataStandardName>
			<gmd:metadataStandardVersion>
				<gco:CharacterString>
					<xsl:value-of select="'1.2'"/>
				</gco:CharacterString>
			</gmd:metadataStandardVersion>
			<!-- if there is a URL supplied in the citation for the resource, use this as the resource identifier -->
			<gmd:dataSetURI>
				<gco:CharacterString>
					<xsl:choose>
						<!-- check first for FGDC-STD-012-2002 (extensions for Remote Sensing) identifier, that would be the best... -->
						<xsl:when test="count($var_metadataRoot/idinfo/datsetid)>0">
							<xsl:value-of
								select="normalize-space(string($var_metadataRoot/idinfo/datsetid))"
							/>
						</xsl:when>
						<!-- otherwise try a couple things that might be in original FGDC CSDGM -->
						<xsl:when
							test="count($var_metadataRoot/idinfo/citation/citeinfo/onlink[1])>0">
							<xsl:value-of
								select="normalize-space(string($var_metadataRoot/idinfo/citation/citeinfo/onlink[1]))"
							/>
						</xsl:when>
						<xsl:when test="count($var_metadataRoot/distinfo[1]/resdesc)>0">
							<xsl:value-of
								select="normalize-space(string($var_metadataRoot/distinfo[1]/resdesc))"
							/>
						</xsl:when>
						<xsl:otherwise>
							<!-- put in something, USGIN profile requires... -->
							<xsl:value-of
								select="concat(string('http://www.opengis.net/def/nil/OGC/0/missing/'),$currentDateTime)"
							/>
						</xsl:otherwise>
					</xsl:choose>
				</gco:CharacterString>
			</gmd:dataSetURI>

			<!-- metadata/spdoinfo spatial data information -->
			<xsl:for-each select="$var_metadataRoot/spdoinfo[1]">
				<!-- spatial representation -->
				<xsl:for-each select="rastinfo">
					<xsl:variable name="var_rastinfoNode" select="."/>
					<gmd:spatialRepresentationInfo>
						<gmd:MD_GridSpatialRepresentation>
							<xsl:variable name="var_rowCount_exists" select="(count(rowcount))>0"/>
							<xsl:variable name="var_colCount_exists" select="(count(colcount))>0"/>
							<xsl:variable name="var_vrtCount_exists" select="(count(vrtcount))>0"/>
							<gmd:numberOfDimensions>
								<xsl:choose>
									<xsl:when
										test="(number($var_rowCount_exists) + number($var_colCount_exists) + number($var_vrtCount_exists))>0">
										<gco:Integer>
											<xsl:value-of
												select="string((number($var_rowCount_exists) + number($var_colCount_exists) + number($var_vrtCount_exists)))"
											/>
										</gco:Integer>
									</xsl:when>
									<xsl:otherwise>
										<gco:Integer>
											<xsl:value-of select="string('1')"/>
										</gco:Integer>
									</xsl:otherwise>
								</xsl:choose>
							</gmd:numberOfDimensions>
							<!-- This for-each and the similar ones below were commented out by Ted Habermann 2011-07-26
									<xsl:for-each select="$var72_metadata/idinfo/citation/citeinfo/lworkcit">-->
							<gmd:axisDimensionProperties>
								<gmd:MD_Dimension>
									<gmd:dimensionName>
										<!--											<xsl:variable name="var_hasRow"  select="(if (exists($var_rastinfoNode/rowcount)) then 'row' else ())"/>-->
										<xsl:if test="count($var_rastinfoNode/rowcount)>0">
											<gmd:MD_DimensionNameTypeCode
												codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode"
												codeListValue="row" codeSpace="001"
												>row</gmd:MD_DimensionNameTypeCode>
										</xsl:if>
									</gmd:dimensionName>
									<xsl:if test="count($var_rastinfoNode/rowcount)>0">
										<gmd:dimensionSize>
											<gco:Integer>
												<xsl:value-of
												select="string($var_rastinfoNode/rowcount)"
												/>
											</gco:Integer>
										</gmd:dimensionSize>
									</xsl:if>
								</gmd:MD_Dimension>
							</gmd:axisDimensionProperties>
							<!--</xsl:for-each>-->
							<!--<xsl:for-each select="$var72_metadata/idinfo/citation/citeinfo/lworkcit">-->
							<gmd:axisDimensionProperties>
								<gmd:MD_Dimension>
									<gmd:dimensionName>
										<!--											<xsl:variable name="var_hasColumn"  select="(if (exists($var_rastinfoNode/colcount)) then 'column' else ())"/>-->
										<xsl:if test="count($var_rastinfoNode/colcount)>0">
											<gmd:MD_DimensionNameTypeCode
												codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode"
												codeListValue="column" codeSpace="002"
												>column</gmd:MD_DimensionNameTypeCode>
										</xsl:if>
									</gmd:dimensionName>
									<gmd:dimensionSize>
										<xsl:for-each select="$var_rastinfoNode/colcount">
											<gco:Integer>
												<xsl:value-of select="string(.)"/>
											</gco:Integer>
										</xsl:for-each>
									</gmd:dimensionSize>
								</gmd:MD_Dimension>
							</gmd:axisDimensionProperties>
							<!--</xsl:for-each>-->
							<!--<xsl:for-each select="$var72_metadata/idinfo/citation/citeinfo/lworkcit">-->
							<xsl:if test="count($var_rastinfoNode/vrtcount)>0">
								<gmd:axisDimensionProperties>
									<gmd:MD_Dimension>
										<gmd:dimensionName>
											<!--<xsl:variable name="var_hasVertical"  select="(if (count($var_rastinfoNode/vrtcount)) then 'vertical' else ())"/>-->
											<gmd:MD_DimensionNameTypeCode
												codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode"
												codeListValue="vertical" codeSpace="003"
												>vertical</gmd:MD_DimensionNameTypeCode>
										</gmd:dimensionName>
										<gmd:dimensionSize>
											<xsl:for-each select="$var_rastinfoNode/vrtcount">
												<gco:Integer>
												<xsl:value-of select="string(.)"/>
												</gco:Integer>
											</xsl:for-each>
										</gmd:dimensionSize>
									</gmd:MD_Dimension>
								</gmd:axisDimensionProperties>
							</xsl:if>
							<!--</xsl:for-each>-->
							<!-- determine if input data has a rasttype property and use that to assign cell geometry Type code -->
							<xsl:variable name="var_rasttypeGeometryType">
								<xsl:call-template name="vmf:geometryType">
									<xsl:with-param name="input"
										select="rasttype"
									/>
								</xsl:call-template>
							</xsl:variable>
							<!-- if have gridSpatialRepresnetation, cellGeometry is mandatory -->
							<xsl:choose>
								<xsl:when test="string-length($var_rasttypeGeometryType)>0">
									<gmd:cellGeometry>
										<gmd:MD_CellGeometryCode
											codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CellGeometryCode">
											<xsl:attribute name="codeListValue">
												<xsl:value-of
												select="string($var_rasttypeGeometryType)"
												/>
											</xsl:attribute>
											<xsl:variable name="var_rasttypeGeometryCode">
												<xsl:call-template name="vmf:geometryCode">
												<xsl:with-param name="input"
												select="rasttype"
												/>
												</xsl:call-template>
											</xsl:variable>
											<xsl:if test="string-length($var_rasttypeGeometryCode)>0">
												<xsl:attribute name="codeSpace">
												<xsl:value-of
												select="string($var_rasttypeGeometryCode)"
												/>
												</xsl:attribute>
											</xsl:if>
											<xsl:value-of select="$var_rasttypeGeometryType"/>
										</gmd:MD_CellGeometryCode>
									</gmd:cellGeometry>
								</xsl:when>
								<xsl:otherwise>
									<gmd:cellGeometry gco:nilReason="missing"/>
								</xsl:otherwise>
							</xsl:choose>
							<!-- no content for transformation parmater avaialalbility in FGDC metatada -->
							<gmd:transformationParameterAvailability>
								<xsl:attribute name="gco:nilReason">
									<xsl:value-of select="unknown"/>
								</xsl:attribute>
							</gmd:transformationParameterAvailability>
						</gmd:MD_GridSpatialRepresentation>
					</gmd:spatialRepresentationInfo>
				</xsl:for-each>
				<!-- do vector spatial representation description; FGCD xml specifies choice between 
						rastinfo or ptvctinf but ISO19115 allows both to be present in valid instance -->
				<xsl:for-each select="ptvctinf">
					<!-- Point and Vector Object Information,+ the types and numbers of vector or nongridded point spatial objects in the data set. -->
					<!-- FGDC xml implements this element as a choice between 1..* sdtsterm elements, or 1 vpfterm  -->
					<xsl:if test="count(sdtsterm)>0">
						<gmd:spatialRepresentationInfo>
							<gmd:MD_VectorSpatialRepresentation>
								<xsl:for-each select="sdtsterm">								<gmd:geometricObjects>
									<gmd:MD_GeometricObjects>
										<gmd:geometricObjectType>
											<xsl:choose>
												<xsl:when test="count(sdtstype)>0">	
													<xsl:variable name="var_geometryType2">
														<xsl:call-template name="vmf:geometryType2">
															<xsl:with-param name="input" select="sdtstype"/>
														</xsl:call-template>
													</xsl:variable>
													<xsl:variable name="var_geometryCode2">
														<xsl:call-template name="vmf:geometryCode2">
															<xsl:with-param name="input" select="sdtstype"/>
														</xsl:call-template>
													</xsl:variable>
													
													<xsl:choose>
														
														<xsl:when test="$var_geometryType2 != 'unknown'">
															<gmd:MD_GeometricObjectTypeCode>
																<xsl:attribute name="codeList">
																	<xsl:value-of select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_GeometricObjectTypeCode')"/>
																</xsl:attribute>
																<xsl:attribute name="codeListValue">
																	<xsl:value-of select="string($var_geometryType2)"/>
																</xsl:attribute>
																<xsl:attribute name="codeSpace">
																	<xsl:value-of select="string($var_geometryCode2)"/>
																</xsl:attribute>
																<xsl:value-of select="string(sdtstype)"/>
															</gmd:MD_GeometricObjectTypeCode>
														</xsl:when>
														<xsl:otherwise>
															<!-- geometry type lookup failed -->
															<gmd:MD_GeometricObjectTypeCode>
																<xsl:attribute name="codeList">
																	<xsl:value-of select="string('http://www.opengis.net/def/nil/OGC/0/missing')"/>
																</xsl:attribute>
																<xsl:attribute name="codeListValue">
																	<xsl:value-of select="string(sdtstype)"/>
																</xsl:attribute>
																<xsl:value-of select="string(sdtstype)"/>
															</gmd:MD_GeometricObjectTypeCode>
														</xsl:otherwise>
													</xsl:choose>
												</xsl:when>
												<xsl:otherwise>
													<xsl:attribute name="gco:nilReason">
														<xsl:value-of select="'missing'"/>
													</xsl:attribute>
												</xsl:otherwise>
											</xsl:choose>
										</gmd:geometricObjectType>
										<xsl:if test="count(ptvctcnt)>0">
											<gmd:geometricObjectCount>
												<gco:Integer>
													<xsl:value-of select="string(number(ptvctcnt))"/>
												</gco:Integer>
											</gmd:geometricObjectCount>
										</xsl:if>
									</gmd:MD_GeometricObjects>
								</gmd:geometricObjects>
								</xsl:for-each>
								
							</gmd:MD_VectorSpatialRepresentation>
						</gmd:spatialRepresentationInfo>
					</xsl:if>
					<xsl:if test="count(vpfterm)>0">
						<gmd:spatialRepresentationInfo>
							<gmd:MD_VectorSpatialRepresentation>
								<gmd:topologyLevel>
									<gmd:MD_TopologyLevelCode>
										<!-- Levels 0,1,2,3, defined by Department of Defense, 1992, Vector Product Format (MIL-STD-600006): Philadelphia, Department of Defense, Defense Printing Service Detachment Office, page 34 -->
										<xsl:choose>
											<xsl:when test="count(vpfterm/vpflevel)>0 and (number(vpfterm/vpflevel)=number(vpfterm/vpflevel)) and (number(vpfterm/vpflevel) &lt; 4)">
												<!-- vpf level should be: '0 <= VPF Topology Level <= 3' -->
												<xsl:attribute name="codeList">
													<xsl:value-of
														select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_TopologyLevelCode')"
													/>
												</xsl:attribute>
												<xsl:attribute name="codeSpace">
													<xsl:value-of
														select="normalize-space(string(vpfterm/vpflevel))"
													/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:choose>
														<xsl:when test="number(vpfterm/vpflevel)=0">
															<xsl:value-of select="'geometryOnly'"/>
														</xsl:when>
														<xsl:when test="number(vpfterm/vpflevel)=1">
															<xsl:value-of select="'topology1D'"/>
														</xsl:when>
														<xsl:when test="number(vpfterm/vpflevel)=2">														<xsl:value-of select="'planarGraph'"/>
														</xsl:when>
														<xsl:when test="number(vpfterm/vpflevel)=3">														<xsl:value-of select="'fullPlanarGraph'"/>
														</xsl:when>
													</xsl:choose>
												</xsl:attribute>
											</xsl:when>
											<xsl:otherwise>
												<xsl:attribute name="codeList">
													<xsl:value-of select="string('http://www.opengis.net/def/nil/OGC/0/missing')"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:value-of select="vpflevel"/>
												</xsl:attribute>
											</xsl:otherwise>
										</xsl:choose>
									</gmd:MD_TopologyLevelCode>
								</gmd:topologyLevel>
								<xsl:for-each select="vpfterm/vpfinfo">
									<gmd:geometricObjects>
										<gmd:MD_GeometricObjects>
											<gmd:geometricObjectType>
												<xsl:variable name="var_vpfTypeExists">
													<xsl:if test="count(vpftype)>0">
														<xsl:value-of select="string(vpftype)"/>
													</xsl:if>
												</xsl:variable>
												<xsl:variable name="var_vpfgeometryType2">
													<xsl:call-template name="vmf:geometryType2">
														<xsl:with-param name="input" select="$var_vpfTypeExists"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:variable name="var_vpfgeometryCode2">
													<xsl:call-template name="vmf:geometryCode2">
														<xsl:with-param name="input" select="$var_vpfTypeExists"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:choose>
													<xsl:when test="not(count(vpftype)>0)">
														<!-- error condition, sdtstype is required -->
														<xsl:attribute name="gco:nilReason">
															<xsl:value-of select="'missing'"/>
														</xsl:attribute>
													</xsl:when>
													<xsl:when test="$var_vpfgeometryType2 != 'unknown'">
														<gmd:MD_GeometricObjectTypeCode>
															<xsl:attribute name="codeList">
																<xsl:value-of select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_GeometricObjectTypeCode')"/>
															</xsl:attribute>
															<xsl:attribute name="codeListValue">
																<xsl:value-of select="string($var_vpfgeometryType2)"/>
															</xsl:attribute>
															<xsl:attribute name="codeSpace">
																<xsl:value-of select="string($var_vpfgeometryCode2)"/>
															</xsl:attribute>
															<xsl:value-of select="string(vpftype)"/>
														</gmd:MD_GeometricObjectTypeCode>
													</xsl:when>
													<xsl:otherwise>
														<!-- geometry type lookup faile -->
														
														<gmd:MD_GeometricObjectTypeCode>
															<xsl:attribute name="codeList">
																<xsl:value-of select="string('http://www.opengis.net/def/nil/OGC/0/missing')"/>
															</xsl:attribute>
															<xsl:attribute name="codeListValue">
																<xsl:value-of select="string(vpftype)"/>
															</xsl:attribute>
															<xsl:value-of select="string(vpftype)"/>
														</gmd:MD_GeometricObjectTypeCode>
														
													</xsl:otherwise>
												</xsl:choose>
											</gmd:geometricObjectType>
											<xsl:if test="count(ptvctcnt)>0">
												<gmd:geometricObjectCount>
							<gco:Integer>
														<xsl:value-of select="string(ptvctcnt)"/>
													</gco:Integer>
												</gmd:geometricObjectCount>
											</xsl:if>
										</gmd:MD_GeometricObjects>
									</gmd:geometricObjects>
								</xsl:for-each>
							</gmd:MD_VectorSpatialRepresentation>
						</gmd:spatialRepresentationInfo>
					</xsl:if>
				</xsl:for-each>
				<!-- spatial reference system information -->
			<!-- indspref is an indirect spatial reference: any way to describe a location without using 
				coordinates. Indirect spatial reference methods usually use a geographic feature, 
				such as a county, state, township or section of the Public Land Survey System, or a road, 
				to uniquely identify a place. The reference may use the name of the feature, for example
				"Westmoreland County", or a code that identifies the feature (such as a county FIPS code). Other
				examples of indirect spatial references include street addresses, linear reference systems, and 
				River Reach codes. -->
			<!-- this is bogus; what need here is a mappign from '4.1.2.1.1 Map Projection Name - 
				name of the map projection' domain values to EPSG codes -->
			<!-- these are the domain values:
				Albers Conical Equal Area
				Azimuthal Equidistant
				Equidistant Conic
				Equirectangular
				General Vertical Near-sided Perspective Gnomonic
				Lambert Azimuthal Equal Area
				Lambert Conformal Conic
				Mercator
				Modified Stereographic for Alaska
				Miller Cylindrical
				Oblique Mercator
				Orthographic
				Polar Stereographic
				Polyconic
				Robinson
				Sinusoidal
				Space Oblique Mercator
				Stereographic
				Transverse Mercator
				van der Grinten -->
	<!--		<xsl:for-each select="$var_metadataRoot/spdoinfo">-->
				<xsl:for-each select="indspref">
		<!-- put cdsgm 'Indirect Spatial Reference' into the code characterString...-->
					<gmd:referenceSystemInfo>
					<gmd:MD_ReferenceSystem>

							<gmd:referenceSystemIdentifier>
								<gmd:RS_Identifier>
									<!-- smr change gmd:CodeSpace to gmd:code -->
									<gmd:code>
										<gco:CharacterString>
											 <xsl:value-of select="string(.)"/>

										</gco:CharacterString>
									</gmd:code>
								</gmd:RS_Identifier>
							</gmd:referenceSystemIdentifier>

					</gmd:MD_ReferenceSystem>
				</gmd:referenceSystemInfo>
				</xsl:for-each> <!-- indspref  -->
			</xsl:for-each> <!-- processing spdinfo section of csdgm -->
			<!-- metadata extensions FGDC metainfo/metextns/onlink here  -->
			<gmd:metadataExtensionInfo>
				<gmd:MD_MetadataExtensionInformation>
					<gmd:extensionOnLineResource>
						<gmd:CI_OnlineResource>
							<gmd:linkage>
								<gmd:URL>
									<xsl:variable name="CIlinkURL">
										<xsl:value-of
											select="count(/metadata/metainfo/metextns[1]/onlink)"
										/>
									</xsl:variable>
									<xsl:for-each select="/metadata/metainfo/metextns[1]/onlink">
										<xsl:value-of
											select="normalize-space(string(.))"/>
										<xsl:if test="($CIlinkURL>1)">
											<xsl:value-of select="string(' ')"/>
										</xsl:if>
									</xsl:for-each>
								</gmd:URL>
							</gmd:linkage>
							<xsl:for-each select="metprof">
								<gmd:name>
									<gco:CharacterString>
										<xsl:value-of
											select="concat('Profile Name:', normalize-space(string(.)))"
										/>
									</gco:CharacterString>
								</gmd:name>
							</xsl:for-each>
						</gmd:CI_OnlineResource>
					</gmd:extensionOnLineResource>
				</gmd:MD_MetadataExtensionInformation>
			</gmd:metadataExtensionInfo>
			
	<!-- *************************************************************************-->
			<!-- FGDC id metadata/idinfo goes into MD_identification -->
			<!-- context is metadata/idinfo -->
			<xsl:for-each select="$var_metadataRoot/idinfo">
				<xsl:variable name="var_idinfoSourceNode" select="."/>
				<gmd:identificationInfo>
					<gmd:MD_DataIdentification>
						<xsl:for-each select="citation/citeinfo">
							<gmd:citation>
									<xsl:call-template name="usgin:citinfoHandler">
										<xsl:with-param name="theciteinfo" select="."/>
									</xsl:call-template>
							</gmd:citation>
						</xsl:for-each>
						<gmd:abstract>
							<gco:CharacterString>
								<xsl:choose>
									<xsl:when
										test="count(descript/abstract)>0 and string-length(string(descript/abstract))>0">
										<xsl:value-of
											select="normalize-space(string(descript/abstract))"
										/>
									</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="string('no abstract provided')"/>
									</xsl:otherwise>
								</xsl:choose>
<!-- insert text for spatial data organization, spatial data reference, and entity attribute information
							that is not well accounted for in transformation -->
<!-- the following text is modified from FGDC_Classic for Web body
An xsl template for displaying metadata in ArcInfo8 with the traditional FGDC look and feel created by mp-->
								Other sections: <xsl:for-each select="$var_metadataRoot/spdoinfo">
									Spatial Data Organization: <xsl:for-each select="indspref">
										Indirect_Spatial_Reference_Method: <xsl:value-of select="."
										/>
									</xsl:for-each>
									<xsl:for-each select="direct"> Direct_Spatial_Reference_Method:
											<xsl:value-of select="."/>
									</xsl:for-each>
									<xsl:for-each select="ptvctinf">
										Point_and_Vector_Object_Information: <xsl:for-each
											select="sdtsterm"> SDTS_Terms_Description: <xsl:for-each
												select="sdtstype">
												SDTS_Point_and_Vector_Object_Type: <xsl:value-of
												select="."/>
											</xsl:for-each>
											<xsl:for-each select="ptvctcnt">
												Point_and_Vector_Object_Count: <xsl:value-of
												select="."/>
											</xsl:for-each>
										</xsl:for-each>
										<xsl:for-each select="vpfterm"> VPF_Terms_Description:
												<xsl:for-each select="vpflevel"> VPF_Topology_Level:
												<xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="vpfinfo">
												VPF_Point_and_Vector_Object_Information:
												<xsl:for-each select="vpftype">
												VPF_Point_and_Vector_Object_Type: <xsl:value-of
												select="."/>
												</xsl:for-each>
												<xsl:for-each select="ptvctcnt">
												Point_and_Vector_Object_Count: <xsl:value-of
												select="."/>
												</xsl:for-each>
											</xsl:for-each>
										</xsl:for-each>
									</xsl:for-each>
									<xsl:for-each select="rastinfo"> Raster_Object_Information:
											<xsl:for-each select="rasttype"> Raster_Object_Type:
												<xsl:value-of select="."/>
										</xsl:for-each>
										<xsl:for-each select="rowcount"> Row_Count: <xsl:value-of
												select="."/>
										</xsl:for-each>
										<xsl:for-each select="colcount"> Column_Count: <xsl:value-of
												select="."/>
										</xsl:for-each>
										<xsl:for-each select="vrtcount"> Vertical_Count:
												<xsl:value-of select="."/>
										</xsl:for-each>
									</xsl:for-each>
								</xsl:for-each>
								<!-- Spatial Reference text blob gets put in the abstract if its present.-->
								<xsl:for-each select="$var_metadataRoot/spref">
									Spatial_Reference_Information: <xsl:for-each select="horizsys">
										Horizontal_Coordinate_System_Definition: <xsl:for-each
											select="geograph"> Geographic: <xsl:for-each
												select="latres"> Latitude_Resolution: <xsl:value-of
												select="."/>
											</xsl:for-each>
											<xsl:for-each select="longres"> Longitude_Resolution:
												<xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="geogunit">
												Geographic_Coordinate_Units: <xsl:value-of
												select="."/>
											</xsl:for-each>
										</xsl:for-each>
										<xsl:for-each select="planar"> Planar: <xsl:for-each
												select="mapproj"> Map_Projection: <xsl:for-each
												select="mapprojn"> Map_Projection_Name:
												<xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="albers">
												Albers_Conical_Equal_Area: </xsl:for-each>
												<xsl:for-each select="azimequi">
												Azimuthal_Equidistant: </xsl:for-each>
												<xsl:for-each select="equicon"> Equidistant_Conic: </xsl:for-each>
												<xsl:for-each select="equirect"> Equirectangular: </xsl:for-each>
												<xsl:for-each select="gvnsp">
												General_Vertical_Near-sided_Perspective: </xsl:for-each>
												<xsl:for-each select="gnomonic"> Gnomonic: </xsl:for-each>
												<xsl:for-each select="lamberta">
												Lambert_Azimuthal_Equal_Area: </xsl:for-each>
												<xsl:for-each select="lambertc">
												Lambert_Conformal_Conic: </xsl:for-each>
												<xsl:for-each select="mercator"> Mercator: </xsl:for-each>
												<xsl:for-each select="modsak">
												Modified_Stereographic_for_Alaska: </xsl:for-each>
												<xsl:for-each select="miller"> Miller_Cylindrical: </xsl:for-each>
												<xsl:for-each select="obqmerc"> Oblique_Mercator: </xsl:for-each>
												<xsl:for-each select="orthogr"> Orthographic: </xsl:for-each>
												<xsl:for-each select="polarst"> Polar_Stereographic: </xsl:for-each>
												<xsl:for-each select="polycon"> Polyconic: </xsl:for-each>
												<xsl:for-each select="robinson"> Robinson: </xsl:for-each>
												<xsl:for-each select="sinusoid"> Sinusoidal: </xsl:for-each>
												<xsl:for-each select="spaceobq">
												Space_Oblique_Mercator_(Landsat): </xsl:for-each>
												<xsl:for-each select="stereo"> Stereographic: </xsl:for-each>
												<xsl:for-each select="transmer">
												Transverse_Mercator: </xsl:for-each>
												<xsl:for-each select="vdgrin"> van_der_Grinten: </xsl:for-each>
												<xsl:apply-templates select="*"/>
												<!-- this is where the work gets done, in the template for each projection -->
											</xsl:for-each>
											<xsl:for-each select="gridsys"> Grid_Coordinate_System:
												<xsl:for-each select="gridsysn">
												Grid_Coordinate_System_Name: <xsl:value-of
												select="."/>
												</xsl:for-each>
												<xsl:for-each select="utm">
												Universal_Transverse_Mercator: <xsl:for-each
												select="utmzone"> UTM_Zone_Number: <xsl:value-of
												select="."/>
												</xsl:for-each>
												<xsl:for-each select="transmer">
												Transverse_Mercator: </xsl:for-each>
												<xsl:apply-templates select="transmer"/>
												</xsl:for-each>
												<xsl:for-each select="ups">
												Universal_Polar_Stereographic: <xsl:for-each
												select="upszone"> UPS_Zone_Identifier:
												<xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="polarst">
												Polar_Stereographic: </xsl:for-each>
												<xsl:apply-templates select="polarst"/>
												</xsl:for-each>
												<xsl:for-each select="spcs">
												State_Plane_Coordinate_System: <xsl:for-each
												select="spcszone"> SPCS_Zone_Identifier:
												<xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="lambertc">
												Lambert_Conformal_Conic: </xsl:for-each>
												<xsl:apply-templates select="lambertc"/>
												<xsl:for-each select="transmer">
												Transverse_Mercator: </xsl:for-each>
												<xsl:apply-templates select="transmer"/>
												<xsl:for-each select="obqmerc"> Oblique_Mercator: </xsl:for-each>
												<xsl:apply-templates select="obqmerc"/>
												<xsl:for-each select="polycon"> Polyconic: </xsl:for-each>
												<xsl:apply-templates select="polycon"/>
												</xsl:for-each>
												<xsl:for-each select="arcsys">
												ARC_Coordinate_System: <xsl:for-each
												select="arczone"> ARC_System_Zone_Identifier:
												<xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="equirect"> Equirectangular: </xsl:for-each>
												<xsl:apply-templates select="equirect"/>
												<xsl:for-each select="azimequi">
												Azimuthal_Equidistant: </xsl:for-each>
												<xsl:apply-templates select="azimequi"/>
												</xsl:for-each>
												<xsl:for-each select="othergrd">
												Other_Grid_System's_Definition: <xsl:value-of
												select="."/>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="localp"> Local_Planar:
												<xsl:for-each select="localpd">
												Local_Planar_Description: <xsl:value-of select="."
												/>
												</xsl:for-each>
												<xsl:for-each select="localpgi">
												Local_Planar_Georeference_Information:
												<xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="planci">
												Planar_Coordinate_Information: <xsl:for-each
												select="plance">
												Planar_Coordinate_Encoding_Method: <xsl:value-of
												select="."/>
												</xsl:for-each>
												<xsl:for-each select="coordrep">
												Coordinate_Representation: <xsl:for-each
												select="absres"> Abscissa_Resolution:
												<xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="ordres">
												Ordinate_Resolution: <xsl:value-of select="."/>
												</xsl:for-each>
												</xsl:for-each>
												<xsl:for-each select="distbrep">
												Distance_and_Bearing_Representation: <xsl:for-each
												select="distres"> Distance_Resolution:
												<xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="bearres">
												Bearing_Resolution: <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="bearunit"> Bearing_Units:
												<xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="bearrefd">
												Bearing_Reference_Direction: <xsl:value-of
												select="."/>
												</xsl:for-each>
												<xsl:for-each select="bearrefm">
												Bearing_Reference_Meridian: <xsl:value-of
												select="."/>
												</xsl:for-each>
												</xsl:for-each>
												<xsl:for-each select="plandu">
												Planar_Distance_Units: <xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
										</xsl:for-each>
										<xsl:for-each select="local"> Local: <xsl:for-each
												select="localdes"> Local_Description: <xsl:value-of
												select="."/>
											</xsl:for-each>
											<xsl:for-each select="localgeo">
												Local_Georeference_Information: <xsl:value-of
												select="."/>
											</xsl:for-each>
										</xsl:for-each>
										<xsl:for-each select="geodetic"> Geodetic_Model:
												<xsl:for-each select="horizdn">
												Horizontal_Datum_Name: <xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="ellips"> Ellipsoid_Name:
												<xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="semiaxis"> Semi-major_Axis:
												<xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="denflat">
												Denominator_of_Flattening_Ratio: <xsl:value-of
												select="."/>
											</xsl:for-each>
										</xsl:for-each>
									</xsl:for-each>
									<xsl:for-each select="vertdef">
										Vertical_Coordinate_System_Definition: <xsl:for-each
											select="altsys"> Altitude_System_Definition:
												<xsl:for-each select="altdatum">
												Altitude_Datum_Name: <xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="altres"> Altitude_Resolution:
												<xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="altunits">
												Altitude_Distance_Units: <xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="altenc"> Altitude_Encoding_Method:
												<xsl:value-of select="."/>
											</xsl:for-each>
										</xsl:for-each>
										<xsl:for-each select="depthsys"> Depth_System_Definition:
												<xsl:for-each select="depthdn"> Depth_Datum_Name:
												<xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="depthres"> Depth_Resolution:
												<xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="depthdu"> Depth_Distance_Units:
												<xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="depthem"> Depth_Encoding_Method:
												<xsl:value-of select="."/>
											</xsl:for-each>
										</xsl:for-each>
									</xsl:for-each>
								</xsl:for-each>
								<!-- End spatial reference section -->
								<!-- Entity and Attribute -->
								<xsl:for-each select="$var_metadataRoot/eainfo">
									Entity_and_Attribute_Information: <xsl:for-each
										select="detailed"> Detailed_Description: <xsl:for-each
											select="enttyp"> Entity_Type: <xsl:for-each
												select="enttypl"> Entity_Label: <xsl:value-of
												select="."/>
											</xsl:for-each>
											<xsl:for-each select="enttypd"> Entity_Definition:
												<xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="enttypds"> Definition_Source:
												<xsl:value-of select="."/>
											</xsl:for-each>
										</xsl:for-each>
										<xsl:for-each select="attr"> Attribute: <xsl:for-each
												select="attrlabl"> Attribute_Label: <xsl:value-of
												select="."/>
											</xsl:for-each>
											<xsl:for-each select="attrdef"> Attribute_Definition:
												<xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="attrdefs">
												Attribute_Definition_Source: <xsl:value-of
												select="."/>
											</xsl:for-each>
											<xsl:for-each select="attrdomv">
												Attribute_Domain_Values: <xsl:for-each select="edom"> Enumerated_Domain: <xsl:for-each select="edomv">
												Enumerated_Domain_Value: <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="edomvd">
												Enumerated_Domain_Value_Definition: <xsl:value-of
												select="."/>
												</xsl:for-each>
												<xsl:for-each select="edomvds">
												Enumerated_Domain_Value_Definition_Source:
												<xsl:value-of select="."/>
												</xsl:for-each> Domain Value Attribute:
												<xsl:apply-templates select="attr"/>
												</xsl:for-each>
												<!-- end enumerated domain -->
												<xsl:for-each select="rdom"> Range_Domain:
												<xsl:for-each select="rdommin">
												Range_Domain_Minimum: <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="rdommax">
												Range_Domain_Maximum: <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="attrunit">
												Attribute_Units_of_Measure: <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="attrmres">
												Attribute_Measurement_Resolution: <xsl:value-of select="."/>
												</xsl:for-each> Range Domain Attribute:
												<xsl:apply-templates select="attr"/>
												</xsl:for-each>
												<xsl:for-each select="codesetd"> Codeset_Domain:
												<xsl:for-each select="codesetn"> Codeset_Name:
												<xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="codesets"> Codeset_Source:
												<xsl:value-of select="."/>
												</xsl:for-each>
												</xsl:for-each>
												<xsl:for-each select="udom"> Unrepresentable_Domain:
												<xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="begdatea">
												Beginning_Date_of_Attribute_Values: <xsl:value-of
												select="."/>
											</xsl:for-each>
											<xsl:for-each select="enddatea">
												Ending_Date_of_Attribute_Values: <xsl:value-of
												select="."/>
											</xsl:for-each>
											<xsl:for-each select="attrvai">
												Attribute_Value_Accuracy_Information: <xsl:for-each
												select="attrva"> Attribute_Value_Accuracy:
												<xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="attrvae">
												Attribute_Value_Accuracy_Explanation:
												<xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="attrmfrq">
												Attribute_Measurement_Frequency: <xsl:value-of
												select="."/>
											</xsl:for-each>
										</xsl:for-each>
									</xsl:for-each>
									<xsl:for-each select="overview"> Overview_Description:
											<xsl:for-each select="eaover">
											Entity_and_Attribute_Overview: <xsl:value-of select="string(.)"
											/>
										</xsl:for-each>
										<xsl:for-each select="eadetcit">
											Entity_and_Attribute_Detail_Citation: <xsl:value-of
												select="string(.)"/>
										</xsl:for-each>
									</xsl:for-each>
								</xsl:for-each>
								<!-- end of Entity Attribute section text blob, end of text for abstract element -->
								<!--  /xsl:template -->
							</gco:CharacterString>
						</gmd:abstract>
						
						<xsl:for-each select="descript/purpose">
							<gmd:purpose>
								<gco:CharacterString>
									<xsl:value-of select="normalize-space(string(.))"/>
								</gco:CharacterString>
							</gmd:purpose>
						</xsl:for-each>
						<xsl:for-each select="datacred">
							<gmd:credit>
								<gco:CharacterString>
									<xsl:value-of select="normalize-space(string(.))"/>
								</gco:CharacterString>
							</gmd:credit>
						</xsl:for-each>
						<xsl:for-each select="$var_idinfoSourceNode/status/progress">
							<xsl:variable name="var_lcProgress">
								<xsl:call-template name="lcase">
									<xsl:with-param name="theString" select="."/>
								</xsl:call-template>
							</xsl:variable>
						<gmd:status>
							<gmd:MD_ProgressCode>
								<!-- csdgm allows {"Complete", "In work", "Planned"}
								map to ISO {completed, underDevelopment, planned}-->
								<xsl:variable name="var_csdgmProgressCode">
									<xsl:value-of select="'complete, in work, planned'"/>
								</xsl:variable>
									<xsl:attribute name="codeList">
										<xsl:choose>
											<xsl:when
												test="contains($var_csdgmProgressCode,$var_lcProgress)">
												<xsl:value-of
												select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ProgressCode')"
												/>
											</xsl:when>
											<xsl:otherwise>
												<xsl:value-of
												select="string('http://www.opengis.net/def/nil/OGC/0/missing')"
												/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:attribute>
								<xsl:variable name="var_theProgCode">
									<xsl:value-of select="$var_lcProgress"/>
								</xsl:variable>
									<xsl:attribute name="codeListValue">
											<xsl:choose>
											<xsl:when test="contains($var_theProgCode,'complete')">
												<xsl:value-of select="'completed'"/>
											</xsl:when>
											<xsl:when test="contains($var_theProgCode,'work')">
												<xsl:value-of select="'underDevelopment'"/>
											</xsl:when>
											<xsl:when test="contains($var_theProgCode,'planned')">
												<xsl:value-of select="'planned'"/>
											</xsl:when>
											<xsl:otherwise>
												<xsl:value-of select="$var_theProgCode"/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:attribute>
								<xsl:value-of select="$var_theProgCode"/>
								</gmd:MD_ProgressCode>
							
						</gmd:status>
						</xsl:for-each> <!-- check for status/progress -->
			<!-- ******************************************************************************** -->			
						
						<xsl:for-each select="ptcontac">
							<gmd:pointOfContact>
								<!-- ptcontac/cntinfo -->
								<xsl:for-each select="cntinfo">
									<!-- xsl:variable name="var_ptcontac-cntinfo_node" select="."/ -->
									<gmd:CI_ResponsibleParty>
										<xsl:call-template name="usgin:contactName">
											<xsl:with-param name="the-cntinfo" select="."/>
										</xsl:call-template>
										<gmd:contactInfo>
											<xsl:call-template name="usgin:contactHandler">
												<xsl:with-param name="the-cntinfo" select="."/>
											</xsl:call-template>
										</gmd:contactInfo>
										<gmd:role>
											<gmd:CI_RoleCode>
												<xsl:attribute name="codeList">
												<xsl:value-of
												select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode')"
												/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
												<xsl:value-of
												select="string('pointOfContact')"/>
												</xsl:attribute>
												<xsl:attribute name="codeSpace">
												<xsl:value-of select="string('007')"
												/>
												</xsl:attribute>
												<xsl:value-of select="'pointOfContact'"/>
											</gmd:CI_RoleCode>
										</gmd:role>
									</gmd:CI_ResponsibleParty>
								</xsl:for-each>
							</gmd:pointOfContact>
						</xsl:for-each>
						<!-- +++ Resource maintenance frequency section -->
						<xsl:if test="count(status/update)>0">
						<gmd:resourceMaintenance>
							<gmd:MD_MaintenanceInformation>
								<gmd:maintenanceAndUpdateFrequency>
									<xsl:variable name="var338_result_vmf11_inputtoresult">
										<xsl:call-template name="vmf:updateFrequency">
											<xsl:with-param name="input"
												select="status/update"
											/>
										</xsl:call-template>
									</xsl:variable>
									<xsl:if test="string-length($var338_result_vmf11_inputtoresult)>0">
										<gmd:MD_MaintenanceFrequencyCode>
											<xsl:attribute name="codeList">
												<xsl:value-of
												select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MaintenanceFrequencyCode')"
												/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:value-of
												select="string($var338_result_vmf11_inputtoresult)"
												/>
											</xsl:attribute>
											<xsl:variable name="var337_result_vmf12_inputtoresult">
												<xsl:call-template name="vmf:updateFrequencyCode">
												<xsl:with-param name="input"
												select="status/update"
												/>
												</xsl:call-template>
											</xsl:variable>

											<xsl:if
												test="string-length($var337_result_vmf12_inputtoresult)>0">
												<xsl:attribute name="codeSpace">
												<xsl:value-of
												select="string($var337_result_vmf12_inputtoresult)"
												/>
												</xsl:attribute>
											</xsl:if>
											<xsl:value-of
												select="$var338_result_vmf11_inputtoresult"/>
										</gmd:MD_MaintenanceFrequencyCode>
									</xsl:if>
								</gmd:maintenanceAndUpdateFrequency>
							</gmd:MD_MaintenanceInformation>
						</gmd:resourceMaintenance>
						</xsl:if>
						<xsl:for-each select="$var_metadataRoot/eainfo/detailed/attr">
							<xsl:variable name="var_currentattr" select="string(attrlabl)"/>
							<xsl:if test="count(attrmfrq)>0">
							<!-- detailed entity attribute section, attribute Measurement frequency -->
							<gmd:resourceMaintenance>
								<gmd:MD_MaintenanceInformation>
									<gmd:maintenanceAndUpdateFrequency>
										<xsl:variable name="var_lookupUpdateFrequency">
											<xsl:call-template name="vmf:updateFrequency">
												<xsl:with-param name="input"
													select="attrmfrq"
												/>
											</xsl:call-template>
										</xsl:variable>
										<xsl:if test="string-length($var_lookupUpdateFrequency)>0">
											<gmd:MD_MaintenanceFrequencyCode>
												<xsl:attribute name="codeList">
													<xsl:value-of
														select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MaintenanceFrequencyCode')"
													/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:value-of
														select="string($var_lookupUpdateFrequency)"
													/>
												</xsl:attribute>
												<xsl:variable
													name="var_lookupUpdateFrequencyCode">
													<xsl:call-template name="vmf:updateFrequencyCode">
														<xsl:with-param name="input"
															select="attrmfrq"
														/>
													</xsl:call-template>
												</xsl:variable>
												<!--<xsl:if test="string-length($var_lookupUpdateFrequencyCode)>0">-->
												<xsl:if test="$var_lookupUpdateFrequencyCode">													
													<xsl:attribute name="codeSpace">
														<xsl:value-of
															select="string($var_lookupUpdateFrequencyCode)"
														/>
													</xsl:attribute>
												</xsl:if>
												<xsl:value-of
													select="$var_lookupUpdateFrequency"/>
											</gmd:MD_MaintenanceFrequencyCode>
										</xsl:if>
									</gmd:maintenanceAndUpdateFrequency>
									<gmd:updateScope>
										<gmd:MD_ScopeCode>
											<xsl:attribute name="codeList">
												<xsl:value-of
												select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode')"
												/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:value-of
												select="string('attribute')"/>
											</xsl:attribute>
										</gmd:MD_ScopeCode>
									</gmd:updateScope>
								</gmd:MD_MaintenanceInformation>
							</gmd:resourceMaintenance>
							</xsl:if>
						</xsl:for-each>
						<!-- Handle browse graphic if it exists -->
						<xsl:for-each select="browse">
							<gmd:graphicOverview>
								<gmd:MD_BrowseGraphic>
									<gmd:fileName>
										<gco:CharacterString>
											<xsl:value-of select="string(browsen)"/>
										</gco:CharacterString>
									</gmd:fileName>
									<gmd:fileDescription>
										<gco:CharacterString>
											<xsl:value-of select="string(browsed)"/>
										</gco:CharacterString>
									</gmd:fileDescription>
									<gmd:fileType>
										<gco:CharacterString>
											<xsl:value-of select="string(browset)"/>
										</gco:CharacterString>
									</gmd:fileType>
								</gmd:MD_BrowseGraphic>
							</gmd:graphicOverview>
						</xsl:for-each>
						<!-- handle Keywords, grouped by theme with a thesaurus element for each theme -->
						<!-- if ...kt (keyword thesaurus) is missing, fgdc xml should be invalid, but in real world... -->

						<xsl:for-each select="keywords/theme">
							<gmd:descriptiveKeywords>
								<gmd:MD_Keywords>
									<xsl:for-each select="themekey">
										<gmd:keyword>
											<gco:CharacterString>
												<xsl:value-of
												select="normalize-space(string(.))"/>
											</gco:CharacterString>
										</gmd:keyword>
									</xsl:for-each>
									<gmd:type>
										<gmd:MD_KeywordTypeCode
											codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode"
											codeListValue="theme" codeSpace="005">
											<xsl:value-of select="'theme'"/>
										</gmd:MD_KeywordTypeCode>
									</gmd:type>
									<xsl:choose>
										<xsl:when test="count(themekt)>0">
											<gmd:thesaurusName>
												<gmd:CI_Citation>
												<gmd:title>
												<gco:CharacterString>
												<xsl:value-of select="normalize-space(themekt)"
												/>
												</gco:CharacterString>
												</gmd:title>
												<gmd:date>
												<xsl:attribute name="gco:nilReason">
												<xsl:value-of select="string('unknown')"/>
												</xsl:attribute>
												</gmd:date>
												</gmd:CI_Citation>
											</gmd:thesaurusName>
										</xsl:when>
										<xsl:otherwise>
											<gmd:thesaurusName gco:nilReason="missing"/>
										</xsl:otherwise>
									</xsl:choose>

								</gmd:MD_Keywords>
							</gmd:descriptiveKeywords>
						</xsl:for-each>

						<xsl:for-each select="keywords/place">
							<gmd:descriptiveKeywords>
								<gmd:MD_Keywords>
									<xsl:for-each select="placekey">
										<gmd:keyword>
											<gco:CharacterString>
												<xsl:value-of
												select="normalize-space(string(.))"/>
											</gco:CharacterString>
										</gmd:keyword>
									</xsl:for-each>
									<gmd:type>
										<gmd:MD_KeywordTypeCode
											codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode"
											codeListValue="place" codeSpace="002">
											<xsl:value-of select="'place'"/>
										</gmd:MD_KeywordTypeCode>
									</gmd:type>
									<xsl:choose>
										<xsl:when test="count(placekt)>0">
											<gmd:thesaurusName>
												<gmd:CI_Citation>
												<gmd:title>
												<gco:CharacterString>
												<xsl:value-of select="normalize-space(placekt)"
												/>
												</gco:CharacterString>
												</gmd:title>
												<gmd:date>
												<xsl:attribute name="gco:nilReason">
												<xsl:value-of select="string('unknown')"/>
												</xsl:attribute>
												</gmd:date>
												</gmd:CI_Citation>
											</gmd:thesaurusName>
										</xsl:when>
										<xsl:otherwise>
											<gmd:thesaurusName gco:nilReason="missing"/>
										</xsl:otherwise>
									</xsl:choose>

								</gmd:MD_Keywords>
							</gmd:descriptiveKeywords>
						</xsl:for-each>
						<!--	</xsl:otherwise>
							</xsl:choose>-->
						<!-- stratum keywords -->
						<!-- alternate logic for thesaurus name -->
						<!--xsl for-each-group select="keywords/stratum" group-by="string(string(stratkt))">
								<xsl:variable name="var364_cur_result_groupby" as="item()+" select="current-group()"/>
								<xsl:variable name="var365_cur_result_groupby"  select="current-grouping-key()"/ -->
						<xsl:for-each select="keywords/stratum">
							<gmd:descriptiveKeywords>
								<gmd:MD_Keywords>
									<xsl:for-each select="stratkey">
										<gmd:keyword>
											<gco:CharacterString>
												<xsl:value-of
												select="normalize-space(string(.))"/>
											</gco:CharacterString>
										</gmd:keyword>
									</xsl:for-each>
									<gmd:type>
										<gmd:MD_KeywordTypeCode
											codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode"
											codeListValue="stratum" codeSpace="003">
											<xsl:value-of select="'stratum'"/>
										</gmd:MD_KeywordTypeCode>
									</gmd:type>
									<xsl:choose>
										<xsl:when test="count(stratkt)>0">
											<gmd:thesaurusName>
												<gmd:CI_Citation>
												<gmd:title>
												<gco:CharacterString>
												<xsl:value-of
												select="normalize-space(string(stratkt))"/>
												</gco:CharacterString>
												</gmd:title>
												<gmd:date>
												<xsl:attribute name="gco:nilReason">
												<xsl:value-of
												select="string(string('unknown'))"/>
												</xsl:attribute>
												</gmd:date>
												</gmd:CI_Citation>
											</gmd:thesaurusName>
										</xsl:when>
										<xsl:otherwise>
											<gmd:thesaurusName gco:nilReason="missing"/>
										</xsl:otherwise>
									</xsl:choose>
								</gmd:MD_Keywords>
							</gmd:descriptiveKeywords>
						</xsl:for-each>
						<!--						<xsl:if test="string-length(string(keywords/temporal[1]/tempkey[1]))>0">-->
						<xsl:for-each select="keywords/temporal">
							<!--xsl:variable name="var370_cur_result_groupby" as="item()+" select="current-group()"/>
								<xsl:variable name="var371_cur_result_groupby"  select="current-grouping-key()"/ -->
							<gmd:descriptiveKeywords>
								<gmd:MD_Keywords>
									<xsl:for-each select="tempkey">
										<gmd:keyword>
											<gco:CharacterString>
												<xsl:value-of
												select="normalize-space(string(.))"/>
											</gco:CharacterString>
										</gmd:keyword>
									</xsl:for-each>
									<gmd:type>
										<gmd:MD_KeywordTypeCode
											codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode"
											codeListValue="temporal" codeSpace="004">
											<xsl:value-of select="'temporal'"/>
										</gmd:MD_KeywordTypeCode>
									</gmd:type>
									<xsl:choose>
										<xsl:when test="count(tempkt)>0">
											<gmd:thesaurusName>
												<gmd:CI_Citation>
												<gmd:title>
												<gco:CharacterString>
												<xsl:value-of
												select="normalize-space(string(tempkt))"/>
												</gco:CharacterString>
												</gmd:title>
												<gmd:date>
												<xsl:attribute name="gco:nilReason">
												<xsl:value-of
												select="string(string('unknown'))"/>
												</xsl:attribute>
												</gmd:date>
												</gmd:CI_Citation>
											</gmd:thesaurusName>
										</xsl:when>
										<xsl:otherwise>
											<gmd:thesaurusName gco:nilReason="missing"/>
										</xsl:otherwise>
									</xsl:choose>
								</gmd:MD_Keywords>
							</gmd:descriptiveKeywords>
						</xsl:for-each>
						<!--</xsl:if>-->
						<!-- resource constraints section, distribution liability, access constraint, and use constraints get concatenated into a single gmd:useConstraint 
								text blob -->
						<xsl:variable name="var_distributionLiability_exists">
							<xsl:if test="count($var_metadataRoot/distinfo/distliab)>0">
								<xsl:value-of
									select="concat('Distribution Liability: ', string($var_metadataRoot/distinfo/distliab))"
								/>
							</xsl:if>
						</xsl:variable>
						<xsl:variable name="var_accessConstraints_exists">
							<xsl:if test="count(accconst)>0">
								<xsl:value-of
									select="concat('Access Constraints: ', string($var_metadataRoot//idinfo/accconst))"
								/>
							</xsl:if>
						</xsl:variable>
						<xsl:variable name="var_useLimitation_exists">
							<xsl:if test="count(useconst)>0">
								<xsl:value-of
									select="concat('Use Limitation: ', string($var_metadataRoot/idinfo/useconst))"
								/>
							</xsl:if>
						</xsl:variable>
						<xsl:if
							test="string-length($var_distributionLiability_exists)>0 or string-length($var_accessConstraints_exists)>0 or string-length($var_useLimitation_exists)>0">
							<gmd:resourceConstraints>
								<gmd:MD_LegalConstraints>
									<xsl:if test="string-length($var_accessConstraints_exists)>0">
										<gmd:accessConstraints>
											<gmd:MD_RestrictionCode
												codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode"
												codeListValue="otherRestrictions" codeSpace="008">
												<xsl:value-of select="'otherRestrictions'"/>
											</gmd:MD_RestrictionCode>
										</gmd:accessConstraints>
									</xsl:if>
									<xsl:if test="string-length($var_useLimitation_exists)>0">
										<gmd:useConstraints>
											<gmd:MD_RestrictionCode
												codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode"
												codeListValue="otherRestrictions" codeSpace="008">
												<xsl:value-of select="'otherRestrictions'"/>
											</gmd:MD_RestrictionCode>
										</gmd:useConstraints>
									</xsl:if>
									<gmd:otherConstraints>
										<gco:CharacterString>
											<xsl:value-of
												select="normalize-space(concat( $var_accessConstraints_exists, ' ',   $var_useLimitation_exists, ' ',   $var_distributionLiability_exists))"
											/>
										</gco:CharacterString>
									</gmd:otherConstraints>
								</gmd:MD_LegalConstraints>
							</gmd:resourceConstraints>
						</xsl:if>
						<xsl:for-each select="secinfo">
							<gmd:resourceConstraints>
								<gmd:MD_SecurityConstraints>
									<gmd:classification>
										<xsl:variable name="var388_result_securityClassType">
											<xsl:call-template name="vmf:securityClassType">
												<xsl:with-param name="input"
												select="secclass"
												/>
											</xsl:call-template>
										</xsl:variable>
										
										<xsl:if test="$var388_result_securityClassType">
											<gmd:MD_ClassificationCode>
												<xsl:attribute name="codeList">
												<xsl:value-of
												select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ClassificationCode')"
												/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
												<xsl:value-of
												select="string($var388_result_securityClassType)"
												/>
												</xsl:attribute>
												<xsl:variable name="var387_result_securityClassCode">
												<xsl:call-template name="vmf:securityClassCode">
												<xsl:with-param name="input"
												select="secclass"
												/>
												</xsl:call-template>
												</xsl:variable>
												
												<xsl:if
													test="$var387_result_securityClassCode">
												<xsl:attribute name="codeSpace">
												<xsl:value-of
												select="string($var387_result_securityClassCode)"
												/>
												</xsl:attribute>
												</xsl:if>
												<xsl:value-of
												select="$var388_result_securityClassType"/>
											</gmd:MD_ClassificationCode>
										</xsl:if>
									</gmd:classification>
									<gmd:classificationSystem>
										<gco:CharacterString>
											<xsl:value-of select="string(secsys)"/>
										</gco:CharacterString>
									</gmd:classificationSystem>
									<gmd:handlingDescription>
										<gco:CharacterString>
											<xsl:value-of select="string(sechandl)"/>
										</gco:CharacterString>
									</gmd:handlingDescription>
								</gmd:MD_SecurityConstraints>
							</gmd:resourceConstraints>
						</xsl:for-each>
						<!--  put in relationships to larger work and cross references using gmd:aggregationInfo elements -->
						<xsl:for-each select="citation/citeinfo/lworkcit">
							<!--<xsl:variable name="var_largerWorkCitationNode" select="."/>-->
							<gmd:aggregationInfo>
								<gmd:MD_AggregateInformation>
									<xsl:for-each select="citeinfo">
										<gmd:aggregateDataSetName>
										<xsl:call-template name="usgin:citinfoHandler">
											<xsl:with-param name="theciteinfo" select="."/>
										</xsl:call-template>
									</gmd:aggregateDataSetName>
									</xsl:for-each>
									<gmd:associationType>
										<gmd:DS_AssociationTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode"
											codeListValue="largerWorkCitation" codeSpace="002">
											<xsl:value-of select="'largerWorkCitation'"/>
										</gmd:DS_AssociationTypeCode>
									</gmd:associationType>
								</gmd:MD_AggregateInformation>
							</gmd:aggregationInfo>
						</xsl:for-each>
						<!-- idinfo/crossref cross references -->
						<xsl:for-each select="crossref">
							<gmd:aggregationInfo>
								<gmd:MD_AggregateInformation>
									<xsl:variable name="var693_crossref" select="."/>
									<xsl:for-each select="citinfo">
									<gmd:aggregateDataSetName>
										<xsl:call-template name="usgin:citinfoHandler">
											<xsl:with-param name="theciteinfo" select="."/>
										</xsl:call-template>
									</gmd:aggregateDataSetName>
									</xsl:for-each>
									<gmd:associationType>
										<gmd:DS_AssociationTypeCode>

											<xsl:attribute name="codeList">
												<xsl:value-of
												select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode')"
												/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:value-of select="string('crossReference')"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:value-of select="string('001')"/>
											</xsl:attribute>
											<xsl:value-of select="'CSDGM cross reference'"/>
										</gmd:DS_AssociationTypeCode>
									</gmd:associationType>
								</gmd:MD_AggregateInformation>
							</gmd:aggregationInfo>
						</xsl:for-each>

						<!-- ******************************************************************************************************************* -->
						<!-- Spatial Representation -->
						<xsl:for-each select="$var_metadataRoot/spdoinfo">
							<gmd:spatialRepresentationType>
								<xsl:for-each select="direct">
									<xsl:variable name="var563_result_spatialRepresentationType">
										<xsl:call-template name="vmf:spatialRepresentationType">
											<xsl:with-param name="input"
												select="."
											/>
										</xsl:call-template>
									</xsl:variable>
									<xsl:if
										test="string-length($var563_result_spatialRepresentationType)>0">
										<gmd:MD_SpatialRepresentationTypeCode>
											<xsl:attribute name="codeList">
												<xsl:value-of
												select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_SpatialRepresentationTypeCode')"
												/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:value-of
												select="string($var563_result_spatialRepresentationType)"
												/>
											</xsl:attribute>
											<xsl:variable
												name="var564_result_spatialRepresentationCode">
												<xsl:call-template
												name="vmf:spatialRepresentationCode">
												<xsl:with-param name="input"
												select="$var563_result_spatialRepresentationType"
												/>
												</xsl:call-template>
											</xsl:variable>
											<xsl:if
												test="string-length($var564_result_spatialRepresentationCode)>0">
												<xsl:attribute name="codeSpace">
												<xsl:value-of
												select="string($var564_result_spatialRepresentationCode)"
												/>
												</xsl:attribute>
											</xsl:if>
											<xsl:value-of
												select="$var563_result_spatialRepresentationType"/>
										</gmd:MD_SpatialRepresentationTypeCode>
									</xsl:if>
								</xsl:for-each>
							</gmd:spatialRepresentationType>
						</xsl:for-each>
						<!-- resource language -->
						<gmd:language>
							<gco:CharacterString>
								<xsl:value-of select="'eng'"/>
							</gco:CharacterString>
						</gmd:language>
						<!-- messy logic to extract ISO topic category  -->
						<xsl:variable name="var_ISOCategories">
							<xsl:value-of select="string(' biota boundaries climatologyMeteorologyAtmosphere 
								economy elevation environment farming geoscientificInformation 
								health imageryBaseMapsEarthCover inlandWaters intelligenceMilitary 
								location oceans planningCadastre society structure transportation 
								utilitiesCommunication')"/>
						</xsl:variable>
						<xsl:variable name="hasISOtopic">
							<xsl:for-each select="keywords/theme">
								<xsl:for-each select="themekey">
									<xsl:if
										test="contains($var_ISOCategories, concat(' ',normalize-space(string(.))))">
										<!-- set hasISOtopic variable -->
										<xsl:value-of select="string(.)"/>
									</xsl:if>
								</xsl:for-each>
								<!--		</xsl:if>  -->
							</xsl:for-each>
							<!--	 flag to indicate if catch an ISO topic -->
						</xsl:variable>
						<xsl:choose>
							<xsl:when test="string-length(string($hasISOtopic))>0">
								<xsl:for-each select="keywords/theme">
									<xsl:for-each select="themekey">
										<xsl:if
											test="contains($var_ISOCategories, concat(' ',normalize-space(string(.))))">
											<gmd:topicCategory>
												<gmd:MD_TopicCategoryCode><xsl:value-of select="normalize-space(string(.))"/></gmd:MD_TopicCategoryCode>
											</gmd:topicCategory>
										</xsl:if>
									</xsl:for-each>
								</xsl:for-each>
							</xsl:when>
							<xsl:otherwise>
								<gmd:topicCategory gco:nilReason="missing">
									<!-- put in a dummy value so will pass profile rules -->
									<gmd:MD_TopicCategoryCode><xsl:value-of select="normalize-space(string('geoscientificInformation'))"/></gmd:MD_TopicCategoryCode>
								</gmd:topicCategory>
							</xsl:otherwise>
						</xsl:choose>
						<!-- end topic category section -->

						<xsl:if test="not(not(count($var_metadataRoot/distinfo/techpreq)&gt; 0) and not(native))">
							<!-- kludge to implement logical or -->
						<gmd:environmentDescription>
								<gco:CharacterString>
									<xsl:if
										test="(count($var_metadataRoot/distinfo/techpreq) &gt; 0)">
										<xsl:value-of
											select="concat(string(' Technical Prerequisites: '),string($var_metadataRoot/distinfo/techpreq))"/>
									</xsl:if>
									<xsl:if test="$var_metadataRoot/distinfo/techpreq and native">
										<xsl:value-of select="'; '"/>
									</xsl:if>
									
									<xsl:if test="native">
										<xsl:value-of
											select="concat(string('Native Dataset Environment: '), string(native))"/>
										/>
									</xsl:if>
								</gco:CharacterString>
						</gmd:environmentDescription>
						</xsl:if>
						
						<!-- Extent section, geographic, vertical, temporal... -->
						<gmd:extent>
							<gmd:EX_Extent>
								<xsl:attribute name="id">
									<xsl:value-of select="generate-id()"/>
								</xsl:attribute>
								<gmd:geographicElement>
									<!-- bounding box is mandatory, spatial reference should be EPSG 4326, ie WGS 84 -->
									<!-- geographic extent, lat long bounding box required for USGIN -->
									<gmd:EX_GeographicBoundingBox>
										<xsl:attribute name="id">
											<xsl:value-of select="concat('gbb.', generate-id())"
											/>
										</xsl:attribute>
										<gmd:westBoundLongitude>
											<gco:Decimal>
												<xsl:choose>
													<xsl:when test="number(spdom/bounding/westbc)=number(spdom/bounding/westbc)">
														<xsl:value-of select="string(number(spdom/bounding/westbc))"/>
													</xsl:when>
													<xsl:otherwise>
														<xsl:value-of select="string('-179.9')"/>
													</xsl:otherwise>
												</xsl:choose>
											</gco:Decimal>
										</gmd:westBoundLongitude>
										<gmd:eastBoundLongitude>
											<gco:Decimal>
												<xsl:choose>
												<xsl:when
												test="number(spdom/bounding/eastbc) = number(spdom/bounding/eastbc)">
												<xsl:value-of
												select="number(spdom/bounding/eastbc)"/>
												</xsl:when>
												<xsl:otherwise>
												<xsl:value-of select="string('-60')"/>
												</xsl:otherwise>
												</xsl:choose>
											</gco:Decimal>
										</gmd:eastBoundLongitude>
										<gmd:southBoundLatitude>
											<gco:Decimal>
												<xsl:choose>
												<xsl:when
												test="number(spdom/bounding/southbc)=number(spdom/bounding/southbc)">
												<xsl:value-of
												select="string(number(spdom/bounding/southbc))"
												/>
												</xsl:when>
												<xsl:otherwise>
												<xsl:value-of select="string('14')"/>
												</xsl:otherwise>
												</xsl:choose>
											</gco:Decimal>
										</gmd:southBoundLatitude>
										<gmd:northBoundLatitude>
											<gco:Decimal>
												<xsl:choose>
												<xsl:when
												test="number(spdom/bounding/northbc)=number(spdom/bounding/northbc)">
												<xsl:value-of
												select="string(number(spdom/bounding/northbc))"
												/>
												</xsl:when>
												<xsl:otherwise>
												<xsl:value-of select="string('170')"/>
												</xsl:otherwise>
												</xsl:choose>
											</gco:Decimal>
										</gmd:northBoundLatitude>
									</gmd:EX_GeographicBoundingBox>
								</gmd:geographicElement>
								<xsl:for-each select="spdom/dsgpoly">
									<gmd:geographicElement>
										<!-- handle extent encoded as a polygon -->
									<!--	<xsl:variable name="var582_dsgpoly" select="."/>-->
										<gmd:EX_BoundingPolygon>
											<gmd:polygon>
												<gml:Polygon>
												<xsl:attribute name="gml:id">
												<xsl:value-of
												select="concat('boundingPoly.',generate-id())"/>
												</xsl:attribute>
												<gml:interior>
												<gml:LinearRing>
												<gml:coordinates>
													<xsl:attribute name="decimal">
														<xsl:value-of select="string('.')"/>
													</xsl:attribute>
													<xsl:attribute name="cs">
														<xsl:value-of select="', '"/>
													</xsl:attribute>
													<xsl:attribute name="ts">
														<xsl:value-of select="'; '"/>
													</xsl:attribute>
													<xsl:choose>
														<xsl:when test="dsgpolyo/grngpoin">
															<xsl:for-each select="dsgpolyo/grngpoin">
																<xsl:value-of
																	select="concat(string(gringlat), ', ', string(gringlon), '; ')"/>
															</xsl:for-each>
														</xsl:when>
														<xsl:otherwise>
															<xsl:for-each select="dsgpolyo/gring">
																<xsl:value-of select="."/>
															</xsl:for-each>
														</xsl:otherwise>
													</xsl:choose>
												</gml:coordinates>
			
												</gml:LinearRing>
												</gml:interior>
												</gml:Polygon>
											</gmd:polygon>
										</gmd:EX_BoundingPolygon>
									</gmd:geographicElement>
								</xsl:for-each>
								<!-- temporal extent, single date -->
								<xsl:for-each select="timeperd/timeinfo/sngdate">
									<xsl:variable name="var_extentSingleDate" select="."/>
									<xsl:variable name="var_lccaldate">
										<xsl:call-template name="lcase">
											<xsl:with-param name="theString" select="caldate"/>
										</xsl:call-template>
									</xsl:variable>
									<gmd:temporalElement>
										<gmd:EX_TemporalExtent>
											<xsl:attribute name="id">
												<xsl:value-of
												select="concat('TempEx.', generate-id())"/>
											</xsl:attribute>
											<gmd:extent>												
												<xsl:choose>
													<xsl:when
														test="contains($var_lccaldate, 'unknown') or contains($var_lccaldate, 'unpublished')">
														<xsl:attribute name="gco:nilReason">
															<xsl:value-of select="$var_lccaldate"/>
														</xsl:attribute>
													</xsl:when>
													<xsl:otherwise>
														<gml:TimeInstant>
															<xsl:attribute name="gml:id">
																<xsl:value-of select="concat('TInst.',generate-id())"/>
															</xsl:attribute>
															<!-- context is metadata/idinfo -->
															<xsl:if test="count($var_metadataRoot/idinfo/timeperd/current)>0">
																<gml:description>
																	<xsl:value-of
																		select="string($var_metadataRoot/idinfo/timeperd/current)"
																	/>
																</gml:description>
															</xsl:if>
															<!-- now process the dates -->
															<!--						<xsl:variable name="var_DateTemp"> -->
															<xsl:variable name="var_TimePos">
																<xsl:call-template name="usgin:TimePositionFormat">
																	<xsl:with-param name="inputDate" select="caldate"/>
																	<xsl:with-param name="inputTime" select="time"/>
																</xsl:call-template>
															</xsl:variable>
															<gml:timePosition>
																<xsl:variable name="castableAsDateTime">
																	<xsl:value-of
																		select="(substring($var_TimePos,5,1)='-') and (substring($var_TimePos,8,1)='-') and (substring($var_TimePos,11,1)='T') and (substring($var_TimePos,14,1)=':') and (substring($var_TimePos,17,1)=':')"
																	/>
																</xsl:variable>
																<xsl:choose>
																	<xsl:when test="string($castableAsDateTime)='true'">
																		<xsl:value-of select="$var_TimePos"/>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:attribute name="indeterminatePosition">
																			<xsl:value-of select="string('unknown')"/>
																		</xsl:attribute>
																	</xsl:otherwise>
																</xsl:choose>
															</gml:timePosition>
														</gml:TimeInstant>
													</xsl:otherwise>
												</xsl:choose>
											</gmd:extent>
										</gmd:EX_TemporalExtent>
									</gmd:temporalElement>
								</xsl:for-each>
								<!-- temmporal extent, multiple individual dates and times. 
						 guess the idea is there might be multple mdattim/sngdate elements?-->
								<xsl:for-each select="timeperd/timeinfo/mdattim/sngdate">
									<!-- iterate over sngdate elements in mdattim -->
								<!--	<xsl:variable name="var_mdattmdate" select="."/>-->
									<xsl:variable name="var_lccaldate">
										<xsl:call-template name="lcase">
											<xsl:with-param name="theString" select="caldate"/>
										</xsl:call-template>
									</xsl:variable>
									<gmd:temporalElement>
										<gmd:EX_TemporalExtent>
											<xsl:attribute name="id">
												<xsl:value-of
												select="concat('TimePeriodEx.', generate-id())"
												/>
											</xsl:attribute>
											<gmd:extent>
												<xsl:choose>
													<xsl:when
														test="contains($var_lccaldate, 'unknown') or contains($var_lccaldate, 'unpublished')">
														<xsl:attribute name="gco:nilReason">
															<xsl:value-of select="$var_lccaldate"/>
														</xsl:attribute>
													</xsl:when>
													<xsl:otherwise>
														<gml:TimeInstant>
															<xsl:attribute name="gml:id">
																<xsl:value-of select="concat('TInst.',generate-id())"/>
															</xsl:attribute>
															<!-- context is metadata/idinfo -->
															<xsl:if test="count($var_metadataRoot/idinfo/timeperd/current)>0">
																<gml:description>
																	<xsl:value-of
																		select="string($var_metadataRoot/idinfo/timeperd/current)"
																	/>
																</gml:description>
															</xsl:if>
															<!-- now process the dates -->
															<!--						<xsl:variable name="var_DateTemp"> -->
															<xsl:variable name="var_TimePos">
																<xsl:call-template name="usgin:TimePositionFormat">
																	<xsl:with-param name="inputDate" select="caldate"/>
																	<xsl:with-param name="inputTime" select="time"/>
																</xsl:call-template>
															</xsl:variable>
															<gml:timePosition>
																<xsl:variable name="castableAsDateTime">
																	<xsl:value-of
																		select="(substring($var_TimePos,5,1)='-') and (substring($var_TimePos,8,1)='-') and (substring($var_TimePos,11,1)='T') and (substring($var_TimePos,14,1)=':') and (substring($var_TimePos,17,1)=':')"
																	/>
																</xsl:variable>
																<xsl:choose>
																	<xsl:when test="string($castableAsDateTime)='true'">
																		<xsl:value-of select="$var_TimePos"/>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:attribute name="indeterminatePosition">
																			<xsl:value-of select="string('unknown')"/>
																		</xsl:attribute>
																	</xsl:otherwise>
																</xsl:choose>
															</gml:timePosition>
														</gml:TimeInstant>
													</xsl:otherwise>
												</xsl:choose>
												
											</gmd:extent>
										</gmd:EX_TemporalExtent>
									</gmd:temporalElement>
								</xsl:for-each>
								<!-- temporal extent, range of dates and time -->
								<!-- each rngdates has a rngdates/begdate begtime, and /enddate /endtime -->
								<xsl:for-each select="timeperd/timeinfo/rngdates">
									<xsl:variable name="var_rngdatesNode" select="."/>
									<xsl:variable name="var_lcbegdate">
										<xsl:call-template name="lcase">
											<xsl:with-param name="theString" select="begdate"/>
										</xsl:call-template>
									</xsl:variable>
									<xsl:variable name="var_lcenddate">
										<xsl:call-template name="lcase">
											<xsl:with-param name="theString" select="enddate"/>
										</xsl:call-template>
									</xsl:variable>
									<gmd:temporalElement>
										<gmd:EX_TemporalExtent>
											<xsl:attribute name="id">
												<xsl:value-of select="concat('DateRngEx.', generate-id())"/>
											</xsl:attribute>
											<gmd:extent>
												<gml:TimePeriod>
													<xsl:attribute name="gml:id">
														<xsl:value-of select="concat('bndTimePeriod.',generate-id())"/>
													</xsl:attribute>
													<xsl:if test="count($var_metadataRoot/idinfo/timeperd/current)>0">
														<gml:description>
															<xsl:value-of select="string($var_metadataRoot/idinfo/timeperd/current)"/>
														</gml:description>
													</xsl:if>
													<gml:beginPosition>
														<!-- content is ISO8610 (xs:date) string -->
														<xsl:choose>
															<xsl:when
																test="contains($var_lcbegdate, 'present') or contains($var_lcbegdate, 'now')">
																<xsl:attribute name="indeterminatePosition">
																	<xsl:value-of select="string('now')"/>
																</xsl:attribute>
															</xsl:when>
															
															<xsl:otherwise>
																<xsl:variable name="var_TimePos3">
																	<xsl:call-template name="usgin:TimePositionFormat">
																		<xsl:with-param name="inputDate" select="begdate"/>
																		<xsl:with-param name="inputTime" select="begtime"
																		/>
																	</xsl:call-template>
																</xsl:variable>
																<xsl:variable name="castableAsDateTime3">
																	<xsl:value-of
																		select="(substring($var_TimePos3,5,1)='-') and (substring($var_TimePos3,8,1)='-') and (substring($var_TimePos3,11,1)='T') and (substring($var_TimePos3,14,1)=':') and (substring($var_TimePos3,17,1)=':')"
																	/>
																</xsl:variable>
																<xsl:choose>
																	<xsl:when
																		test="string($castableAsDateTime3)='true'">
																		<xsl:value-of select="$var_TimePos3"/>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:attribute name="indeterminatePosition">
																			<xsl:value-of select="string('unknown')"/>
																		</xsl:attribute>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:otherwise>
														</xsl:choose>
													</gml:beginPosition>
													<gml:endPosition>
														<!-- content is ISO8601 (xs:date) string -->
														<!-- content is ISO8610 (xs:date) string -->
														<xsl:choose>
															<xsl:when
																test="contains($var_lcenddate, 'present') or contains($var_lcenddate, 'now')">
																<xsl:attribute name="indeterminatePosition">
																	<xsl:value-of select="string('now')"/>
																</xsl:attribute>
															</xsl:when>
															
															<xsl:otherwise>
																<xsl:variable name="var_TimePos4">
																	<xsl:call-template name="usgin:TimePositionFormat">
																		<xsl:with-param name="inputDate" select="enddate"/>
																		<xsl:with-param name="inputTime" select="endtime"
																		/>
																	</xsl:call-template>
																</xsl:variable>
																<xsl:variable name="castableAsDateTime4">
																	<xsl:value-of
																		select="(substring($var_TimePos4,5,1)='-') and (substring($var_TimePos4,8,1)='-') and (substring($var_TimePos4,11,1)='T') and (substring($var_TimePos4,14,1)=':') and (substring($var_TimePos4,17,1)=':')"
																	/>
																</xsl:variable>
																<xsl:choose>
																	<xsl:when
																		test="string($castableAsDateTime4)='true'">
																		<xsl:value-of select="$var_TimePos4"/>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:attribute name="indeterminatePosition">
																			<xsl:value-of select="string('unknown')"/>
																		</xsl:attribute>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:otherwise>
														</xsl:choose>												</gml:endPosition>
												</gml:TimePeriod>
											</gmd:extent>
										</gmd:EX_TemporalExtent>
									</gmd:temporalElement>
								</xsl:for-each>
							</gmd:EX_Extent>
						</gmd:extent>
						<!-- supplemental information text blob... -->
						<xsl:for-each select="descript/supplinf">
							<gmd:supplementalInformation>
								<gco:CharacterString>
									<xsl:value-of select="string(.)"/>
								</gco:CharacterString>
							</gmd:supplementalInformation>
						</xsl:for-each>
					</gmd:MD_DataIdentification>
				</gmd:identificationInfo>
			</xsl:for-each> 			<!-- end context is metadata/idinfo -->

			<!-- content information section -->
			<!-- replaced contentInfo with choose -->
			<xsl:if test="count($var_metadataRoot/eainfo/detailed)>0">
				<gmd:contentInfo>
					<gmd:MD_FeatureCatalogueDescription>
						<gmd:includedWithDataset>
							<xsl:attribute name="gco:nilReason">
								<xsl:value-of select="'unknown'"/>
							</xsl:attribute>
							<!--<gco:Boolean>
								<xsl:value-of select="$var_metadataRoot/eainfo/detailed"/>
							</gco:Boolean>-->
						</gmd:includedWithDataset>
						<xsl:for-each select="$var_metadataRoot/eainfo/detailed">
							<gmd:featureTypes>
								<gco:LocalName>
									<xsl:attribute name="codeSpace">
										<xsl:choose>
											<xsl:when  test="enttyp/enttypds">
												<xsl:value-of select="normalize-space(string(enttyp/enttypds))"/>
											</xsl:when>
											<xsl:otherwise>
												<xsl:value-of select="string('http://www.opengis.net/def/nil/OGC/0/unknown/')"/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:attribute>
									<xsl:value-of
										select="normalize-space(string(enttyp/enttypl))"/>
								</gco:LocalName>
							</gmd:featureTypes>
						</xsl:for-each>
						
						
						<xsl:choose>
							<xsl:when test="count($var_metadataRoot/eainfo/overview)=0">
								<gmd:featureCatalogueCitation>
									<xsl:attribute name="gco:nilReason">
										<xsl:value-of select="string('missing')"/>
									</xsl:attribute>
								</gmd:featureCatalogueCitation>
							</xsl:when>
							<xsl:otherwise>
								<xsl:for-each select="$var_metadataRoot/eainfo/overview">
									<gmd:featureCatalogueCitation>
										<gmd:CI_Citation>
											<gmd:title>
												<gco:CharacterString>
													<xsl:choose>
														<xsl:when test="eadetcit">
															<xsl:value-of select="string(eadetcit)" />
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="string('Citation missing')"/>
														</xsl:otherwise>
													</xsl:choose>
												</gco:CharacterString>
											</gmd:title>
											<gmd:date>
												<xsl:attribute name="gco:nilReason">
													<xsl:value-of select="string('missing')"/>
												</xsl:attribute>
											</gmd:date>
											<xsl:if test="eaover">
												<gmd:otherCitationDetails>
													<gco:CharacterString>
														<xsl:value-of select="concat(string('Entity and Attribute Overview: '),string(eaover))"/>
													</gco:CharacterString>
												</gmd:otherCitationDetails>
											</xsl:if>
										</gmd:CI_Citation>
									</gmd:featureCatalogueCitation>
									
								</xsl:for-each>
								
							</xsl:otherwise>
						</xsl:choose>
						
					</gmd:MD_FeatureCatalogueDescription>
				</gmd:contentInfo>
			</xsl:if>
			<xsl:if test="count($var_metadataRoot/dataqual/cloud)>0">
				<xsl:variable name="var_lccloud">
					<xsl:call-template name="lcase">
						<xsl:with-param name="theString" select="$var_metadataRoot/dataqual/cloud"/>
					</xsl:call-template>
				</xsl:variable>
				<gmd:contentInfo>
					<gmd:MD_ImageDescription>
						<!-- attributeDescription and contentType are mandatory for valid MD_ImageDescription -->
						<gmd:attributeDescription gco:nilReason="missing"/>
						<gmd:contentType>
							<gmd:MD_CoverageContentTypeCode
								codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_CoverageContentTypeCode"
								codeListValue="image"/>
						</gmd:contentType>
						<gmd:cloudCoverPercentage>
							<xsl:choose>
								<xsl:when
									test="contains($var_lccloud, 'unknown')">
									<xsl:attribute name="gco:nilReason">
										<xsl:value-of select="string('unknown')"/>
									</xsl:attribute>
								</xsl:when>
								<xsl:when
									test="number($var_metadataRoot/dataqual/cloud[1])=number($var_metadataRoot/dataqual/cloud[1])">
									<gco:Real>
										<xsl:value-of
											select="string($var_metadataRoot/dataqual/cloud[1])"
										/>
									</gco:Real>
								</xsl:when>
								<xsl:otherwise>
									<xsl:attribute name="gco:nilReason">
										<xsl:value-of select="string('inapplicable')"/>
									</xsl:attribute>
								</xsl:otherwise>
							</xsl:choose>
						</gmd:cloudCoverPercentage>
					</gmd:MD_ImageDescription>
				</gmd:contentInfo>
			</xsl:if>

			<!-- ******************************************************************* -->
			<!-- each distribution (distinfo) has one distributor contact;  distinfo/digform in first distInfo get transferOptions links from MD_Distribution and distributorTransferOptions link (by href) from the distributor, and distributionFormat links from MD_Distribution as well as distributorFormatLinks from distributor.  Other distinfo elements are distributor/MD_Distributor elements with distributorTransferOptions and distributorFormat elements for each distinfo/digForm -->
			<xsl:choose>

				<xsl:when test="count($var_metadataRoot/distinfo)>0">
					<gmd:distributionInfo>
						<gmd:MD_Distribution>
							<!-- process distinfo[1] formats into distributionFormat -->
							<!-- process distributor 
					for-each distributor
						process formats (href for distinfo[1]) into distributorFormat
						process distributor
						process transferOptions (href for distinfo[1]) into distributorTransferOptions-->
							<!-- process distinfo[1] transfer options into MD_Distributon/transferOptions -->
							<!-- process citeinfo/onlink into DigitalTransferOptions with unknonwn distributor -->

							<!-- distribution format -->
							<xsl:for-each select="$var_metadataRoot/distinfo[1]//digform[1]">
								<gmd:distributionFormat>
									<xsl:call-template name="usgin:format">
										<xsl:with-param name="thedigform" select="."/>
										<xsl:with-param name="theFmtID" select="'firstIDformat'"/>
									</xsl:call-template>
								</gmd:distributionFormat>
							</xsl:for-each>
							<!-- handle each distributor, which will have its own distinfo element -->
							<xsl:for-each select="$var_metadataRoot/distinfo">
								<xsl:variable name="currentDistInfo" select="."/>
								<!-- each distinfo has one contact (distinfo/cntInfo) -->
								<!-- each csdgm distribution has a distribuotr, resource description, distribution liability,
							0..* standard order process, custom order process, techpreq, available time period.
							The formats and transferOptions for the first distributor are placed in distributionFormat and 
							transferOptions for USGIN, and repeated (by href) in the distributorFormat and 
							distributorTransferOptions-->
								<!-- distributor information -->
								<gmd:distributor>
									<gmd:MD_Distributor>
										<gmd:distributorContact>
											<!-- csdgm allows exactly one cntinfo per distrib -->
											<gmd:CI_ResponsibleParty>
												<xsl:call-template name="usgin:contactName">
												<xsl:with-param name="the-cntinfo"
												select="distrib/cntinfo"/>
												</xsl:call-template>
												<gmd:contactInfo>
												<xsl:call-template name="usgin:contactHandler">
												<xsl:with-param name="the-cntinfo"
												select="distrib/cntinfo"/>
												</xsl:call-template>
												</gmd:contactInfo>
												<gmd:role>
												<gmd:CI_RoleCode
												codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode"
												codeListValue="distributor" codeSpace="005">
												<xsl:value-of select="string('distributor')"/>
												</gmd:CI_RoleCode>
												</gmd:role>
											</gmd:CI_ResponsibleParty>
										</gmd:distributorContact>
										<!-- distribution ordering process information; context is distinfo -->
										<!-- avaialble  -->
										<xsl:variable name="var_availabl">
											<xsl:choose>
												<xsl:when test="count(availabl/timeinfo/sngdate)>0">
													<!-- csdgm allow general timeinfo: a sngdate, daterange or multi date ISO plannedAvailableDateTime is a single DateTime only.-->
														<xsl:call-template name="usgin:TimePositionFormat">
															<xsl:with-param name="inputDate" select="availabl/timeinfo/sngdate/caldate"/>
															<xsl:with-param name="inputTime" select="availabl/timeinfo/sngdate/time"/>														</xsl:call-template>
													
												</xsl:when>
												<xsl:when test="count(availabl/timeinfo/rngdates)>0">
													<!-- put in the begin date -->
													<xsl:call-template name="usgin:TimePositionFormat">
														<xsl:with-param name="inputDate"
															select="availabl/timeinfo/rngdates/begdate"/>
														<xsl:with-param name="inputTime"
															select="availabl/timeinfo/rngdates/begtime"/>
													</xsl:call-template>
												</xsl:when>
												<xsl:when test="count(availabl/timeinfo/mdattim)>0">
													<xsl:call-template name="usgin:TimePositionFormat">
														<xsl:with-param name="inputDate"
															select="availabl/timeinfo/mdattim/sngdate[1]/caldate"/>
														<xsl:with-param name="inputTime"
															select="availabl/timeinfo/mdattim/sngdate[1]/time"/>
													</xsl:call-template>
												</xsl:when>
												<xsl:otherwise>
														<xsl:value-of select="string('nilError')"/>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<xsl:for-each select="stdorder">
											<gmd:distributionOrderProcess>
												<gmd:MD_StandardOrderProcess>
													<xsl:if test="count(fees)>0">
														<gmd:fees>
															<gco:CharacterString>
																<xsl:value-of select="normalize-space(string(fees))"/>
															</gco:CharacterString>
														</gmd:fees>
													</xsl:if>
													<xsl:if test="string-length($var_availabl)>0 and not(contains($var_availabl,'nilError'))">
														<gmd:plannedAvailableDateTime>
														<xsl:choose>
															<xsl:when test="contains($var_availabl,'nil')">
																<xsl:attribute name="gco:nilReason">
																	<xsl:value-of select="substring-after($var_availabl,'nil')"/>
																</xsl:attribute>
															</xsl:when>
															<xsl:otherwise>
																<gco:DateTime>
																	<xsl:value-of select="$var_availabl"/>
																</gco:DateTime>
															</xsl:otherwise>
														</xsl:choose>
														</gmd:plannedAvailableDateTime>
													</xsl:if>
			<!--	Test to see if there are ordering instructions in the source metadata distribution section; 
								context is distinfo/stdorder-->
												<xsl:if
													test="count($currentDistInfo/custom)>0 or count(nondig)>0 or count(digform/ordering)>0 or count(digform/digtopt/onlinopt)>0">
												<gmd:orderingInstructions>
			<!-- csdgm allows accessinstructions for each distinct online option, which might all be inside one stdorder; also might have 
										ordering for the stdorder element, or custom instructions associated with the distributor. 
										put dial-uup information in the text as well.-->
												<gco:CharacterString>
													<xsl:if test="count($currentDistInfo/custom)>0">
												<xsl:variable name="var-cust-dist-name">
												<xsl:choose>
												<xsl:when
													test="count($currentDistInfo/cntinfo/cntperp/cntper)>0">
												<xsl:value-of
												select="concat(string($currentDistInfo/cntinfo/cntperp/cntper), ' custom')"
												/>
												</xsl:when>
												<xsl:when
													test="count($currentDistInfo/cntinfo/cntorgp/cntorg)>0">
												<xsl:value-of
												select="concat(string($currentDistInfo/cntinfo/cntorgp/cntorg),' custom')"
												/>
												</xsl:when>
												<xsl:otherwise>
												<xsl:value-of
												select="string('Custom distributor info')"/>
												</xsl:otherwise>
												</xsl:choose>
												</xsl:variable>
												<xsl:value-of
												select="concat($var-cust-dist-name,': ')"/>
												<xsl:value-of
												select="concat(normalize-space(string($currentDistInfo/custom)),'. ')"
												/>
												</xsl:if>
													<xsl:if test="count(nondig)>0">
												<xsl:value-of
												select="string('Non-Digital distribution: ')"/>
												<xsl:value-of
												select="concat(normalize-space(string(nondig)),'. ')"
												/>
												</xsl:if>
													<xsl:if test="count(digform/ordering)>0">
												<xsl:value-of
												select="concat('Ordering Instructions: ', normalize-space(string(digform/ordering)), '. ')"
												/>
												</xsl:if>

												<xsl:for-each
												select="digform/digtopt/onlinopt/computer">
												<xsl:if
													test="count(accinstr)>0 or count(dialinst/dialtel)>0">
												<xsl:variable name="instrLabel">
												<xsl:choose>
													<xsl:when test="count(networka)>0">
												<xsl:value-of
												select="normalize-space(string(computer/networka/networkr[1]))"
												/>
												</xsl:when>
													<xsl:when test="count(dialinst/dialtel)>0">
												<xsl:value-of
												select="normalize-space(string(computer/networka/dialtel[1]))"
												/>
												</xsl:when>
												<xsl:otherwise>
												<xsl:value-of select="'noName'"/>
												</xsl:otherwise>
												</xsl:choose>
												</xsl:variable>
												<xsl:value-of
												select="concat('Access instructions for ', $instrLabel,': ')"/>
												<xsl:value-of
												select="concat(normalize-space(string(accinstr)),'. ')"/>
													<xsl:if test="count(dialinst)>0">
														<xsl:if test="count(dialinst/lowbps)>0">
												<xsl:value-of
												select="concat('Lowest BPS:',string(dialinst/lowbps),'; ')"
												/>
												</xsl:if>
														<xsl:if test="count(dialinst/highbps)>0">
												<xsl:value-of
												select="concat('Highest BPS:',string(dialinst/highbps),'; ')"
												/>
												</xsl:if>
														<xsl:if test="count(dialinst/numdata)>0">
												<xsl:value-of
												select="concat('Number DataBits:',string(dialinst/numdata),'; ')"
												/>
												</xsl:if>
														<xsl:if test="count(dialinst/numstop)>0">
												<xsl:value-of
												select="concat('Number StopBits:',string(dialinst/numstop),'; ')"
												/>
												</xsl:if>
														<xsl:if test="count(dialinst/parity)>0">
												<xsl:value-of
												select="concat('Parity:',string(dialinst/parity),'; ')"
												/>
												</xsl:if>
														<xsl:if test="count(dialinst/compress)>0">
												<xsl:value-of
												select="concat('Compression Support:',string(dialinst/compress),'; ')"
												/>
												</xsl:if>
														<xsl:if test="count(dialinst/dialtel)>0">
												<xsl:for-each select="dialinst/dialtel">
												<xsl:value-of
												select="concat('Dialup Telephone:',string(.),'; ')"
												/>
												</xsl:for-each>
												</xsl:if>
														<xsl:if test="count(dialinst/dialfile)>0">
												<xsl:for-each select="dialinst/dialfile">
												<xsl:value-of
												select="concat('Dialup File Name:',string(.),'; ')"
												/>
												</xsl:for-each>
												</xsl:if>
												</xsl:if>
												<!-- put dial-up information in the text blob... -->
												</xsl:if>
													<xsl:if test="count(oncomp)>0">
												<xsl:value-of
												select="concat('Online Computer and Operating System: ', normalize-space(string(oncomp)), '. ')"
												/>
												</xsl:if>
												</xsl:for-each>

												</gco:CharacterString>
												</gmd:orderingInstructions>
												</xsl:if>
												<xsl:for-each select="turnarnd">
												<gmd:turnaround>
												<gco:CharacterString>
												<xsl:value-of
												select="normalize-space(string(.))"/>
												</gco:CharacterString>
												</gmd:turnaround>
												</xsl:for-each>
												</gmd:MD_StandardOrderProcess>
											</gmd:distributionOrderProcess>
										</xsl:for-each>
										<xsl:if test="count($var_metadataRoot/distinfo)>1">
											<!-- distributorFormat -->
											<xsl:for-each select="$currentDistInfo/stdorder/digform">
												<xsl:choose>
												<xsl:when
												test="$var_metadataRoot/distinfo[1]/stdorder/digform[1]/digtinfo/formname =digtinfo/formname">
												<gmd:distributorFormat>
												<xsl:attribute name="xlink:href">
												<xsl:value-of select="concat('#','firstIDformat')"
												/>
												</xsl:attribute>
												</gmd:distributorFormat>
												</xsl:when>
												<xsl:otherwise>
												<gmd:distributorFormat>
												<xsl:call-template name="usgin:format">
												<xsl:with-param name="thedigform" select="."/>
												</xsl:call-template>
												</gmd:distributorFormat>
												</xsl:otherwise>
												</xsl:choose>
											</xsl:for-each>

											<!-- distributorTransferOptions -->
											<xsl:for-each select="$currentDistInfo/stdorder/digform">
												<xsl:choose>
												<xsl:when
												test="$var_metadataRoot/distinfo[1]/stdorder/digform[1]/digtopt[1]/networkr[1] = digtopt/networkr[1]">
												<gmd:distributorTransferOptions>
												<xsl:attribute name="xlink:href">
												<xsl:value-of select="concat('#','firstOptionID')"
												/>
												</xsl:attribute>
												</gmd:distributorTransferOptions>
												</xsl:when>
												<xsl:otherwise>
												<gmd:distributorTransferOptions>
												<xsl:call-template name="usgin:digTransferOption">
												<xsl:with-param name="thedigform" select="."/>
												</xsl:call-template>
												</gmd:distributorTransferOptions>
												</xsl:otherwise>
												</xsl:choose>
											</xsl:for-each>
										</xsl:if>
									</gmd:MD_Distributor>
								</gmd:distributor>
							</xsl:for-each>

							<!-- transfer options for first distinfo//digform only; others are transformed as distributorTransferOptions -->
							<xsl:choose>
								<xsl:when
									test="count($var_metadataRoot/distinfo[1]/stdorder/digform[1])>0">
									<gmd:transferOptions>
										<!-- process for the first distinfo -->
										<xsl:call-template name="usgin:digTransferOption">
											<xsl:with-param name="thedigform"
												select="$var_metadataRoot/distinfo[1]/stdorder/digform[1]"/>
											<xsl:with-param name="theOptionID"
												select="'firstOptionID'"/>
										</xsl:call-template>
									</gmd:transferOptions>
								</xsl:when>
								<xsl:otherwise>
									<xsl:if test="count($var_metadataRoot/idinfo/citation/citeinfo/onlink[contains(.,'//')])=0">
									<gmd:transferOptions>
										<xsl:attribute name="gco:nilReason">
											<xsl:value-of select="string('missing')"/>
										</xsl:attribute>
									</gmd:transferOptions>
									</xsl:if>
								</xsl:otherwise>
							</xsl:choose>

							<!-- CHECK IF there are any resource links in the citation and add those. -->
							<xsl:if
								test="count($var_metadataRoot/idinfo/citation/citeinfo/onlink[contains(.,'//')])>0">
								<gmd:transferOptions>
									<gmd:MD_DigitalTransferOptions>
										<xsl:for-each
											select="$var_metadataRoot/idinfo/citation/citeinfo/onlink[contains(.,'//')]">
											<gmd:onLine>
												<gmd:CI_OnlineResource>
												<gmd:linkage>
												<gmd:URL>
												<xsl:value-of
												select="normalize-space(string(.))"
												/>
												</gmd:URL>
												</gmd:linkage>
												<gmd:protocol>
												<gco:CharacterString>http</gco:CharacterString>
												</gmd:protocol>
												<gmd:name>
												<gco:CharacterString>
												<xsl:value-of
												select="$var_metadataRoot/idinfo/citation/citeinfo/title"
												/>
												</gco:CharacterString>
												</gmd:name>
												<gmd:description>
												<gco:CharacterString>
												<xsl:value-of
												select="'Online linkage from csdgm citation; there is no contact information for the distributor'"
												/>
												</gco:CharacterString>
												</gmd:description>
												</gmd:CI_OnlineResource>
											</gmd:onLine>
										</xsl:for-each>
									</gmd:MD_DigitalTransferOptions>
								</gmd:transferOptions>
							</xsl:if>
						</gmd:MD_Distribution>
					</gmd:distributionInfo>
				</xsl:when>
				<xsl:otherwise>
					<gmd:distributionInfo>
						<xsl:attribute name="gco:nilReason">
							<xsl:value-of select="'missing'"/>
						</xsl:attribute>
					</gmd:distributionInfo>
				</xsl:otherwise>

			</xsl:choose>

			<!-- ************************************************************************** -->
			<!-- data quality section; csdgm allows one dataqual element -->
			<!-- csdgm may have {attribute accuracy or Postitional Accuracy} and lineage -->
			<xsl:for-each select="$var_metadataRoot/dataqual">
				<gmd:dataQualityInfo>
					<gmd:DQ_DataQuality>
						<!-- each ISO data quality is characterized by a different scope; 
		 	csdgm does not have concept of a quality scope, so there should only
			be one gmd:dataQualityInfo instance in the transformed metadata-->
						<gmd:scope>
							<gmd:DQ_Scope>
								<gmd:level>
									<gmd:MD_ScopeCode codeListValue="dataset"
										codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode"
									/>
								</gmd:level>
							</gmd:DQ_Scope>
						</gmd:scope>
						<!-- position accuracy reports -->
						<!--ISO does not distinguish horizontal vs. vertical position accuracy -->
						<xsl:for-each select="posacc/horizpa">
							<gmd:report>
								<gmd:DQ_AbsoluteExternalPositionalAccuracy>
									<gmd:nameOfMeasure>
										<gco:CharacterString>
											<xsl:value-of select="'Horizontal Positional Accuracy'"
											/>
										</gco:CharacterString>
									</gmd:nameOfMeasure>
									<gmd:measureDescription>
										<gco:CharacterString>
											<xsl:variable name="DQMeasureDesc">
												<xsl:value-of
												select="count(/metadata/dataqual/posacc/horizpa/qhorizpa)"
												/>
											</xsl:variable>
											<xsl:for-each
												select="/metadata/dataqual/posacc/horizpa/qhorizpa">
												<xsl:value-of
												select="normalize-space(string(horizpae))"/>
												<xsl:if test="($DQMeasureDesc>1)">
												<xsl:value-of select="string(' ')"/>
												</xsl:if>
											</xsl:for-each>
										</gco:CharacterString>
									</gmd:measureDescription>
									<gmd:evaluationMethodDescription>
										<gco:CharacterString>
											<xsl:value-of
												select="normalize-space(string(horizpar))"/>
										</gco:CharacterString>
									</gmd:evaluationMethodDescription>
									<gmd:result>
										<gmd:DQ_QuantitativeResult>
											<gmd:valueUnit gco:nilReason="missing"/>
											<gmd:value>
												<gco:Record>
												<xsl:variable name="DQvalueCount">
												<xsl:value-of
												select="count(/metadata/dataqual/posacc/horizpa/qhorizpa)"
												/>
												</xsl:variable>
												<xsl:for-each
												select="/metadata/dataqual/posacc/horizpa/qhorizpa">
												<xsl:value-of
												select="normalize-space(string(horizpav))"/>
												<xsl:if test="($DQvalueCount>1)">
												<xsl:value-of select="string(' ')"/>
												</xsl:if>
												</xsl:for-each>
												</gco:Record>
											</gmd:value>
										</gmd:DQ_QuantitativeResult>
									</gmd:result>
								</gmd:DQ_AbsoluteExternalPositionalAccuracy>
							</gmd:report>
						</xsl:for-each>
						<xsl:for-each select="posacc/vertacc">
							<gmd:report>
								<gmd:DQ_AbsoluteExternalPositionalAccuracy>
									<gmd:nameOfMeasure>
										<gco:CharacterString>
											<xsl:value-of select="'Vertical Positional Accuracy'"/>
										</gco:CharacterString>
									</gmd:nameOfMeasure>
									<gmd:measureDescription>
										<gco:CharacterString>
											<xsl:variable name="DQvertAccExplan">
												<xsl:value-of
												select="count(/metadata/dataqual/posacc/vertacc/qvertpa)"
												/>
											</xsl:variable>
											<xsl:for-each
												select="/metadata/dataqual/posacc/vertacc/qvertpa">
												<xsl:value-of
												select="normalize-space(string(vertacce))"/>
												<xsl:if test="($DQvertAccExplan>1)">
												<xsl:value-of select="string(' ')"/>
												</xsl:if>
											</xsl:for-each>
										</gco:CharacterString>
									</gmd:measureDescription>
									<gmd:evaluationMethodDescription>
										<gco:CharacterString>
											<xsl:value-of
												select="normalize-space(string(vertaccr))"/>
										</gco:CharacterString>
									</gmd:evaluationMethodDescription>
									<gmd:result>
										<gmd:DQ_QuantitativeResult>
											<gmd:valueUnit gco:nilReason="missing"/>
											<gmd:value>
												<gco:Record>
												<xsl:variable name="DQvertAccVal">
												<xsl:value-of
												select="count(/metadata/dataqual/posacc/vertacc/qvertpa)"
												/>
												</xsl:variable>
												<xsl:for-each
												select="/metadata/dataqual/posacc/vertacc/qvertpa">
												<xsl:value-of
												select="normalize-space(string(vertaccv))"/>
												<xsl:if test="($DQvertAccVal>1)">
												<xsl:value-of select="string(' ')"/>
												</xsl:if>
												</xsl:for-each>
												</gco:Record>
											</gmd:value>
										</gmd:DQ_QuantitativeResult>
									</gmd:result>
								</gmd:DQ_AbsoluteExternalPositionalAccuracy>
							</gmd:report>
						</xsl:for-each>
						<!-- completeness report -->
						<xsl:if test="count(complete)>0">
							<gmd:report>
								<gmd:DQ_CompletenessOmission>
									<gmd:nameOfMeasure>
										<gco:CharacterString>
											<xsl:value-of select="'CSDGM Completeness report: '"/>
										</gco:CharacterString>
									</gmd:nameOfMeasure>
									<gmd:evaluationMethodDescription>
										<gco:CharacterString>
											<xsl:value-of
												select="normalize-space(string(complete))"/>
										</gco:CharacterString>
									</gmd:evaluationMethodDescription>
									<gmd:result>
										<xsl:attribute name="gco:nilReason">
											<xsl:value-of select="'missing'"/>
										</xsl:attribute>
									</gmd:result>
								</gmd:DQ_CompletenessOmission>
							</gmd:report>
						</xsl:if>
						<!-- conceptual consistency report -->
						<xsl:if test="count(logic)>0">
							<gmd:report>
								<gmd:DQ_ConceptualConsistency>
									<gmd:nameOfMeasure>
										<gco:CharacterString>
											<xsl:value-of
												select="'CSDGM Logical Consistency Report: '"/>
										</gco:CharacterString>
									</gmd:nameOfMeasure>
									<gmd:measureDescription>
										<gco:CharacterString>
											<xsl:value-of
												select="normalize-space(string(logic))"/>
										</gco:CharacterString>
									</gmd:measureDescription>
									<gmd:result>
										<xsl:attribute name="gco:nilReason">
											<xsl:value-of select="string('missing')"/>
										</xsl:attribute>
									</gmd:result>
								</gmd:DQ_ConceptualConsistency>
							</gmd:report>
						</xsl:if>
						<!-- attribute accuracy information -->
						<xsl:for-each select="attracc">
							<xsl:variable name="var_attributeAccuracyNode" select="."/>
							<gmd:report>
								<gmd:DQ_QuantitativeAttributeAccuracy>
									<gmd:nameOfMeasure>
										<gco:CharacterString>
											<xsl:value-of
												select="'Quantitative Attribute Accuracy Assessment'"
											/>
										</gco:CharacterString>
									</gmd:nameOfMeasure>
									<gmd:measureDescription>
										<gco:CharacterString>
											<xsl:variable name="var_count_qattracc1">
												<xsl:value-of select="count(qattracc)"/>
											</xsl:variable>
											<xsl:for-each select="qattracc">
												<xsl:value-of
												select="normalize-space(string(attracce))"/>
												<xsl:if test="$var_count_qattracc1 &gt; 1">
												<xsl:value-of select="';  '"/>
												</xsl:if>
											</xsl:for-each>
										</gco:CharacterString>
									</gmd:measureDescription>
									<xsl:if test="count(attraccr)>0">
										<gmd:evaluationMethodDescription>
											<gco:CharacterString>
												<xsl:value-of
												select="normalize-space(string(attraccr))"/>
											</gco:CharacterString>
										</gmd:evaluationMethodDescription>
									</xsl:if>
									<gmd:result>
										<gmd:DQ_QuantitativeResult>
											<gmd:valueUnit gco:nilReason="inapplicable"/>
											<gmd:value>
												<gco:Record>
												<xsl:variable name="var_count_qattracc2">
												<xsl:value-of select="count(qattracc)"/>
												</xsl:variable>
												<xsl:for-each select="qattracc">
												<xsl:value-of
												select="normalize-space(string(attraccv))"/>
												<xsl:if test="$var_count_qattracc2 &gt; 1">
												<xsl:value-of select="';  '"/>
												</xsl:if>
												</xsl:for-each>
												</gco:Record>
											</gmd:value>
										</gmd:DQ_QuantitativeResult>
									</gmd:result>
								</gmd:DQ_QuantitativeAttributeAccuracy>
							</gmd:report>
						</xsl:for-each>
						<!-- lineage information -->
						<!-- csdgm xml puts a list of sources first, with an abbreviation for each one 
				that serves	to link process step input and output sources with the citations. -->
						<xsl:if test="count(lineage)>0">
							<gmd:lineage>
								<gmd:LI_Lineage>
									<gmd:statement>
										<gco:CharacterString>missing</gco:CharacterString>
									</gmd:statement>
									<xsl:for-each select="lineage/procstep">
										<xsl:variable name="var_lineageProcessingStepNode" select="."/>
										<gmd:processStep>
											<gmd:LI_ProcessStep>
												<gmd:description>
													<gco:CharacterString>
														<xsl:value-of select="string(procdesc)"/>
													</gco:CharacterString>
												</gmd:description>
												<!-- process step date and time -->
												<gmd:dateTime>
													<xsl:variable name="var_formatProcdate">
														<xsl:call-template name="usgin:TimePositionFormat">
															<xsl:with-param name="inputDate" select="procdate"/>
															<xsl:with-param name="inputTime" select="proctime"/>
														</xsl:call-template>
													</xsl:variable>
													<xsl:choose>
														
														<xsl:when test="starts-with($var_formatProcdate,'nil')">
															<xsl:attribute name="gco:nilReason">
																<xsl:value-of select="'unknown'"/>
															</xsl:attribute>
														</xsl:when>
														<xsl:otherwise>
															<gco:DateTime>
																<xsl:value-of select="string($var_formatProcdate)"/>
															</gco:DateTime>
														</xsl:otherwise>
													</xsl:choose>
												</gmd:dateTime>
												<xsl:for-each select="proccont">
													<gmd:processor>
														<gmd:CI_ResponsibleParty>
															<xsl:call-template name="usgin:contactName">
																<xsl:with-param name="the-cntinfo" select="cntinfo"/>
															</xsl:call-template>
															<gmd:contactInfo>
																<xsl:call-template name="usgin:contactHandler">
																	<xsl:with-param name="the-cntinfo" select="cntinfo"/>
																</xsl:call-template>
															</gmd:contactInfo>
															<gmd:role>
																<gmd:CI_RoleCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode" codeListValue="processor" codeSpace="009">
																	<xsl:value-of select="string('processor')"/>
																</gmd:CI_RoleCode>
															</gmd:role>
														</gmd:CI_ResponsibleParty>
													</gmd:processor>
												</xsl:for-each>
												<!-- get sources -->
												<xsl:for-each select="srcprod">
													<gmd:source>
														<xsl:attribute name="xlink:href">
															<xsl:value-of select="concat('#',normalize-space(srcprod))"/>
														</xsl:attribute>
													</gmd:source>
												</xsl:for-each>
											</gmd:LI_ProcessStep>
										</gmd:processStep>
									</xsl:for-each>
									<!-- csdgm process steps reference a sourceCitations from a citation section -->
									<xsl:for-each select="lineage/srcinfo">
										<xsl:variable name="var_lineageSourceInfoNode" select="."/>
										<gmd:source>
											<gmd:LI_Source>
												<xsl:if test="count(srccitea)>0">
													<xsl:attribute name="id">
														<xsl:value-of select="string(srccitea)"/>
													</xsl:attribute>
												</xsl:if>
												<xsl:if
													test="count(strcontr)>0 or count(typesrc)>0">
													<gmd:description>
														<gco:CharacterString>
															<xsl:if test="count(strcontr)>0">
																<xsl:value-of
																	select="concat('Source Contribution: ', string(srccontr), ' ')"
																/>
															</xsl:if>
															<xsl:if test="count(typesrc)>0">
																<xsl:value-of
																	select="concat('Type of Source Media: ',  string(typesrc))"
																/>
															</xsl:if>
														</gco:CharacterString>
													</gmd:description>
												</xsl:if>
												<xsl:variable name="var_lcsrcscale">
													<xsl:if test="count(srcscale)>0">
													<xsl:call-template name="lcase">
														<xsl:with-param name="theString" select="srcscale"/>
													</xsl:call-template>
						</xsl:if>
												</xsl:variable>
												<xsl:if
													test="count(srcscale)>0 and (($var_lcsrcscale = 'unknown') or number(srcscale)=number(srcscale))">
													<gmd:scaleDenominator>
														<gmd:MD_RepresentativeFraction>
															<gmd:denominator>
																<xsl:choose>
																	<xsl:when
																		test="($var_lcsrcscale = 'unknown')">
																		<xsl:attribute name="gco:nilReason">
																			<xsl:value-of select="string('unknown')"/>
																		</xsl:attribute>
																	</xsl:when>
																	<xsl:when test="number(srcscale)=number(srcscale)">
																		<gco:Integer>
																			<xsl:value-of
																				select="string(number(srcscale))"/>
																		</gco:Integer>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:attribute name="gco:nilReason">
																			<!-- use inapplicable to indicate the srcscale value is not interpretable -->
																			<xsl:value-of select="string('inapplicable')"/>
																		</xsl:attribute>
																	</xsl:otherwise>
																</xsl:choose>
															</gmd:denominator>
														</gmd:MD_RepresentativeFraction>
													</gmd:scaleDenominator>
												</xsl:if>
												<xsl:for-each select="srccite/citeinfo">
												<gmd:sourceCitation>
													<xsl:call-template name="usgin:citinfoHandler">
														<xsl:with-param name="theciteinfo">
															<xsl:value-of select="."/>
														</xsl:with-param>
													</xsl:call-template>
												</gmd:sourceCitation>
												</xsl:for-each>
						<xsl:if test="count(srctime/timeinfo)>0">
													<gmd:sourceExtent>
														<gmd:EX_Extent>
															<!-- temporal extent, single date -->
															<xsl:for-each select="srctime/timeinfo/sngdate">
																<xsl:variable name="var_extentSingleDate1" select="."/>
																<xsl:variable name="var_lccaldate">
																	<xsl:call-template name="lcase">
																		<xsl:with-param name="theString" select="caldate"/>
																	</xsl:call-template>
																</xsl:variable>
																<gmd:temporalElement>
																	<gmd:EX_TemporalExtent>
																		<xsl:attribute name="id">
																			<xsl:value-of
																				select="concat('TempEx.', generate-id())"/>
																		</xsl:attribute>
																		<gmd:extent>												
																			<xsl:choose>
																				<xsl:when
																					test="contains($var_lccaldate, 'unknown') or contains($var_lccaldate, 'unpublished')">
																					<xsl:attribute name="gco:nilReason">
																						<xsl:value-of select="$var_lccaldate"/>
																					</xsl:attribute>
																				</xsl:when>
																				<xsl:otherwise>
																					<gml:TimeInstant>
																						<xsl:attribute name="gml:id">
																							<xsl:value-of select="concat('TInst.',generate-id())"/>
																						</xsl:attribute>
																						<xsl:variable name="var_TimePos5">
																							<xsl:call-template name="usgin:TimePositionFormat">
																								<xsl:with-param name="inputDate" select="caldate"/>
																								<xsl:with-param name="inputTime" select="time"/>
																							</xsl:call-template>
																						</xsl:variable>
																						<gml:timePosition>
																							<xsl:variable name="castableAsDateTime5">
																								<xsl:value-of
																									select="(substring($var_TimePos5,5,1)='-') and (substring($var_TimePos5,8,1)='-') and (substring($var_TimePos5,11,1)='T') and (substring($var_TimePos5,14,1)=':') and (substring($var_TimePos5,17,1)=':')"/>
																							</xsl:variable>
																							<xsl:choose>
																								<xsl:when test="string($castableAsDateTime5)='true'">
																									<xsl:value-of select="$var_TimePos5"/>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:attribute name="indeterminatePosition">
																										<xsl:value-of select="string('unknown')"/>
																									</xsl:attribute>
																								</xsl:otherwise>
																							</xsl:choose>
																						</gml:timePosition>
																					</gml:TimeInstant>
																				</xsl:otherwise>
																			</xsl:choose>
																		</gmd:extent>
																	</gmd:EX_TemporalExtent>
																</gmd:temporalElement>
															</xsl:for-each>
															<!-- temporal extent, multiple individual dates and times. 
																guess the idea is there might be multple mdattim/sngdate elements?-->
															<xsl:for-each select="srctime/timeinfo/mdattim/sngdate">
																<!-- iterate over sngdate elements in mdattim -->
																<!--	<xsl:variable name="var_mdattmdate" select="."/>-->
																<xsl:variable name="var_lccaldate">
																	<xsl:call-template name="lcase">
																		<xsl:with-param name="theString" select="caldate"/>
																	</xsl:call-template>
																</xsl:variable>
																<gmd:temporalElement>
																	<gmd:EX_TemporalExtent>
																		<xsl:attribute name="id">
																			<xsl:value-of
																				select="concat('TimePerEx.', generate-id())"
																			/>
																		</xsl:attribute>
																		<gmd:extent>
																			<xsl:choose>
																				<xsl:when
																					test="contains($var_lccaldate, 'unknown') or contains($var_lccaldate, 'unpublished')">
																					<xsl:attribute name="gco:nilReason">
																						<xsl:value-of select="$var_lccaldate"/>
																					</xsl:attribute>
																				</xsl:when>
																				<xsl:otherwise>
																					<gml:TimeInstant>
																						<xsl:attribute name="gml:id">
																							<xsl:value-of select="concat('TInst.',generate-id())"/>
																						</xsl:attribute>
																						<!-- now process the dates -->
																						<!--						<xsl:variable name="var_DateTemp"> -->
																						<xsl:variable name="var_TimePos6">
																							<xsl:call-template name="usgin:TimePositionFormat">
																								<xsl:with-param name="inputDate" select="caldate"/>
																								<xsl:with-param name="inputTime" select="time"/>
																							</xsl:call-template>
																						</xsl:variable>
																						<gml:timePosition>
																							<xsl:variable name="castableAsDateTime6">
																								<xsl:value-of
																									select="(substring($var_TimePos6,5,1)='-') and (substring($var_TimePos6,8,1)='-') and (substring($var_TimePos6,11,1)='T') and (substring($var_TimePos6,14,1)=':') and (substring($var_TimePos6,17,1)=':')"
																								/>
																							</xsl:variable>
																							<xsl:choose>
																								<xsl:when test="string($castableAsDateTime6)='true'">
																									<xsl:value-of select="$var_TimePos6"/>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:attribute name="indeterminatePosition">
																										<xsl:value-of select="string('unknown')"/>
																									</xsl:attribute>
																								</xsl:otherwise>
																							</xsl:choose>
																						</gml:timePosition>
																						
																					</gml:TimeInstant>
																				</xsl:otherwise>
																			</xsl:choose>
																		</gmd:extent>
																	</gmd:EX_TemporalExtent>
																</gmd:temporalElement>
															</xsl:for-each>
															<!-- temporal extent, range of dates and time -->
															<!-- each rngdates has a rngdates/begdate begtime, and /enddate /endtime -->
															<xsl:for-each select="srctime/timeinfo/rngdates">
																<xsl:variable name="var_rngdatesNode" select="."/>
																<xsl:variable name="var_lcbegdate">
																	<xsl:call-template name="lcase">
																		<xsl:with-param name="theString" select="begdate"/>
																	</xsl:call-template>
																</xsl:variable>
																<xsl:variable name="var_lcenddate">
																	<xsl:call-template name="lcase">
																		<xsl:with-param name="theString" select="enddate"/>
																	</xsl:call-template>
																</xsl:variable>
																<gmd:temporalElement>
																	<gmd:EX_TemporalExtent>
																		<xsl:attribute name="id">
																			<xsl:value-of select="concat('DateRngEx.', generate-id())"/>
																		</xsl:attribute>
																		<gmd:extent>
																			<gml:TimePeriod>
																				<xsl:attribute name="gml:id">
																					<xsl:value-of select="concat('bndTimePeriod.',generate-id())"/>
																				</xsl:attribute>
																				<gml:beginPosition>
																					<!-- content is ISO8610 (xs:date) string -->
																					<xsl:choose>
																						<xsl:when
																							test="contains($var_lcbegdate, 'present') or contains($var_lcbegdate, 'now')">
																							<xsl:attribute name="indeterminatePosition">
																								<xsl:value-of select="string('now')"/>
																							</xsl:attribute>
																						</xsl:when>
																						
																						<xsl:otherwise>
																							<xsl:variable name="var_TimePos7">
																								<xsl:call-template name="usgin:TimePositionFormat">
																									<xsl:with-param name="inputDate" select="begdate"/>
																									<xsl:with-param name="inputTime" select="begtime"
																									/>
																								</xsl:call-template>
																							</xsl:variable>
																							<xsl:variable name="castableAsDateTime7">
																								<xsl:value-of
																									select="(substring($var_TimePos7,5,1)='-') and (substring($var_TimePos7,8,1)='-') and (substring($var_TimePos7,11,1)='T') and (substring($var_TimePos7,14,1)=':') and (substring($var_TimePos7,17,1)=':')"
																								/>
																							</xsl:variable>
																							<xsl:choose>
																								<xsl:when
																									test="string($castableAsDateTime7)='true'">
																									<xsl:value-of select="$var_TimePos7"/>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:attribute name="indeterminatePosition">
																										<xsl:value-of select="string('unknown')"/>
																									</xsl:attribute>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:otherwise>
																					</xsl:choose>
																				</gml:beginPosition>
																				<gml:endPosition>
																					<!-- content is ISO8601 (xs:date) string -->
																					<xsl:choose>
																						<xsl:when
																							test="contains($var_lcenddate, 'present') or contains($var_lcenddate, 'now')">
																							<xsl:attribute name="indeterminatePosition">
																								<xsl:value-of select="string('now')"/>
																							</xsl:attribute>
																						</xsl:when>
																						
																						<xsl:otherwise>
																							<xsl:variable name="var_TimePos8">
																								<xsl:call-template name="usgin:TimePositionFormat">
																									<xsl:with-param name="inputDate" select="enddate"/>
																									<xsl:with-param name="inputTime" select="endtime"
																									/>
																								</xsl:call-template>
																							</xsl:variable>
																							<xsl:variable name="castableAsDateTime8">
																								<xsl:value-of
																									select="(substring($var_TimePos8,5,1)='-') and (substring($var_TimePos8,8,1)='-') and (substring($var_TimePos8,11,1)='T') and (substring($var_TimePos8,14,1)=':') and (substring($var_TimePos8,17,1)=':')"
																								/>
																							</xsl:variable>
																							<xsl:choose>
																								<xsl:when
																									test="string($castableAsDateTime8)='true'">
																									<xsl:value-of select="$var_TimePos8"/>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:attribute name="indeterminatePosition">
																										<xsl:value-of select="string('unknown')"/>
																									</xsl:attribute>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:otherwise>
																					</xsl:choose>												</gml:endPosition>
																			</gml:TimePeriod>
																		</gmd:extent>
																	</gmd:EX_TemporalExtent>
																</gmd:temporalElement>
															</xsl:for-each>
														</gmd:EX_Extent>
													</gmd:sourceExtent>
												</xsl:if>
											</gmd:LI_Source>
										</gmd:source>
									</xsl:for-each>
								</gmd:LI_Lineage>
							</gmd:lineage>
						</xsl:if>
					</gmd:DQ_DataQuality>
				</gmd:dataQualityInfo>
			</xsl:for-each>

			<!-- metadata constraints -->
			<xsl:if
				test="count($var_metadataRoot/metainfo/metac)>0 or count($var_metadataRoot/metainfo/metuc)>0">
				<gmd:metadataConstraints>
					<gmd:MD_LegalConstraints>
						<xsl:if test="count($var_metadataRoot/metainfo/metac)>0">
							<gmd:accessConstraints>
								<gmd:MD_RestrictionCode>
									<xsl:attribute name="codeList">
										<xsl:value-of
											select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode')"
										/>
									</xsl:attribute>
									<xsl:attribute name="codeListValue">
										<xsl:value-of select="string('otherRestrictions')"/>
									</xsl:attribute>
									<xsl:attribute name="codeSpace">
										<xsl:value-of select="string('008')"/>
									</xsl:attribute>
								</gmd:MD_RestrictionCode>
							</gmd:accessConstraints>
						</xsl:if>
						<xsl:if test="count($var_metadataRoot/metainfo/metuc)>0">
							<gmd:useConstraints>
								<gmd:MD_RestrictionCode>
									<xsl:attribute name="codeList">
										<xsl:value-of
											select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode')"
										/>
									</xsl:attribute>
									<xsl:attribute name="codeListValue">
										<xsl:value-of
											select="string('otherRestrictions')"/>
									</xsl:attribute>
									<xsl:attribute name="codeSpace">
										<xsl:value-of select="string('008')"/>
									</xsl:attribute>
								</gmd:MD_RestrictionCode>
							</gmd:useConstraints>
						</xsl:if>
						<xsl:for-each select="$var_metadataRoot/metainfo/metuc">
							<gmd:otherConstraints>
								<gco:CharacterString>
									<xsl:value-of select="'Metadata Use Constraint: '"/>
									<xsl:value-of select="string(.)"/>
								</gco:CharacterString>
							</gmd:otherConstraints>
						</xsl:for-each>
						<xsl:for-each select="$var_metadataRoot/metainfo/metac">
							<gmd:otherConstraints>
								<gco:CharacterString>
									<xsl:value-of select="'Metadata Access Constraint: '"/>
									<xsl:value-of select="string(.)"/>
								</gco:CharacterString>
							</gmd:otherConstraints>
						</xsl:for-each>
					</gmd:MD_LegalConstraints>
				</gmd:metadataConstraints>
			</xsl:if>
			<!-- security constraints -->
			<xsl:for-each select="$var_metadataRoot/metainfo/metsi">
				<xsl:variable name="var_lookupSecurityClassType">
					<xsl:call-template name="vmf:securityClassType">
						<xsl:with-param name="input"
							select="metsc"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:variable name="var_securityClassCode">
					<xsl:call-template name="vmf:securityClassCode">
						<xsl:with-param name="input"
							select="metsc"/>
					</xsl:call-template>
				</xsl:variable>
				<gmd:metadataConstraints>
					<gmd:MD_SecurityConstraints>
						<xsl:choose>
							<xsl:when
								test="string-length($var_lookupSecurityClassType)>0 and string-length(string($var_lookupSecurityClassType))>0">
								<gmd:classification>
									<gmd:MD_ClassificationCode>
										<xsl:attribute name="codeListValue">
											<xsl:value-of
												select="string($var_lookupSecurityClassType)"/>
										</xsl:attribute>
										<xsl:choose>
											<xsl:when test="$var_lookupSecurityClassType='unknown'">
												<xsl:attribute name="codeList">
												<xsl:value-of
												select="string('http://www.opengis.net/def/nil/OGC/0/unknown/')"
												/>
												</xsl:attribute>
											</xsl:when>
											<xsl:otherwise>
												<xsl:attribute name="codeList">
												<xsl:value-of
												select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ClassificationCode')"
												/>
												</xsl:attribute>
											</xsl:otherwise>
										</xsl:choose>
										<xsl:if test="$var_securityClassCode != 'unknown'">
											<xsl:attribute name="codeSpace">
												<xsl:value-of
												select="string($var_securityClassCode)"/>
											</xsl:attribute>
										</xsl:if>
										<xsl:value-of select="metsc"/>
									</gmd:MD_ClassificationCode>
								</gmd:classification>
							</xsl:when>
							<xsl:otherwise>
								<gmd:classification gco:nilReason="missing"/>
							</xsl:otherwise>
						</xsl:choose>
						<xsl:if test="count(metscs)>0 and string-length(string(metscs))>0">
							<gmd:classificationSystem>
								<gco:CharacterString>
									<xsl:value-of select="string(metscs)"/>
								</gco:CharacterString>
							</gmd:classificationSystem>
						</xsl:if>
						<xsl:if test="string-length(string(metshd))>0">
							<gmd:handlingDescription>
								<gco:CharacterString>
									<xsl:value-of select="string(metshd)"/>
								</gco:CharacterString>
							</gmd:handlingDescription>
						</xsl:if>
					</gmd:MD_SecurityConstraints>
				</gmd:metadataConstraints>
			</xsl:for-each>
			<!-- metadata maintenance -->
			<gmd:metadataMaintenance>
				<gmd:MD_MaintenanceInformation>
					<gmd:maintenanceAndUpdateFrequency>
						<xsl:attribute name="gco:nilReason">
							<xsl:value-of select="string('unknown')"/>
						</xsl:attribute>
					</gmd:maintenanceAndUpdateFrequency>
					<xsl:for-each select="$var_metadataRoot/metainfo/metrd">
						<!-- CSDGM has metrd: 'Metadata Review Date free date; Metadata Review Date later than Metadata Date' and 
							metfrd: 'Metadata Future Review Date free date; Metadata Future Review Date later than Metadata Review Date'
							interpretation here is that metrd is next update data. Put metfrd in maintenance note.
							Unfortunately these are 'free dates'  not even timeinfo elements, so interpreting what we get is wide open!-->
						<xsl:variable name="var_MDreviewDate">
							<xsl:call-template name="lcase">
								<xsl:with-param name="theString" select="."/>
							</xsl:call-template>
						</xsl:variable>
						<gmd:dateOfNextUpdate>
							<xsl:variable name="var_procMDreviewDate">

								<xsl:call-template name="usgin:TimePositionFormat">
									<xsl:with-param name="inputDate" select="(metainfo/metrd)"/>
									<xsl:with-param name="inputTime"/>
								</xsl:call-template>
							</xsl:variable>
							<xsl:choose>
								<xsl:when
									test="starts-with(string($var_procMDreviewDate),'nil')">
									<xsl:attribute name="gco:nilReason">
										<xsl:value-of
											select="substring-after(string($var_procMDreviewDate),'nil')"
										/>
									</xsl:attribute>
								</xsl:when>
								<xsl:otherwise>
									<gco:Date>
										<xsl:value-of select="string($var_procMDreviewDate)"/>
									</gco:Date>
								</xsl:otherwise>
							</xsl:choose>
						</gmd:dateOfNextUpdate>
					</xsl:for-each>
					<gmd:maintenanceNote>
							<!-- metadata review date; if present will be concatenated with the maintenance note -->
								<xsl:variable name="var_metFRevDateRept">
								<xsl:choose>
									<xsl:when test="count(metainfo/metfrd)>0">
										<xsl:variable name="var_DateTemp">
											<xsl:call-template name="usgin:TimePositionFormat">
												<xsl:with-param name="inputDate"
												select="(metainfo/metfrd)"/>
												<xsl:with-param name="inputTime"/>
											</xsl:call-template>
										</xsl:variable>
										<xsl:value-of
											select="concat(string(' Future metadata content review date: '), string($var_DateTemp))"
										/>
									</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="''"/>
									</xsl:otherwise>
								</xsl:choose>
							</xsl:variable>
							<gco:CharacterString>
								<xsl:value-of
									select="normalize-space(concat('This metadata was automatically generated from a metadata record encoded using the ', string(metainfo/metstdn), ' standard, version ', string(metainfo/metstdv), '. Conversion was executed by the 2014-11-30 version of csdgm-to-iso19115.xslt transform (SMR steve.richard at azgs dot az dot gov) to generate USGIN compatible ISO19139 XML, using xslt 1.0 for use by GeoPortal. ', $var_metFRevDateRept))"
								/>
							</gco:CharacterString>
					</gmd:maintenanceNote>
					<gmd:maintenanceNote>
						<gco:CharacterString>
					<xsl:value-of select="string('Output is compatible with output of iso-19115-to-usgin-19115-data transform. This statement is required for USGIN geoportal interrogation to recognized as a verified USGIN metadata profile record')"/>
						</gco:CharacterString>
					</gmd:maintenanceNote>
					<gmd:contact>
						<gmd:CI_ResponsibleParty>
							<gmd:positionName>
								<gco:CharacterString>USGIN/NGDS metadata
									editor</gco:CharacterString>
							</gmd:positionName>
							<gmd:contactInfo>
								<gmd:CI_Contact>
									<gmd:address>
										<gmd:CI_Address>
											<gmd:electronicMailAddress>
												<gco:CharacterString>metadata@usgin.org</gco:CharacterString>
											</gmd:electronicMailAddress>
										</gmd:CI_Address>
									</gmd:address>
								</gmd:CI_Contact>
							</gmd:contactInfo>
							<gmd:role>
								<gmd:CI_RoleCode
									codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode"
									codeListValue="processor" codeSpace="007"
									>processor</gmd:CI_RoleCode>
							</gmd:role>
						</gmd:CI_ResponsibleParty>
					</gmd:contact>
				</gmd:MD_MaintenanceInformation>
			</gmd:metadataMaintenance>
		</gmd:MD_Metadata>
	</xsl:template>
	<!-- Map projection display handlers, this stuff gets put in the abstract -->
	<!-- Map Projections -->
	<xsl:template match="albers | equicon | lambertc">
		<xsl:apply-templates select="stdparll"/>
		<xsl:apply-templates select="longcm"/>
		<xsl:apply-templates select="latprjo"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="gnomonic | lamberta | orthogr | stereo | gvnsp">
		<xsl:for-each select="../gvnsp">
			<xsl:apply-templates select="heightpt"/>
		</xsl:for-each>
		<xsl:apply-templates select="longpc"/>
		<xsl:apply-templates select="latprjc"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="azimequi | polycon | transmer">
		<xsl:for-each select="../transmer">
			<xsl:apply-templates select="sfctrmer"/>
		</xsl:for-each>
		<xsl:apply-templates select="longcm"/>
		<xsl:apply-templates select="latprjo"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="miller | sinusoid | vdgrin">
		<xsl:for-each select="../equirect">
			<xsl:apply-templates select="stdparll"/>
		</xsl:for-each>
		<xsl:for-each select="../mercator">
			<xsl:apply-templates select="stdparll"/>
			<xsl:apply-templates select="sfequat"/>
		</xsl:for-each>
		<xsl:apply-templates select="longcm"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="equirect">
		<xsl:apply-templates select="stdparll"/>
		<xsl:apply-templates select="longcm"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="mercator">
		<xsl:apply-templates select="stdparll"/>
		<xsl:apply-templates select="sfequat"/>
		<xsl:apply-templates select="longcm"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="polarst">
		<xsl:apply-templates select="svlong"/>
		<xsl:apply-templates select="stdparll"/>
		<xsl:apply-templates select="sfprjorg"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="obqmerc">
		<xsl:apply-templates select="sfctrlin"/>
		<xsl:apply-templates select="obqlazim"/>
		<xsl:apply-templates select="obqlpt"/>
		<xsl:apply-templates select="latprjo"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="spaceobq">
		<xsl:apply-templates select="landsat"/>
		<xsl:apply-templates select="pathnum"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="robinson">
		<xsl:apply-templates select="longpc"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="modsak">
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<!-- Map Projection Parameters -->
	<xsl:template match="stdparll"> Standard_Parallel: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="longcm"> Longitude_of_Central_Meridian: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="latprjo"> Latitude_of_Projection_Origin: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="feast"> False_Easting: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="fnorth"> False_Northing: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="sfequat"> Scale_Factor_at_Equator: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="heightpt"> Height_of_Perspective_Point_Above_Surface: <xsl:value-of
			select="."/>
	</xsl:template>
	<xsl:template match="longpc"> Longitude_of_Projection_Center: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="latprjc"> Latitude_of_Projection_Center: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="sfctrlin"> Scale_Factor_at_Center_Line: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="obqlazim"> Oblique_Line_Azimuth: <xsl:value-of select="."/>
		<xsl:for-each select="azimangl"> Azimuthal_Angle: <xsl:value-of select="."/>
		</xsl:for-each>
		<xsl:for-each select="azimptl"> Azimuthal_Measure_Point_Longitude: <xsl:value-of select="."
			/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template match="obqlpt"> Oblique_Line_Point: <xsl:value-of select="."/>
		<xsl:for-each select="obqllat"> Oblique_Line_Latitude: <xsl:value-of select="."/>
		</xsl:for-each>
		<xsl:for-each select="obqllong"> Oblique_Line_Longitude: <xsl:value-of select="."/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template match="svlong"> Straight_Vertical_Longitude_from_Pole: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="sfprjorg"> Scale_Factor_at_Projection_Origin: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="landsat"> Landsat_Number: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="pathnum"> Path_Number: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="sfctrmer"> Scale_Factor_at_Central_Meridian: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="otherprj"> Other_Projection's_Definition: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="attr">
		<!-- template to handle attributes of attributes, don't allow recursion --> Attribute Label:
			<xsl:value-of select="attrlabl"/> Definition: <xsl:value-of select="attrdef"/> Source:
			<xsl:value-of select="attrdefs"/> Attribute of Attribute Domain: <xsl:for-each
			select="attrdomv"> Attribute_Domain_Values: <xsl:for-each select="edom">
				Enumerated_Domain: <xsl:for-each select="edomv"> Value: <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="edomvd"> Value_Definition: <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="edomvds"> Value_Definition_Source: <xsl:value-of select="."/>
				</xsl:for-each>
			</xsl:for-each>
			<!-- end enumerated domain -->
			<xsl:for-each select="rdom"> Range_Domain: <xsl:for-each select="rdommin">
					Range_Minimum: <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="rdommax"> Range_Maximum: <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="attrunit"> Units_of_Measure: <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="attrmres"> Attribute_Measurement_Resolution: <xsl:value-of
						select="."/>
				</xsl:for-each>
			</xsl:for-each>
			<xsl:for-each select="codesetd"> Codeset Domain: <xsl:for-each select="codesetn">
					Codeset Name: <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="codesets"> Codeset Source: <xsl:value-of select="."/>
				</xsl:for-each>
			</xsl:for-each>
			<xsl:for-each select="udom"> Unrepresentable Domain: <xsl:value-of select="."/>
			</xsl:for-each>
		</xsl:for-each>
	</xsl:template>
</xsl:stylesheet>
