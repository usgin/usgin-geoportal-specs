<?xml version="1.0" encoding="UTF-8"?>
<!--
======================================================================
	 FGDC CSDGM to ISO 19115 Transform version 2.0 using XPath 2.0
	USGIN v1.0

	 This is the XML Style sheet that transforms metadata conforming to the Content Standards for Digital Geospatial Metadata of the Federal Geographic Data Committee 
	 June 1998 FGDC-STD-001-1998 version to the ISO 19115:2003(E).  This stylesheet can be applied to FGDC CSDGM XML to generate ISO 19115 XML.

	 Original XSLT was generated by Altova MapForce 2009sp1. 

	 Authors:
	     Original XSLT is the product of a collaboration of the Metadata Transform Working Group. For further information, please contact NOAA's National Coastal Data 
	     Development Center (NCDDC).
			Toll Free: 866.732.2382
			E-mail: ncddcmetadata@noaa.gov

	 Distribution liability on original XSLT:
		 NOAA makes no warranty regarding these data, expressed or implied, nor does the fact of distribution constitute such a warranty. NOAA, NESDIS, 
		 NODC and NCDDC cannot assume liability for any damages caused by any errors or omissions in these data, nor as a result of the failure of these data 
		 to function on a particular system. These files were developed for opensource uses.

	Original auto-generated XSLT extensively modified by Stephen Richard and Leahanna Musil, USGIN to make the operation more intelligible and maintainable, 
		adopt for USGIN ISO metadata conventions. Spatial reference and entity-attribute information is put into the abstract as free text.

 Revisions:sta
	     20091028 (JLM) Namespaces were corrected to avoid duplicates.
							 xmlns:n="http://www.isotc211.org/2005/gfc" was changed
							 to xmlns:gfc="http://www.isotc211.org/2005/gfc" and
							 xmlns:n="http://www.opengis.net/gml/3.2" was changed to
							 xmlns:gml="http://www.opengis.net/gml/3.2". All used "n:" 
							 namespaces were changed to "gml:". 
		 20091120 (JLM) CodeLists were edited to remove extra quotes and other.
							 undesired characters. CodeLists were checked to ensure 
							 inclusion of domian codes. Edits were also made to remove 
							 un-used elements. FGDC CSDGM elements horizpa/horizpar and 
							 vertacc/vertaccr were changed from being mapped to gml:id to 
							 gml:CoventionalUnit. Single Date Time Period of contect was
							 added to mapping. Multiple Dates will replace if single date 
							 is empty. Duplicates of axisDimensionsProperties is not
							 allowed to repeat. To solve this, MD_GridSpatialRepresentation
							 was repeated. Cell Geometry Code information was also added.
SMR 2012-01-27 comment out gmd:extendedElementInformation
SMR 2012-01-28 edit xslt to make it more intelligible and maintainable. Give variables more 
							reasonable names, remove spurious type casting, add comments						 
-->
<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:gco="http://www.isotc211.org/2005/gco" xmlns:gfc="http://www.isotc211.org/2005/gfc" xmlns:gmd="http://www.isotc211.org/2005/gmd" xmlns:gmx="http://www.isotc211.org/2005/gmx" xmlns:gsr="http://www.isotc211.org/2005/gsr" xmlns:gss="http://www.isotc211.org/2005/gss" xmlns:gts="http://www.isotc211.org/2005/gts" xmlns:gml="http://www.opengis.net/gml" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:vmf="http://www.altova.com/MapForce/UDF/vmf" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:grp="http://www.altova.com/Mapforce/grouping" xmlns:usgin="http://resources.usgin.org/xslt/FGDC2ISO" exclude-result-prefixes="fn grp vmf xs xsi xsl" xmlns="http://www.opengis.net/gml">
	<!-- ********************** templates by SMR   **************************** -->
	<xsl:template name="usgin:dateFormat">
		<xsl:param name="inputDate" select="()"/>
		<xsl:param name="inputTime" select="()"/>
		<!-- var_DateString will contain either 'nilAAAAA' where AAAA is a nilReason, a valid xs:dateTime, or it will contain a valid Date in format YYYY-MM-DD -->
		<xsl:variable name="var_DateString">
			<xsl:choose>
				<xsl:when test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string($inputDate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string($inputDate))), 'unpublished'))">
					<!-- xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string(fn:normalize-space(fn:string(.)))"/></xsl:attribute -->
					<xsl:value-of select="fn:concat('nil',fn:string($inputDate))"/>
				</xsl:when>
				<xsl:when test="fn:contains(fn:lower-case(fn:normalize-space(fn:string($inputDate))), 'present')">
					<!--gco:DateTime -->
					<xsl:value-of select="fn:string(current-dateTime())"/>
					<!-- /gco:DateTime -->
				</xsl:when>
				<xsl:when test="(fn:normalize-space(fn:string($inputDate)) castable as xs:dateTime)">
					<!-- gco:DateTime -->
					<xsl:value-of select="fn:string($inputDate)"/>
					<!-- /gco:DateTime -->
				</xsl:when>
				<!-- convert YYYYMMDD format to YYYY-MM-DD format -->
				<xsl:otherwise>
					<xsl:variable name="var_dateString_result" as="xs:string?">
						<xsl:choose>
							<xsl:when test="string-length(fn:normalize-space(fn:string($inputDate)))=8">
								<xsl:value-of select="fn:concat(fn:substring(fn:normalize-space(fn:string($inputDate)), 0, 5), '-', fn:substring(fn:normalize-space(fn:string($inputDate)), 5, 2), '-',fn:substring(fn:normalize-space(fn:string($inputDate)), 7, 2))"/>
							</xsl:when>
							<xsl:when test="string-length(fn:normalize-space(fn:string($inputDate)))=6">
								<xsl:value-of select="fn:concat(fn:substring(fn:normalize-space(fn:string($inputDate)), 0, 5), '-', fn:substring(fn:normalize-space(fn:string($inputDate)), 5, 2), '-01')"/>
							</xsl:when>
							<xsl:when test="string-length(fn:normalize-space(fn:string($inputDate)))=4">
								<xsl:value-of select="fn:concat(fn:substring(fn:normalize-space(fn:string($inputDate)), 0, 5), '-01-01')"/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:value-of select="fn:string('nilmissing')"/>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					<xsl:choose>
						<xsl:when test="($var_dateString_result castable as xs:date)">
							<!-- gco:DateTime -->
							<xsl:value-of select="$var_dateString_result"/>
							<!-- /gco:DateTime -->
						</xsl:when>
						<xsl:otherwise>
							<!-- date format is screwy, put in default value -->
							<xsl:value-of select="fn:string('nilmissing')"/>
							<!-- xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string('InvalidValue')"/></xsl:attribute>
							<gco:DateTime>1900-01-01T12:00:00Z</gco:DateTime -->
						</xsl:otherwise>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<!-- done with date, either is nilAAAAA, 0000, a valid xs:dateTime, or a valid xs:date -->
		<!-- now need to process input time  -->
		<xsl:variable name="var_timeString">
			<!-- xsl:if test="fn:exists($inputTime)" -->
			<xsl:choose>
				<xsl:when test="(fn:upper-case(fn:string(.))='UNKNOWN')">
					<xsl:value-of select="xs:string('12:00:00')"/>
				</xsl:when>
				<xsl:when test="string-length($inputTime)=6">
					<xsl:sequence select="fn:concat(fn:substring(fn:string($inputTime), 0, 3), ':', fn:substring(fn:string($inputTime),3,2), ':', fn:substring(fn:string($inputTime), 5, 2))"/>
				</xsl:when>
				<xsl:when test="string-length($inputTime)=4">
					<xsl:sequence select="fn:concat(fn:substring(fn:string($inputTime), 0, 3), ':', fn:substring(fn:string($inputTime),3,2), ':00')"/>
				</xsl:when>
				<xsl:when test="string-length($inputTime)=2">
					<xsl:sequence select="fn:concat(fn:substring(fn:string($inputTime), 0, 3), ':00:00')"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="xs:string('12:00:00')"/>
				</xsl:otherwise>
			</xsl:choose>
			<!-- /xsl:for-each-->
		</xsl:variable>
		<!-- now merge date string with time string (if it exists) -->
		<xsl:choose>
			<xsl:when test="starts-with(xs:string($var_DateString),'nil')">
				<xsl:attribute name="gco:nilReason"><xsl:value-of select="substring-after($var_DateString,'nil')"/></xsl:attribute>
				<gco:DateTime>1900-01-01T12:00:00</gco:DateTime>
			</xsl:when>
			<xsl:when test="(fn:normalize-space(fn:string($var_DateString)) castable as xs:dateTime)">
				<gco:DateTime>
					<xsl:value-of select="fn:string($var_DateString)"/>
				</gco:DateTime>
			</xsl:when>
			<xsl:when test="fn:exists($var_DateString) and (fn:string-length($var_DateString)=10) and (fn:string-length($var_timeString)=8)">
				<gco:DateTime>
					<xsl:value-of select="fn:concat(fn:string($var_DateString),'T',fn:string($var_timeString))"/>
				</gco:DateTime>
			</xsl:when>
			<xsl:when test="fn:exists($var_DateString) and (fn:string-length($var_DateString)=10)  and not(fn:string-length($var_timeString)=8)">
				<gco:DateTime>
					<xsl:value-of select="fn:concat(fn:string($var_DateString),'T12:00:00')"/>
				</gco:DateTime>
			</xsl:when>
			<xsl:otherwise>
				<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string('missing')"/></xsl:attribute>
				<gco:DateTime>1900-01-01T12:00:00</gco:DateTime>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="usgin:TimePositionFormat">
		<xsl:param name="inputDate"/>
		<xsl:param name="inputTime"/>
		<!-- var_DateString will contain either 'nilAAAAA' where AAAA is a nilReason, a valid xs:dateTime, or it will contain a valid Date in format YYYY-MM-DD -->
		<xsl:variable name="var_DateString">
			<xsl:choose>
				<xsl:when test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string($inputDate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string($inputDate))), 'unpublished'))">
					<!-- xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string(fn:normalize-space(fn:string(.)))"/></xsl:attribute -->
					<xsl:value-of select="fn:concat('nil',fn:string($inputDate))"/>
				</xsl:when>
				<xsl:when test="fn:contains(fn:lower-case(fn:normalize-space(fn:string($inputDate))), 'present')">
					<!--gco:DateTime -->
					<xsl:value-of select="fn:string(current-dateTime())"/>
					<!-- /gco:DateTime -->
				</xsl:when>
				<xsl:when test="(fn:normalize-space(fn:string($inputDate)) castable as xs:dateTime)">
					<!-- gco:DateTime -->
					<xsl:value-of select="fn:string($inputDate)"/>
					<!-- /gco:DateTime -->
				</xsl:when>
				<!-- convert YYYYMMDD format to YYYY-MM-DD format -->
				<xsl:otherwise>
					<xsl:variable name="var_dateString_result" as="xs:string?">
						<xsl:choose>
							<xsl:when test="string-length(fn:normalize-space(fn:string($inputDate)))=8">
								<xsl:value-of select="fn:concat(fn:substring(fn:normalize-space(fn:string($inputDate)), 0, 5), '-', fn:substring(fn:normalize-space(fn:string($inputDate)), 5, 2), '-',fn:substring(fn:normalize-space(fn:string($inputDate)), 7, 2))"/>
							</xsl:when>
							<xsl:when test="string-length(fn:normalize-space(fn:string($inputDate)))=6">
								<xsl:value-of select="fn:concat(fn:substring(fn:normalize-space(fn:string($inputDate)), 0, 5), '-', fn:substring(fn:normalize-space(fn:string($inputDate)), 5, 2), '-01')"/>
							</xsl:when>
							<xsl:when test="string-length(fn:normalize-space(fn:string($inputDate)))=4">
								<xsl:value-of select="fn:concat(fn:substring(fn:normalize-space(fn:string($inputDate)), 0, 5), '-01-01')"/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:value-of select="fn:string('nilmissing')"/>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					<xsl:choose>
						<xsl:when test="($var_dateString_result castable as xs:date)">
							<!-- gco:DateTime -->
							<xsl:value-of select="$var_dateString_result"/>
							<!-- /gco:DateTime -->
						</xsl:when>
						<xsl:otherwise>
							<!-- date format is screwy, put in default value -->
							<xsl:value-of select="fn:string('nilmissing')"/>
							<!-- xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string('InvalidValue')"/></xsl:attribute>
							<gco:DateTime>1900-01-01T12:00:00Z</gco:DateTime -->
						</xsl:otherwise>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<!-- done with date, either is nilAAAAA, 0000, a valid xs:dateTime, or a valid xs:date -->
		<!-- now need to process input time  -->
		<xsl:variable name="var_timeString">
			<!-- xsl:if test="fn:exists($inputTime)" -->
			<xsl:choose>
				<xsl:when test="(fn:upper-case(fn:string(.))='UNKNOWN')">
					<xsl:value-of select="xs:string('12:00:00')"/>
				</xsl:when>
				<xsl:when test="string-length($inputTime)=6">
					<xsl:sequence select="fn:concat(fn:substring(fn:string($inputTime), 0, 3), ':', fn:substring(fn:string($inputTime),3,2), ':', fn:substring(fn:string($inputTime), 5, 2))"/>
				</xsl:when>
				<xsl:when test="string-length($inputTime)=4">
					<xsl:sequence select="fn:concat(fn:substring(fn:string($inputTime), 0, 3), ':', fn:substring(fn:string($inputTime),3,2), ':00')"/>
				</xsl:when>
				<xsl:when test="string-length($inputTime)=2">
					<xsl:sequence select="fn:concat(fn:substring(fn:string($inputTime), 0, 3), ':00:00')"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="xs:string('12:00:00')"/>
				</xsl:otherwise>
			</xsl:choose>
			<!-- /xsl:for-each-->
		</xsl:variable>
		<!-- now merge date string with time string (if it exists) -->
		<xsl:choose>
			<xsl:when test="starts-with(xs:string($var_DateString),'nil')">
				<xsl:value-of select="fn:string('indeterminate')"/>
			</xsl:when>
			<xsl:when test="(fn:normalize-space(fn:string($var_DateString)) castable as xs:dateTime)">
				<xsl:value-of select="fn:string($var_DateString)"/>
			</xsl:when>
			<xsl:when test="fn:exists($var_DateString) and (fn:string-length($var_DateString)=10) and (fn:string-length($var_timeString)=8)">
				<xsl:value-of select="fn:concat(fn:string($var_DateString),'T',fn:string($var_timeString))"/>
			</xsl:when>
			<xsl:when test="fn:exists($var_DateString) and (fn:string-length($var_DateString)=10)  and not(fn:string-length($var_timeString)=8)">
				<xsl:value-of select="fn:concat(fn:string($var_DateString),'T12:00:00')"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="fn:string('indeterminate')"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="usgin:contactName">
		<xsl:param name="inputPersonNode" select="()"/>
		<xsl:param name="inputOrganizationNode" select="()"/>
		<xsl:param name="inputPositionNode" select="()"/>
		<!-- handler for individual, organization, position name -->
		<!-- done scraping content for contact name -->
		<!-- now populate the elements count(individualName + OrganisationName + positionName) must be >0 -->
		<!-- check that at least one got populated -->
		<xsl:choose>
			<xsl:when test="fn:exists($inputPersonNode) or fn:exists($inputOrganizationNode) or fn:exists($inputPositionNode)">
				<xsl:if test="fn:exists($inputPersonNode)">
					<gmd:individualName>
						<gco:CharacterString>
							<xsl:for-each select="$inputPersonNode">
								<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
								<xsl:if test="(count($inputPersonNode)>1)">
									<xsl:value-of select="xs:string(' ')"/>
								</xsl:if>
							</xsl:for-each>
						</gco:CharacterString>
					</gmd:individualName>
				</xsl:if>
				<xsl:if test="fn:exists($inputOrganizationNode)">
					<gmd:organisationName>
						<gco:CharacterString>
							<xsl:for-each select="$inputOrganizationNode">
								<xsl:sequence select="fn:concat(fn:normalize-space(xs:string(.)), ' ')"/>
								<!-- xsl:if test="(count($inputOrganizationNode)>1)">
									<xsl:value-of select="xs:string(' ')"/>
								</xsl:if -->
							</xsl:for-each>
						</gco:CharacterString>
					</gmd:organisationName>
				</xsl:if>
				<xsl:if test="fn:exists($inputPositionNode)">
					<xsl:for-each select="$inputPositionNode">
						<gmd:positionName>
							<gco:CharacterString>
								<xsl:for-each select="$inputPositionNode">
									<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
									<xsl:if test="(count($inputPositionNode)>1)">
										<xsl:value-of select="xs:string(' ')"/>
									</xsl:if>
								</xsl:for-each>
							</gco:CharacterString>
						</gmd:positionName>
					</xsl:for-each>
				</xsl:if>
			</xsl:when>
			<!-- if at least one is present check -->
			<!-- no contact name -->
			<xsl:otherwise>
				<gmd:organisationName>
					<gco:CharacterString>metadata contact name, organisation and position are missing</gco:CharacterString>
				</gmd:organisationName>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<!-- *************************************************** -->
	<xsl:template name="usgin:addressFormat">
		<xsl:param name="inputAddr" select="()"/>
		<!-- don't put in postal address elements unless at least one has a value -->
		<xsl:if test="fn:exists($inputAddr/address) or fn:exists($inputAddr/city) or fn:exists($inputAddr/state) or fn:exists($inputAddr/postal) or fn:exists($inputAddr/country)">
			<xsl:for-each select="$inputAddr/address">
				<gmd:deliveryPoint>
					<gco:CharacterString>
						<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
					</gco:CharacterString>
				</gmd:deliveryPoint>
			</xsl:for-each>
			<xsl:for-each select="$inputAddr/city">
				<gmd:city>
					<gco:CharacterString>
						<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
					</gco:CharacterString>
				</gmd:city>
			</xsl:for-each>
			<xsl:for-each select="$inputAddr/state">
				<gmd:administrativeArea>
					<gco:CharacterString>
						<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
					</gco:CharacterString>
				</gmd:administrativeArea>
			</xsl:for-each>
			<xsl:for-each select="$inputAddr/postal">
				<gmd:postalCode>
					<gco:CharacterString>
						<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
					</gco:CharacterString>
				</gmd:postalCode>
			</xsl:for-each>
			<xsl:for-each select="$inputAddr/country">
				<gmd:country>
					<gco:CharacterString>
						<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
					</gco:CharacterString>
				</gmd:country>
			</xsl:for-each>
		</xsl:if>
	</xsl:template>
	<!-- ********************************************************** -->
	<xsl:template name="usgin:telephoneFormat">
		<xsl:param name="telNode" select="()"/>
		<xsl:variable name="var_voicePhone_exists" as="xs:string*">
			<xsl:if test="fn:exists($telNode/cntvoice)">
				<xsl:for-each select="$telNode/cntvoice">
					<xsl:sequence select="xs:string(.)"/>
				</xsl:for-each>
			</xsl:if>
		</xsl:variable>
		<xsl:variable name="var_faxPhone_exists" as="xs:string*">
			<xsl:if test="fn:exists($telNode/cntfax)">
				<xsl:for-each select="$telNode/cntfax">
					<xsl:sequence select="xs:string(.)"/>
				</xsl:for-each>
			</xsl:if>
		</xsl:variable>
		<!-- done checking  for phone number existance in the source record -->
		<!-- do the phone number(s) -->
		<xsl:if test="fn:exists($var_voicePhone_exists) or fn:exists($var_faxPhone_exists)">
			<gmd:phone>
				<gmd:CI_Telephone>
					<xsl:if test="fn:exists($var_voicePhone_exists)">
						<gmd:voice>
							<gco:CharacterString>
								<xsl:for-each select="$var_voicePhone_exists">
									<xsl:sequence select="fn:concat(fn:normalize-space(.),' ')"/>
								</xsl:for-each>
							</gco:CharacterString>
						</gmd:voice>
					</xsl:if>
					<xsl:if test="fn:exists($var_faxPhone_exists)">
						<gmd:facsimile>
							<gco:CharacterString>
								<xsl:for-each select="$var_faxPhone_exists">
									<xsl:sequence select="fn:concat(fn:normalize-space(.),' ')"/>
								</xsl:for-each>
							</gco:CharacterString>
						</gmd:facsimile>
					</xsl:if>
				</gmd:CI_Telephone>
			</gmd:phone>
		</xsl:if>
	</xsl:template>
	<!-- ********************************************************** -->
	<xsl:template name="usgin:emailFormat">
		<xsl:param name="emailNode" select="()"/>
		<xsl:variable name="var_eMail_exists" as="xs:string*">
			<xsl:if test="fn:exists($emailNode/cntemail)">
				<xsl:for-each select="$emailNode/cntemail">
					<xsl:sequence select="xs:string(.)"/>
				</xsl:for-each>
			</xsl:if>
		</xsl:variable>
		<!-- Set this up so that some value gets inserted -->
		<gmd:electronicMailAddress>
			<xsl:choose>
				<xsl:when test="fn:exists($var_eMail_exists)">
					<gco:CharacterString>
						<xsl:for-each select="$var_eMail_exists">
							<xsl:sequence select="fn:concat(fn:normalize-space(.),' ')"/>
						</xsl:for-each>
						<!-- xsl:sequence select="fn:normalize-space($var_eMail_exists)"/-->
					</gco:CharacterString>
				</xsl:when>
				<xsl:otherwise>
					<gco:CharacterString>eMail@missing.org</gco:CharacterString>
				</xsl:otherwise>
			</xsl:choose>
		</gmd:electronicMailAddress>
	</xsl:template>
	<!--  section 1, functions to translate generic codelist terms into ISO codeListValue and codelist code -->
	<xsl:template name="vmf:geometryType">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='PIXEL'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='GRID CELL'">
				<xsl:value-of select="'area'"/>
			</xsl:when>
			<xsl:when test="$input='VOXEL'">
				<xsl:value-of select="'area'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:geometryCode">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='PIXEL'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='GRID CELL'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='VOXEL'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:geometryType2">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='ENTITY POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='LABEL POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='AREA POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='NODE, PLANAR GRAPH'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$input='NODE, NETWORK'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$input='STRING'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='LINK'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='COMPLETE CHAIN'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='AREA CHAIN'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='NETWORK CHAIN, PLANAR GRAPH'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$input='NETWORK CHAIN, NONPLANAR GRAPH'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='CIRCULAR ARC, THREE POINT CENTER'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='ELLIPTICAL ARC'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='UNIFORM B-SPLINE'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='PIECEWISE BEZIER'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='RING WITH MIXED COMPOSITION'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF STRINGS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF CHAINS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF ARCS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='G-POLYGON'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input='GT-POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input='GT-POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:geometryCode2">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='ENTITY POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='LABEL POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='AREA POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='NODE, PLANAR GRAPH'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='NODE, NETWORK'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='STRING'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='LINK'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='COMPLETE CHAIN'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='AREA CHAIN'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='NETWORK CHAIN, PLANAR GRAPH'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='NETWORK CHAIN, NONPLANAR GRAPH'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='CIRCULAR ARC, THREE POINT CENTER'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='ELLIPTICAL ARC'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='UNIFORM B-SPLINE'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='PIECEWISE BEZIER'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='RING WITH MIXED COMPOSITION'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF STRINGS'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF CHAINS'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF ARCS'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='G-POLYGON'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='GT-POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='GT-POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:unknown">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='UNKNOWN'">
				<xsl:value-of select="'unknown'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:docType">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='ATLAS'">
				<xsl:value-of select="'mapHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='AUDIO'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$input='DIAGRAM'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$input='DOCUMENT'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$input='GLOBE'">
				<xsl:value-of select="'documentHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='MAP'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$input='PRINTED MAP'">
				<xsl:value-of select="'mapHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='MODEL'">
				<xsl:value-of select="'modelDigital'"/>
			</xsl:when>
			<xsl:when test="$input='PHYSICAL MODELl'">
				<xsl:value-of select="'modelHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='MULTIMEDIA PRESENTATION'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$input='PROFILE'">
				<xsl:value-of select="'profileDigital'"/>
			</xsl:when>
			<xsl:when test="$input='CROSS-SECTION'">
				<xsl:value-of select="'profileHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='RASTER DIGITAL DATA'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$input='REMOTE-SENSING IMAGE'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$input='SECTION'">
				<xsl:value-of select="'profileHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='SPREADSHEET'">
				<xsl:value-of select="'tableDigital'"/>
			</xsl:when>
			<xsl:when test="$input='TABULAR DIGITAL DATA'">
				<xsl:value-of select="'tableDigital'"/>
			</xsl:when>
			<xsl:when test="$input='VECTOR DIGITAL DATA'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$input='VIDEO'">
				<xsl:value-of select="'videoDigital'"/>
			</xsl:when>
			<xsl:when test="$input='VIEW'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$input='DATABASE'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:docCode">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='ATLAS'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='AUDIO'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='DIAGRAM'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='DOCUMENT'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='GLOBE'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='MAP'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='PRINTED MAP'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='MODEL'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='PHYSICAL MODELl'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input='MULTIMEDIA PRESENTATION'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='PROFILE'">
				<xsl:value-of select="'009'"/>
			</xsl:when>
			<xsl:when test="$input='CROSS-SECTION'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input='RASTER DIGITAL DATA'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='REMOTE-SENSING IMAGE'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='SECTION'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input='SPREADSHEET'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='TABULAR DIGITAL DATA'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='VECTOR DIGITAL DATA'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='VIDEO'">
				<xsl:value-of select="'013'"/>
			</xsl:when>
			<xsl:when test="$input='VIEW'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='DATABASE'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:statusType">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='COMPLETED'">
				<xsl:value-of select="'completed'"/>
			</xsl:when>
			<xsl:when test="$input='COMPLETE'">
				<xsl:value-of select="'completed'"/>
			</xsl:when>
			<xsl:when test="$input='ARCHIVED'">
				<xsl:value-of select="'historicalArchive'"/>
			</xsl:when>
			<xsl:when test="$input='OBSOLETE'">
				<xsl:value-of select="'obsolete'"/>
			</xsl:when>
			<xsl:when test="$input='ON GOING'">
				<xsl:value-of select="'onGoing'"/>
			</xsl:when>
			<xsl:when test="$input='CONTINUALLY'">
				<xsl:value-of select="'onGoing'"/>
			</xsl:when>
			<xsl:when test="$input='PLANNED'">
				<xsl:value-of select="'planned'"/>
			</xsl:when>
			<xsl:when test="$input='REQUIRED'">
				<xsl:value-of select="'required'"/>
			</xsl:when>
			<xsl:when test="$input='IN PROGRESS'">
				<xsl:value-of select="'underDevelopment'"/>
			</xsl:when>
			<xsl:when test="$input='IN WORK'">
				<xsl:value-of select="'underDevelopment'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:statusCode">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='COMPLETED'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='COMPLETE'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='ARCHIVED'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='OBSOLETE'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='ON GOING'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='CONTINUALLY'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='PLANNED'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='REQUIRED'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='IN PROGRESS'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='IN WORK'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:updateFrequency">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CONTINUALLY'">
				<xsl:value-of select="'continual'"/>
			</xsl:when>
			<xsl:when test="$input='DAILY'">
				<xsl:value-of select="'daily'"/>
			</xsl:when>
			<xsl:when test="$input='WEEKLY'">
				<xsl:value-of select="'weekly'"/>
			</xsl:when>
			<xsl:when test="$input='TWO WEEKS'">
				<xsl:value-of select="'fortnightly'"/>
			</xsl:when>
			<xsl:when test="$input='MONTHLY'">
				<xsl:value-of select="'monthly'"/>
			</xsl:when>
			<xsl:when test="$input='QUARTERLY'">
				<xsl:value-of select="'quarterly'"/>
			</xsl:when>
			<xsl:when test="$input='BIANNUALLY'">
				<xsl:value-of select="'biannually'"/>
			</xsl:when>
			<xsl:when test="$input='ANNUALLY'">
				<xsl:value-of select="'annually'"/>
			</xsl:when>
			<xsl:when test="$input='YEARLY'">
				<xsl:value-of select="'annually'"/>
			</xsl:when>
			<xsl:when test="$input='AS NEEDED'">
				<xsl:value-of select="'asNeeded'"/>
			</xsl:when>
			<xsl:when test="$input='IRREGULAR'">
				<xsl:value-of select="'irregular'"/>
			</xsl:when>
			<xsl:when test="$input='NOT PLANNED'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:when test="$input='NONE PLANNED'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:when test="$input='UNKNOWN'">
				<xsl:value-of select="'unknown'"/>
			</xsl:when>
			<xsl:when test="$input='NONE'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:updateFrequencyCode">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CONTINUALLY'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='DAILY'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='WEEKLY'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='TWO WEEKS'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='MONTHLY'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='QUARTERLY'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='BIANNUALLY'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='ANNUALLY'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input='YEARLY'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input='AS NEEDED'">
				<xsl:value-of select="'009'"/>
			</xsl:when>
			<xsl:when test="$input='IRREGULAR'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input='NOT PLANNED'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='NONE PLANNED'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='UNKNOWN'">
				<xsl:value-of select="'012'"/>
			</xsl:when>
			<xsl:when test="$input='NONE'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'012'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:securityClassType">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CONFIDENTIAL'">
				<xsl:value-of select="'confidential'"/>
			</xsl:when>
			<xsl:when test="$input='SECRET'">
				<xsl:value-of select="'secret'"/>
			</xsl:when>
			<xsl:when test="$input='TOP SECRET'">
				<xsl:value-of select="'topSecret'"/>
			</xsl:when>
			<xsl:when test="$input='UNCLASSIFIED'">
				<xsl:value-of select="'unclassified'"/>
			</xsl:when>
			<xsl:when test="$input='RESTRICTED'">
				<xsl:value-of select="'restricted'"/>
			</xsl:when>
			<xsl:when test="$input='SECERT'">
				<xsl:value-of select="'secret'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:securityClassCode">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CONFIDENTIAL'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='SECRET'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='TOP SECRET'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='UNCLASSIFIED'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='RESTRICTED'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='SECERT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:spatialRepresentationType">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'vector'"/>
			</xsl:when>
			<xsl:when test="$input='VECTOR'">
				<xsl:value-of select="'vector'"/>
			</xsl:when>
			<xsl:when test="$input='RASTER'">
				<xsl:value-of select="'grid'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:spatialRepresentationCode">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='vector'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='grid'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:mediumType">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CD-ROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:when test="$input='DVD'">
				<xsl:value-of select="'dvd'"/>
			</xsl:when>
			<xsl:when test="$input='DVD-ROM'">
				<xsl:value-of select="'dvdRom'"/>
			</xsl:when>
			<xsl:when test="$input='3-1/2 INCH FLOPPY DISK'">
				<xsl:value-of select="'3halfInchFloppy'"/>
			</xsl:when>
			<xsl:when test="$input='5-1/4 INCH FLOPPY'">
				<xsl:value-of select="'5quarterInchFloppy'"/>
			</xsl:when>
			<xsl:when test="$input='7-TRACK TAPE'">
				<xsl:value-of select="'7trackTape'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK TAPE'">
				<xsl:value-of select="'9trackType'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK'">
				<xsl:value-of select="'9trackTape'"/>
			</xsl:when>
			<xsl:when test="$input='3480 CARTRIDGE'">
				<xsl:value-of select="'3480Cartridge'"/>
			</xsl:when>
			<xsl:when test="$input='3490 CARTRIDGE'">
				<xsl:value-of select="'3490Cartridge'"/>
			</xsl:when>
			<xsl:when test="$input='3580 CARTRIDGE'">
				<xsl:value-of select="'3580Cartridge'"/>
			</xsl:when>
			<xsl:when test="$input='4 MM CARTRIDGE'">
				<xsl:value-of select="'4mmCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$input='8 MM CARTRIDGE'">
				<xsl:value-of select="'8mmCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$input='1/4 INCH CARTRIDGE'">
				<xsl:value-of select="'1quarterInchCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$input='DIGITAL LINEAR TAPE'">
				<xsl:value-of select="'digitalLinearTape'"/>
			</xsl:when>
			<xsl:when test="$input='ONLINE'">
				<xsl:value-of select="'onLine'"/>
			</xsl:when>
			<xsl:when test="$input='SATELLITE'">
				<xsl:value-of select="'satellite'"/>
			</xsl:when>
			<xsl:when test="$input='TELEPHONE LINK'">
				<xsl:value-of select="'telephoneLink'"/>
			</xsl:when>
			<xsl:when test="$input='HARDCOPY'">
				<xsl:value-of select="'hardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='CD ROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:when test="$input='CDROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:mediumCode">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CD-ROM'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='DVD'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='DVD-ROM'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='3-1/2 INCH FLOPPY DISK'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='5-1/4 INCH FLOPPY'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='7-TRACK TAPE'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK TAPE'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='3480 CARTRIDGE'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input='3490 CARTRIDGE'">
				<xsl:value-of select="'009'"/>
			</xsl:when>
			<xsl:when test="$input='3580 CARTRIDGE'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input='4 MM CARTRIDGE'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='8 MM CARTRIDGE'">
				<xsl:value-of select="'012'"/>
			</xsl:when>
			<xsl:when test="$input='1/4 INCH CARTRIDGE'">
				<xsl:value-of select="'013'"/>
			</xsl:when>
			<xsl:when test="$input='DIGITAL LINEAR TAPE'">
				<xsl:value-of select="'014'"/>
			</xsl:when>
			<xsl:when test="$input='ONLINE'">
				<xsl:value-of select="'015'"/>
			</xsl:when>
			<xsl:when test="$input='SATELLITE'">
				<xsl:value-of select="'016'"/>
			</xsl:when>
			<xsl:when test="$input='TELEPHONE LINK'">
				<xsl:value-of select="'017'"/>
			</xsl:when>
			<xsl:when test="$input='HARDCOPY'">
				<xsl:value-of select="'018'"/>
			</xsl:when>
			<xsl:when test="$input='CD ROM'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='CDROM'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:encodingType">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CPIO'">
				<xsl:value-of select="'cpio'"/>
			</xsl:when>
			<xsl:when test="$input='TAR'">
				<xsl:value-of select="'tar'"/>
			</xsl:when>
			<xsl:when test="$input='HIGH SEIRRA'">
				<xsl:value-of select="'highSierra'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660'">
				<xsl:value-of select="'iso9660'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH ROCK RIDGE'">
				<xsl:value-of select="'iso9660RockRidge'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 UNIX'">
				<xsl:value-of select="'iso9660RockRidge'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH APPLE HFS'">
				<xsl:value-of select="'iso9660AppleHFS'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 MAC'">
				<xsl:value-of select="'iso9660AppleHFS'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:encodingCode">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CPIO'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='TAR'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='HIGH SEIRRA'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH ROCK RIDGE'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 UNIX'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH APPLE HFS'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 MAC'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:function name="grp:sourcesUsed">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/srcused">
			<xsl:sequence select="xs:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:origins">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/origin">
			<xsl:sequence select="xs:string(xs:string(.))"/>
		</xsl:for-each>
	</xsl:function>
	<!-- end of codelist lookup functions -->
	<!--   ***** -->
	<!-- xml header stuff -->
	<xsl:namespace-alias stylesheet-prefix="gml" result-prefix="#default"/>
	<xsl:output method="xml" encoding="UTF-8" indent="yes"/>
	<!-- grouping keywords into themes -->
	<xsl:function name="grp:themektKeywords">
		<!-- themekt is theme keyword thesaurus -->
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/themekt">
			<xsl:if test="not(fn:contains(xs:string(xs:string(.)), 'ISO 19115'))">
				<xsl:sequence select="xs:string(.)"/>
			</xsl:if>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:themekeyKeyword">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/themekey">
			<xsl:sequence select="xs:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:placektKeywords">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/placekt">
			<xsl:sequence select="xs:string(xs:string(.))"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:placeKeyword">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/placekey">
			<xsl:sequence select="xs:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:strataktKeywords">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/stratkt">
			<xsl:sequence select="xs:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:strataKeyword">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/stratkey">
			<xsl:sequence select="xs:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<!-- tempkt is temporal keyword thesaurus -->
	<xsl:function name="grp:tempktKeywords">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/tempkt">
			<xsl:sequence select="xs:string(xs:string(.))"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:temporalKeyword">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/tempkey">
			<xsl:sequence select="xs:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:calendarDate">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/caldate">
			<xsl:sequence select="xs:string(xs:string(.))"/>
		</xsl:for-each>
	</xsl:function>
	<!-- end of group definition functions -->
	<!--  ***************** -->
	<!-- Start actual output metadata record here, let's get down to business -->
	<xsl:template match="/">
		<gmd:MD_Metadata>
			<xsl:attribute name="xsi:schemaLocation" separator=" "><xsl:sequence select="'http://www.isotc211.org/2005/gmd http://schemas.opengis.net/iso/19139/20060504/gmd/gmd.xsd'"/></xsl:attribute>
			<xsl:variable name="var_InputRootNode" as="node()" select="."/>
			<xsl:variable name="var_metadataRoot" as="node()" select="./metadata"/>
			<!-- these all have fixed values for now -->

			<gmd:fileIdentifier>
				<gco:CharacterString>
					<xsl:choose>
						<xsl:when test="fn:exists($var_metadataRoot/idinfo/citation/citeinfo/onlink[1])">
							<xsl:sequence select="fn:normalize-space(fn:substring-after(xs:string($var_metadataRoot/idinfo/citation/citeinfo/onlink[1]),'//'))"/>
						</xsl:when>
						<xsl:when test="fn:exists($var_metadataRoot/distinfo[1]/resdesc)">
							<xsl:sequence select="fn:replace(fn:normalize-space(xs:string($var_metadataRoot/distinfo[1]/resdesc)),' ','')"/>
						</xsl:when>
						<xsl:otherwise>
							<!-- put in something, USGIN profile requires... -->
							<xsl:value-of select="fn:concat(fn:string('http://www.opengis.net/def/nil/OGC/0/missing/'),fn:string(current-dateTime()))"/>
						</xsl:otherwise>
					</xsl:choose>	
				</gco:CharacterString>
			</gmd:fileIdentifier>
			<gmd:language>
				<gco:CharacterString>eng</gco:CharacterString>
			</gmd:language>
			<gmd:characterSet>
				<gmd:MD_CharacterSetCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CharacterSetCode" codeListValue="utf8" codeSpace="004">utf8</gmd:MD_CharacterSetCode>
			</gmd:characterSet>
			<gmd:hierarchyLevel>
				<gmd:MD_ScopeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode" codeListValue="dataset" codeSpace="005">dataset</gmd:MD_ScopeCode>
			</gmd:hierarchyLevel>
			<!-- end fixed values, now start pulling stuff from input record -->
			<gmd:hierarchyLevelName>
				<gco:CharacterString>
					<xsl:value-of select="$var_metadataRoot/distinfo/resdesc"/>
				</gco:CharacterString>
			</gmd:hierarchyLevelName>
			<gmd:contact>
				<gmd:CI_ResponsibleParty>
					<!-- scrape input cntinfo for person and org names that might be in one of 2 places -->
					<xsl:variable name="var_contactIndividual_exists" as="xs:string*">
						<xsl:choose>
							<xsl:when test="fn:exists($var_metadataRoot/metainfo/metc/cntinfo/cntperp/cntper)">
								<!-- old xsl:when test="fn:exists($var5_map_select_metadata)" -->
								<xsl:for-each select="$var_metadataRoot/metainfo/metc/cntinfo/cntperp/cntper">
									<xsl:sequence select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:when>
							<xsl:otherwise>
								<xsl:for-each select="$var_metadataRoot/metainfo/metc/cntinfo/cntorgp/cntper">
									<xsl:sequence select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					<!-- xsl:variable name="var16_map_select_metadata" as="xs:string*">
							<xsl:for-each select="$var_metadataRoot/metainfo/metc/cntinfo/cntperp/cntorg">
								<xsl:sequence select="xs:string(.)"/>
							</xsl:for-each>
						</xsl:variable -->
					<xsl:variable name="var_contactOrganisation_exists" as="xs:string*">
						<xsl:choose>
							<xsl:when test="fn:exists($var_metadataRoot/metainfo/metc/cntinfo/cntperp/cntorg)">
								<xsl:for-each select="$var_metadataRoot/metainfo/metc/cntinfo/cntperp/cntorg">
									<xsl:sequence select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:when>
							<xsl:otherwise>
								<xsl:for-each select="$var_metadataRoot/metainfo/metc/cntinfo/cntorgp/cntorg">
									<xsl:sequence select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					<!-- done scraping content for contact name -->
					<!-- now populate the elements count(individualName + OrganisationName + positionName) must be >0 -->
					<xsl:call-template name="usgin:contactName">
						<xsl:with-param name="inputPersonNode" select="$var_contactIndividual_exists"/>
						<xsl:with-param name="inputOrganizationNode" select="($var_contactOrganisation_exists)"/>
						<xsl:with-param name="inputPositionNode" select="($var_metadataRoot/metainfo/metc/cntinfo/cntpos)"/>
					</xsl:call-template>
					<gmd:contactInfo>
						<gmd:CI_Contact>
							<!--xsl:variable name="var_eMail_exists" as="xs:string*">
								<xsl:if test="fn:exists($var_metadataRoot/metainfo/metc/cntinfo/cntemail)">
									<xsl:for-each select="$var_metadataRoot/metainfo/metc/cntinfo/cntemail">
										<xsl:sequence select="xs:string(.)"/>
									</xsl:for-each>
								</xsl:if>
							</xsl:variable -->
							<!-- done checking  for phone number existance in the source record -->
							<!-- do the phone number(s) -->
							<xsl:call-template name="usgin:telephoneFormat">
								<xsl:with-param name="telNode" select="($var_metadataRoot/metainfo/metc/cntinfo)"/>
							</xsl:call-template>
							<gmd:address>
								<gmd:CI_Address>
									<xsl:call-template name="usgin:addressFormat">
										<xsl:with-param name="inputAddr" select="$var_metadataRoot/metainfo/metc/cntinfo/cntaddr[1]"/>
									</xsl:call-template>
									<!-- done with postal address elements, now the e-mail. Set this up so that some value gets inserted -->
									<xsl:call-template name="usgin:emailFormat">
										<xsl:with-param name="emailNode" select="$var_metadataRoot/metainfo/metc/cntinfo"/>
									</xsl:call-template>
									<!--gmd:electronicMailAddress>
										<xsl:choose>
											<xsl:when test="fn:exists($var_eMail_exists)">
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space($var_eMail_exists)"/>
												</gco:CharacterString>
											</xsl:when>
											<xsl:otherwise>
												<gco:CharacterString>
												noPhone.or.eMail@missing.org
											</gco:CharacterString>
											</xsl:otherwise>
										</xsl:choose>
									</gmd:electronicMailAddress -->
								</gmd:CI_Address>
							</gmd:address>
							<xsl:if test="fn:exists($var_metadataRoot/metainfo/metc/cntinfo/hours)">
								<gmd:hoursOfService>
									<!-- xsl:for-each select="" pull this out so don't end up withh multiple characterstring elements -->
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(xs:string($var_metadataRoot/metainfo/metc/cntinfo/hours))"/>
									</gco:CharacterString>
									<!-- /xsl:for-each -->
								</gmd:hoursOfService>
							</xsl:if>
							<xsl:if test="fn:exists($var_metadataRoot/metainfo/metc/cntinfo/cntinst)">
								<gmd:contactInstructions>
									<!--xsl:for-each select="" pull this out so don't end up withh multiple characterstring elements -->
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(xs:string($var_metadataRoot/metainfo/metc/cntinfo/cntinst))"/>
									</gco:CharacterString>
									<!-- /xsl:for-each -->
								</gmd:contactInstructions>
							</xsl:if>
						</gmd:CI_Contact>
					</gmd:contactInfo>
					<!-- role gets a fixed value; FGDC doesn't allow for different roles, so assume point of contact -->
					<gmd:role>
						<gmd:CI_RoleCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode" codeListValue="pointOfContact" codeSpace="007">pointOfContact</gmd:CI_RoleCode>
					</gmd:role>
				</gmd:CI_ResponsibleParty>
			</gmd:contact>
			<gmd:dateStamp>
				<xsl:for-each select="$var_metadataRoot/metainfo/metd">
					<xsl:call-template name="usgin:dateFormat">
						<xsl:with-param name="inputDate" select="$var_metadataRoot/metainfo/metd"/>
						<xsl:with-param name="inputTime" select="()"/>
					</xsl:call-template>
				</xsl:for-each>
			</gmd:dateStamp>
			<gmd:metadataStandardName>
				<gco:CharacterString>
					<xsl:sequence select="'ISO-USGIN'"/>
				</gco:CharacterString>
			</gmd:metadataStandardName>
			<gmd:metadataStandardVersion>
				<gco:CharacterString>
					<xsl:sequence select="'1.1'"/>
				</gco:CharacterString>
			</gmd:metadataStandardVersion>
			<!-- if there is a URL supplied in the citation for the resource, use this as the resource identifier -->
			<gmd:dataSetURI>
				<gco:CharacterString>
					<xsl:choose>
						<xsl:when test="fn:exists($var_metadataRoot/idinfo/citation/citeinfo/onlink[1])">
							<xsl:sequence select="fn:normalize-space(xs:string($var_metadataRoot/idinfo/citation/citeinfo/onlink[1]))"/>
						</xsl:when>
						<xsl:when test="fn:exists($var_metadataRoot/distinfo[1]/resdesc)">
							<xsl:sequence select="fn:normalize-space(xs:string($var_metadataRoot/distinfo[1]/resdesc))"/>
						</xsl:when>
						<xsl:otherwise>
							<!-- put in something, USGIN profile requires... -->
							<xsl:value-of select="fn:concat(fn:string('http://www.opengis.net/def/nil/OGC/0/missing/'),fn:string(current-dateTime()))"/>
						</xsl:otherwise>
					</xsl:choose>
				</gco:CharacterString>
			</gmd:dataSetURI>
			<!--/xsl:for-each -->
			<!-- metadata/spdoinfo spatial data information -->
			<xsl:for-each select="$var_metadataRoot">
				<xsl:for-each select="spdoinfo">
					<!-- spatial representation -->
					<xsl:for-each select="rastinfo">
						<xsl:variable name="var_rastinfoNode" as="node()" select="."/>
						<gmd:spatialRepresentationInfo>
							<gmd:MD_GridSpatialRepresentation>
								<xsl:variable name="var_rowCount_exists" as="xs:decimal?" select="(if (fn:exists(rowcount)) then xs:decimal(1) else ())"/>
								<xsl:variable name="var_colCount_exists" as="xs:decimal?" select="(if (fn:exists(colcount)) then xs:decimal(1) else ())"/>
								<xsl:variable name="var_vrtCount_exists" as="xs:decimal?" select="(if (fn:exists(vrtcount)) then xs:decimal(1) else ())"/>
								<gmd:numberOfDimensions>
									<xsl:choose>
										<xsl:when test="fn:exists(xs:string(xs:integer($var_rowCount_exists + $var_colCount_exists + $var_vrtCount_exists)))">
											<gco:Integer>
												<xsl:sequence select="xs:string(xs:integer($var_rowCount_exists + $var_colCount_exists + $var_vrtCount_exists))"/>
											</gco:Integer>
										</xsl:when>
										<xsl:otherwise>
											<gco:Integer>
												<xsl:value-of select="xs:string('1')"/>
											</gco:Integer>
										</xsl:otherwise>
									</xsl:choose>
								</gmd:numberOfDimensions>
								<!-- This for-each and the similar ones below were commented out by Ted Habermann 2011-07-26
									<xsl:for-each select="$var72_metadata/idinfo/citation/citeinfo/lworkcit">-->
								<gmd:axisDimensionProperties>
									<gmd:MD_Dimension>
										<gmd:dimensionName>
											<xsl:variable name="var_hasRow" as="xs:string?" select="(if (fn:exists($var_rastinfoNode/rowcount)) then 'row' else ())"/>
											<xsl:if test="fn:exists($var_hasRow)">
												<gmd:MD_DimensionNameTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode" codeListValue="row" codeSpace="001">row</gmd:MD_DimensionNameTypeCode>
											</xsl:if>
										</gmd:dimensionName>
										<xsl:if test="fn:exists($var_rastinfoNode/rowcount)">
											<gmd:dimensionSize>
												<gco:Integer>
													<xsl:sequence select="xs:string(xs:integer($var_rastinfoNode/rowcount))"/>
												</gco:Integer>
											</gmd:dimensionSize>
										</xsl:if>
									</gmd:MD_Dimension>
								</gmd:axisDimensionProperties>
								<!--</xsl:for-each>-->
								<!--<xsl:for-each select="$var72_metadata/idinfo/citation/citeinfo/lworkcit">-->
								<gmd:axisDimensionProperties>
									<gmd:MD_Dimension>
										<gmd:dimensionName>
											<xsl:variable name="var_hasColumn" as="xs:string?" select="(if (fn:exists($var_rastinfoNode/colcount)) then 'column' else ())"/>
											<xsl:if test="fn:exists($var_hasColumn)">
												<gmd:MD_DimensionNameTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode" codeListValue="column" codeSpace="002">column</gmd:MD_DimensionNameTypeCode>
											</xsl:if>
										</gmd:dimensionName>
										<gmd:dimensionSize>
											<xsl:for-each select="$var_rastinfoNode/colcount">
												<gco:Integer>
													<xsl:sequence select="xs:string(xs:integer(.))"/>
												</gco:Integer>
											</xsl:for-each>
										</gmd:dimensionSize>
									</gmd:MD_Dimension>
								</gmd:axisDimensionProperties>
								<!--</xsl:for-each>-->
								<!--<xsl:for-each select="$var72_metadata/idinfo/citation/citeinfo/lworkcit">-->
								<xsl:if test="fn:exists($var_rastinfoNode/vrtcount)">
									<gmd:axisDimensionProperties>
										<gmd:MD_Dimension>
											<gmd:dimensionName>
												<xsl:variable name="var_hasVertical" as="xs:string?" select="(if (fn:exists($var_rastinfoNode/vrtcount)) then 'vertical' else ())"/>
												<gmd:MD_DimensionNameTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode" codeListValue="vertical" codeSpace="003">vertical</gmd:MD_DimensionNameTypeCode>
											</gmd:dimensionName>
											<gmd:dimensionSize>
												<xsl:for-each select="$var_rastinfoNode/vrtcount">
													<gco:Integer>
														<xsl:sequence select="xs:string(xs:integer(.))"/>
													</gco:Integer>
												</xsl:for-each>
											</gmd:dimensionSize>
										</gmd:MD_Dimension>
									</gmd:axisDimensionProperties>
								</xsl:if>
								<!--</xsl:for-each>-->
								<!-- determine if input data has a rasttype property and use that to assign cell geometry Type code -->
								<xsl:variable name="var_rasttypeGeometryType" as="xs:string?">
									<xsl:call-template name="vmf:geometryType">
										<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(rasttype)))"/>
									</xsl:call-template>
								</xsl:variable>
								<!-- if have gridSpatialRepresnetation, cellGeometry is mandatory -->
								<xsl:choose>
									<xsl:when test="fn:exists($var_rasttypeGeometryType)">
										<gmd:cellGeometry>
											<gmd:MD_CellGeometryCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CellGeometryCode">
												<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI($var_rasttypeGeometryType))"/></xsl:attribute>
												<xsl:variable name="var_rasttypeGeometryCode" as="xs:string?">
													<xsl:call-template name="vmf:geometryCode">
														<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(rasttype)))"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:if test="fn:exists($var_rasttypeGeometryCode)">
													<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI($var_rasttypeGeometryCode))"/></xsl:attribute>
												</xsl:if>
												<xsl:sequence select="$var_rasttypeGeometryType"/>
											</gmd:MD_CellGeometryCode>
										</gmd:cellGeometry>
									</xsl:when>
									<xsl:otherwise>
										<gmd:cellGeometry gco:nilReason="missing"/>
									</xsl:otherwise>
								</xsl:choose>
								<!-- no content for transformation parmater avaialalbility in FGDC metatada -->
								<gmd:transformationParameterAvailability>
									<xsl:attribute name="gco:nilReason"><xsl:value-of select="unknown"/></xsl:attribute>
								</gmd:transformationParameterAvailability>
							</gmd:MD_GridSpatialRepresentation>
						</gmd:spatialRepresentationInfo>
					</xsl:for-each>
					<!-- do vector spatial represntation description; FGCD xml specifies choice between rastinfo or ptvctinf -->
					<!-- but ISO19115 allows both to be present in valid instance -->
					<xsl:for-each select="ptvctinf">
						<!-- Point and Vector Object Information,+ the types and numbers of vector or nongridded point spatial objects in the data set. -->
						<!-- FGDC xml implements this element as a choice between 1..* sdtsterm elements, or 1 vpfterm -->
						<!-- xsl:variable name="var_PointVectorObjCountNode" as="node()" select="."/ -->
						<gmd:spatialRepresentationInfo>
							<gmd:MD_VectorSpatialRepresentation>
								<xsl:for-each select="vpfterm">
									<gmd:topologyLevel>
										<gmd:MD_TopologyLevelCode>
											<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(fn:string(vpflevel))))"/></xsl:attribute>
										</gmd:MD_TopologyLevelCode>
									</gmd:topologyLevel>
								</xsl:for-each>
								<!-- done with vpfterm processing -->
								<xsl:for-each select="sdtsterm">
									<gmd:geometricObjects>
										<gmd:MD_GeometricObjects>
											<gmd:geometricObjectType>
												<xsl:variable name="sdtsTermTypeList" as="xs:string*">
													<xsl:for-each select="sdtsterm">
														<xsl:sequence select="fn:string(sdtstype)"/>
													</xsl:for-each>
												</xsl:variable>
												<xsl:variable name="sdtsTermExists" as="xs:string?">
													<xsl:if test="fn:exists($sdtsTermTypeList)">
														<xsl:variable name="var136_cond_result_exists" as="xs:string?">
															<xsl:choose>
																<xsl:when test="fn:exists($sdtsTermTypeList)">
																	<xsl:variable name="var142_map_select_sdtsterm" as="xs:string*">
																		<xsl:for-each select="sdtsterm">
																			<xsl:if test="fn:exists($sdtsTermTypeList)">
																				<xsl:sequence select="fn:string(sdtstype)"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var142_map_select_sdtsterm)">
																		<xsl:sequence select="fn:string-join($var142_map_select_sdtsterm, ' ')"/>
																	</xsl:if>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:for-each select="vpfterm">
																		<xsl:sequence select="fn:string(vpflevel)"/>
																	</xsl:for-each>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:variable>
														<xsl:for-each select="$var136_cond_result_exists">
															<xsl:variable name="var139_result_geometryType2" as="xs:string?">
																<xsl:call-template name="vmf:geometryType2">
																	<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:if test="fn:exists($var139_result_geometryType2)">
																<xsl:sequence select="$var139_result_geometryType2"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:if>
												</xsl:variable>
												<xsl:if test="fn:exists($sdtsTermExists)">
													<gmd:MD_GeometricObjectTypeCode>
														<xsl:variable name="var112_map_select_vpfterm" as="xs:string?">
															<xsl:for-each select="vpfterm">
																<xsl:sequence select="fn:string(vpflevel)"/>
															</xsl:for-each>
														</xsl:variable>
														<xsl:variable name="var113_map_select_sdtsterm" as="xs:string*">
															<xsl:for-each select="sdtsterm">
																<xsl:sequence select="fn:string(sdtstype)"/>
															</xsl:for-each>
														</xsl:variable>
														<xsl:if test="fn:exists((if ((fn:exists($var113_map_select_sdtsterm) or fn:exists($var112_map_select_vpfterm))) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_GeometricObjectTypeCode' else ()))">
															<xsl:attribute name="codeList"><xsl:sequence select="xs:string(xs:anyURI(fn:string((if ((fn:exists($var113_map_select_sdtsterm) or fn:exists($var112_map_select_vpfterm))) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_GeometricObjectTypeCode' else ()))))"/></xsl:attribute>
														</xsl:if>
														<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI(fn:string($sdtsTermExists)))"/></xsl:attribute>
														<xsl:variable name="var119_map_select_sdtsterm" as="xs:string*">
															<xsl:for-each select="sdtsterm">
																<xsl:sequence select="fn:string(sdtstype)"/>
															</xsl:for-each>
														</xsl:variable>
														<xsl:variable name="var118_cond_result_exists" as="xs:string?">
															<xsl:if test="fn:exists($var119_map_select_sdtsterm)">
																<xsl:variable name="var121_cond_result_exists" as="xs:string?">
																	<xsl:choose>
																		<xsl:when test="fn:exists($var119_map_select_sdtsterm)">
																			<xsl:variable name="var127_map_select_sdtsterm" as="xs:string*">
																				<xsl:for-each select="sdtsterm">
																					<xsl:if test="fn:exists($var119_map_select_sdtsterm)">
																						<xsl:sequence select="fn:string(sdtstype)"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var127_map_select_sdtsterm)">
																				<xsl:sequence select="fn:string-join($var127_map_select_sdtsterm, ' ')"/>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:for-each select="vpfterm">
																				<xsl:sequence select="fn:string(vpflevel)"/>
																			</xsl:for-each>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:for-each select="$var121_cond_result_exists">
																	<xsl:variable name="var124_result_geometryCode2" as="xs:string?">
																		<xsl:call-template name="vmf:geometryCode2">
																			<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																		</xsl:call-template>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var124_result_geometryCode2)">
																		<xsl:sequence select="$var124_result_geometryCode2"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:if>
														</xsl:variable>
														<xsl:if test="fn:exists($var118_cond_result_exists)">
															<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI(fn:string($var118_cond_result_exists)))"/></xsl:attribute>
														</xsl:if>
														<xsl:sequence select="fn:string($sdtsTermExists)"/>
													</gmd:MD_GeometricObjectTypeCode>
												</xsl:if>
											</gmd:geometricObjectType>
											<gmd:geometricObjectCount>
												<xsl:variable name="var152_map_select_sdtsterm" as="xs:string*">
													<xsl:for-each select="sdtsterm/ptvctcnt">
														<xsl:sequence select="xs:string(xs:integer(.))"/>
													</xsl:for-each>
												</xsl:variable>
												<xsl:variable name="var149_cond_result_exists" as="xs:string*">
													<xsl:choose>
														<xsl:when test="fn:exists($var152_map_select_sdtsterm)">
															<xsl:for-each select="sdtsterm/ptvctcnt">
																<xsl:sequence select="xs:string(xs:integer(.))"/>
															</xsl:for-each>
														</xsl:when>
														<xsl:otherwise>
															<xsl:for-each select="vpfterm/vpfinfo/ptvctcnt">
																<xsl:sequence select="xs:string(xs:integer(.))"/>
															</xsl:for-each>
														</xsl:otherwise>
													</xsl:choose>
												</xsl:variable>
												<xsl:for-each select="$var149_cond_result_exists">
													<gco:Integer>
														<xsl:sequence select="xs:string(xs:integer(.))"/>
													</gco:Integer>
												</xsl:for-each>
											</gmd:geometricObjectCount>
										</gmd:MD_GeometricObjects>
									</gmd:geometricObjects>
								</xsl:for-each>
							</gmd:MD_VectorSpatialRepresentation>
						</gmd:spatialRepresentationInfo>
					</xsl:for-each>
					<!-- End of ptvctinf-->
				</xsl:for-each>
			</xsl:for-each>
			<!-- spatial reference system information -->
			<!-- indspref is an indirect spatial reference: any way to describe a location without using coordinates. 
				Indirect spatial reference methods usually use a geographic feature, such as a county, state, township or
section of the Public Land Survey System, or a road, to uniquely identify a place. The reference
may use the name of the feature, for example "Westmoreland County", or a code that identifies the
feature (such as a county FIPS code). Other examples of indirect spatial references include street
addresses, linear reference systems, and River Reach codes. -->
			<!-- this is bogus; what need here is a mappign from =4.1.2.1.1 Map Projection Name - name of the map projection" 
				domain values to EPSG codes -->
			<!-- these are the domain values:
				Albers Conical Equal Area
				Azimuthal Equidistant
				Equidistant Conic
				Equirectangular
				General Vertical Near-sided Perspective Gnomonic
				Lambert Azimuthal Equal Area
				Lambert Conformal Conic
				Mercator
				Modified Stereographic for Alaska
				Miller Cylindrical
				Oblique Mercator
				Orthographic
				Polar Stereographic
				Polyconic
				Robinson
				Sinusoidal
				Space Oblique Mercator
				Stereographic
				Transverse Mercator
				van der Grinten -->
			<xsl:for-each select="$var_metadataRoot/spdoinfo">
				<gmd:referenceSystemInfo>
					<gmd:MD_ReferenceSystem>
						<xsl:for-each select="indspref">
							<gmd:referenceSystemIdentifier>
								<gmd:RS_Identifier>
									<!-- smr change gmd:CodeSpace to gmd:code -->
									<gmd:code>
										<gco:CharacterString>
											<!-- xsl:sequence select="xs:string(.)"/ -->
											http://www.opengis.net/def/nil/OGC/0/missing
										</gco:CharacterString>
									</gmd:code>
								</gmd:RS_Identifier>
							</gmd:referenceSystemIdentifier>
						</xsl:for-each>
					</gmd:MD_ReferenceSystem>
				</gmd:referenceSystemInfo>
			</xsl:for-each>
			<!-- metadata extensions FGDC metainfo/metextns/onlink here  -->
			<gmd:metadataExtensionInfo>
				<gmd:MD_MetadataExtensionInformation>
					<gmd:extensionOnLineResource>
						<gmd:CI_OnlineResource>
							<gmd:linkage>
								<gmd:URL>
									<xsl:variable name="CIlinkURL" as="xs:integer">
										<xsl:value-of select="xs:integer(fn:count(/metadata/metainfo/metextns[1]/onlink))"/>
									</xsl:variable>
									<xsl:for-each select="/metadata/metainfo/metextns[1]/onlink">
										<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(xs:string(.))))"/>
										<xsl:if test="($CIlinkURL>1)">
											<xsl:value-of select="xs:string(' ')"/>
										</xsl:if>
									</xsl:for-each>
									<!--xsl:value-of select="$var_metadataRoot/metainfo/metextns/onlink"/>
										<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(xs:string(.))))"/> -->
								</gmd:URL>
							</gmd:linkage>
							<xsl:for-each select="metprof">
								<gmd:name>
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
									</gco:CharacterString>
								</gmd:name>
							</xsl:for-each>
						</gmd:CI_OnlineResource>
					</gmd:extensionOnLineResource>
				</gmd:MD_MetadataExtensionInformation>
			</gmd:metadataExtensionInfo>
			<!-- FGDC id metadata/idinfo goes into MD_identification -->
			<xsl:for-each select="$var_metadataRoot">
				<xsl:for-each select="idinfo">
					<xsl:variable name="var_idinfoSourceNode" as="node()" select="."/>
					<gmd:identificationInfo>
						<gmd:MD_DataIdentification>
							<xsl:for-each select="citation">
								<gmd:citation>
									<xsl:for-each select="citeinfo">
										<xsl:variable name="var_citeinfoSourceNode" as="node()" select="."/>
										<gmd:CI_Citation>
											<gmd:title>
												<xsl:for-each select="title">
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</xsl:for-each>
											</gmd:title>
											<gmd:date>
												<gmd:CI_Date>
													<gmd:date>
														<xsl:call-template name="usgin:dateFormat">
															<xsl:with-param name="inputDate" select="pubdate"/>
															<xsl:with-param name="inputTime" select="pubtime"/>
														</xsl:call-template>
													</gmd:date>
													<xsl:variable name="var_pubdate_exists" as="xs:string?" select="(if (fn:exists(pubdate)) then 'publication' else ())"/>
													<xsl:choose>
														<xsl:when test="fn:exists($var_pubdate_exists)">
															<gmd:dateType>
																<gmd:CI_DateTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode" codeListValue="publication" codeSpace="002">publication</gmd:CI_DateTypeCode>
															</gmd:dateType>
														</xsl:when>
														<xsl:otherwise>
															<gmd:dateType gco:nilReason="missing"/>
														</xsl:otherwise>
													</xsl:choose>
												</gmd:CI_Date>
											</gmd:date>
											<xsl:for-each select="edition">
												<gmd:edition>
													<gco:CharacterString>
														<xsl:sequence select="xs:string(.)"/>
													</gco:CharacterString>
												</gmd:edition>
											</xsl:for-each>
											<xsl:for-each select="$var_metadataRoot/distinfo/resdesc">
												<!-- ESRI geoportal 9.3 maps distinfo/resdesc to dc:Type -->
												<!-- mapping to citation//identifier/code is NOAA convention -->
												<!-- USGIN convention is that citation//identifier//code should be same identifier as dataset URI. 
													Obviously this property is not very useful for interoperability -->
												<gmd:identifier>
													<gmd:MD_Identifier>
														<gmd:authority>
															<gmd:CI_Citation>
																<gmd:title>
																	<gco:CharacterString>NOAA NGDC convention</gco:CharacterString>
																</gmd:title>
																<gmd:date gco:nilReason="inapplicable"/>
															</gmd:CI_Citation>
														</gmd:authority>
														<gmd:code>
															<gco:CharacterString>
																<xsl:sequence select="xs:string(.)"/>
															</gco:CharacterString>
														</gmd:code>
													</gmd:MD_Identifier>
												</gmd:identifier>
											</xsl:for-each>
											<gmd:identifier>
												<gmd:MD_Identifier>
													<gmd:authority>
														<gmd:CI_Citation>
															<gmd:title>
																<gco:CharacterString>USGIN convention</gco:CharacterString>
															</gmd:title>
															<gmd:date gco:nilReason="inapplicable"/>
														</gmd:CI_Citation>
													</gmd:authority>
													<gmd:code>
														<gco:CharacterString>
															<xsl:for-each select="$var_idinfoSourceNode/citation/citeinfo/onlink">
																<xsl:sequence select="fn:concat(fn:normalize-space(xs:string(.)),' ')"/>
															</xsl:for-each>
															<!-- xsl:sequence select="xs:string($var_idinfoSourceNode/citation/citeinfo/onlink)"/ -->
														</gco:CharacterString>
													</gmd:code>
												</gmd:MD_Identifier>
											</gmd:identifier>
											<gmd:citedResponsibleParty>
												<gmd:CI_ResponsibleParty>
													<gmd:organisationName>
														<!--	<xsl:for-each select="origin"> -->
														<gco:CharacterString>
															<xsl:variable name="orgCount" as="xs:integer">
																<xsl:value-of select="xs:integer(fn:count(origin))"/>
															</xsl:variable>
															<xsl:for-each select="origin">
																<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																<xsl:if test="($orgCount>1)">
																	<xsl:value-of select="xs:string(' ')"/>
																</xsl:if>
															</xsl:for-each>
														</gco:CharacterString>
														<!-- </xsl:for-each> -->
													</gmd:organisationName>
													<gmd:role>
														<gmd:CI_RoleCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode" codeListValue="originator" codeSpace="006">originator</gmd:CI_RoleCode>
													</gmd:role>
												</gmd:CI_ResponsibleParty>
											</gmd:citedResponsibleParty>
											<gmd:presentationForm>
												<xsl:variable name="var342_cond_result_exists" as="xs:string?">
													<xsl:choose>
														<xsl:when test="$var_citeinfoSourceNode/geoform">
															<xsl:variable name="var356_map_select_geoform" as="xs:string*">
																<xsl:for-each select="geoform">
																	<xsl:variable name="var359_result_docType" as="xs:string?">
																		<xsl:call-template name="vmf:docType">
																			<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(.)))"/>
																		</xsl:call-template>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var359_result_docType)">
																		<xsl:sequence select="$var359_result_docType"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:variable>
															<xsl:if test="fn:exists($var356_map_select_geoform)">
																<xsl:sequence select="xs:string(fn:string-join($var356_map_select_geoform, ' '))"/>
															</xsl:if>
														</xsl:when>
														<xsl:otherwise>
															<xsl:variable name="var360_map_select_geoform" as="xs:string*">
																<xsl:for-each select="geoform">
			xs:string(												)		<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																</xsl:for-each>
															</xsl:variable>
															<xsl:if test="fn:exists($var360_map_select_geoform)">
																<xsl:sequence select="xs:string(fn:string-join($var360_map_select_geoform, ' '))"/>
															</xsl:if>
														</xsl:otherwise>
													</xsl:choose>
												</xsl:variable>
												<xsl:for-each select="$var342_cond_result_exists">
													<gmd:CI_PresentationFormCode>
														<xsl:variable name="var345_cond_result_exists" as="xs:string?" select="(if (fn:exists($var_citeinfoSourceNode/geoform)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode' else ())"/>
														<xsl:if test="fn:exists($var345_cond_result_exists)">
															<xsl:attribute name="codeList"><xsl:sequence select="xs:string(xs:anyURI($var345_cond_result_exists))"/></xsl:attribute>
														</xsl:if>
														<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI(.))"/></xsl:attribute>
														<xsl:variable name="var346_cond_result_exists" as="xs:string?">
															<xsl:if test="$var_citeinfoSourceNode/geoform">
																<xsl:variable name="var350_map_select_geoform" as="xs:string*">
																	<xsl:for-each select="$var_citeinfoSourceNode/geoform">
																		<xsl:variable name="var353_result_docCode" as="xs:string?">
																			<xsl:call-template name="vmf:docCode">
																				<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																			</xsl:call-template>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var353_result_docCode)">
																			<xsl:sequence select="$var353_result_docCode"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:if test="fn:exists($var350_map_select_geoform)">
																	<xsl:sequence select="xs:string(fn:string-join($var350_map_select_geoform, ' '))"/>
																</xsl:if>
															</xsl:if>
														</xsl:variable>
														<xsl:for-each select="$var346_cond_result_exists">
															<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI(.))"/></xsl:attribute>
														</xsl:for-each>
														<xsl:sequence select="."/>
													</gmd:CI_PresentationFormCode>
												</xsl:for-each>
											</gmd:presentationForm>
											<xsl:for-each select="serinfo">
												<gmd:series>
													<gmd:CI_Series>
														<gmd:name>
															<xsl:for-each select="sername">
																<gco:CharacterString>
																	<xsl:sequence select="xs:string(.)"/>
																</gco:CharacterString>
															</xsl:for-each>
														</gmd:name>
														<gmd:issueIdentification>
															<xsl:for-each select="issue">
																<gco:CharacterString>
																	<xsl:sequence select="xs:string(.)"/>
																</gco:CharacterString>
															</xsl:for-each>
														</gmd:issueIdentification>
													</gmd:CI_Series>
												</gmd:series>
											</xsl:for-each>
											<xsl:for-each select="othercit">
												<gmd:otherCitationDetails>
													<gco:CharacterString>
														<xsl:sequence select="xs:string(.)"/>
													</gco:CharacterString>
												</gmd:otherCitationDetails>
											</xsl:for-each>
										</gmd:CI_Citation>
									</xsl:for-each>
								</gmd:citation>
							</xsl:for-each>
							<!-- xsl:for-each select="descript/abstract" -->
							<gmd:abstract>
								<gco:CharacterString>
									<xsl:choose>
										<xsl:when test="fn:exists(descript/abstract) and string-length(xs:string(descript/abstract))>0">
											<xsl:sequence select="fn:normalize-space(xs:string(descript/abstract))"/>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="xs:string('no abstract provided')"/>
										</xsl:otherwise>
									</xsl:choose>
									<!-- insert text for spataial data organization, spatial data reference, and entity attribute information
							that is not well accounted for in transformation -->
									<!-- the following text is modified from FGDC_Classic for Web body
An xsl template for displaying metadata in ArcInfo8 with the traditional FGDC look and feel created by mp
	-->
Other sections: 	<xsl:for-each select="$var_metadataRoot/spdoinfo">
Spatial Data Organization:	<xsl:for-each select="indspref">
	Indirect_Spatial_Reference_Method:  <xsl:value-of select="."/>
										</xsl:for-each>
										<xsl:for-each select="direct">
	Direct_Spatial_Reference_Method: <xsl:value-of select="."/>
										</xsl:for-each>
										<xsl:for-each select="ptvctinf">
	Point_and_Vector_Object_Information: <xsl:for-each select="sdtsterm">
		SDTS_Terms_Description: <xsl:for-each select="sdtstype">
			SDTS_Point_and_Vector_Object_Type:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="ptvctcnt">
			Point_and_Vector_Object_Count:  <xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="vpfterm">
			VPF_Terms_Description: 
											<xsl:for-each select="vpflevel">
				VPF_Topology_Level: <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="vpfinfo">
				VPF_Point_and_Vector_Object_Information: 
												<xsl:for-each select="vpftype">
						VPF_Point_and_Vector_Object_Type: 
													<xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="ptvctcnt">
						Point_and_Vector_Object_Count:
													<xsl:value-of select="."/>
													</xsl:for-each>
												</xsl:for-each>
											</xsl:for-each>
										</xsl:for-each>
										<xsl:for-each select="rastinfo">
Raster_Object_Information: <xsl:for-each select="rasttype">
Raster_Object_Type:	<xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="rowcount">
	Row_Count: <xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="colcount">
	Column_Count: <xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="vrtcount">
	Vertical_Count: <xsl:value-of select="."/>
											</xsl:for-each>
										</xsl:for-each>
									</xsl:for-each>
									<!-- Spatial Reference text blob gets put in the abstract if its present.-->
									<xsl:for-each select="$var_metadataRoot/spref">
Spatial_Reference_Information: <xsl:for-each select="horizsys">
	Horizontal_Coordinate_System_Definition: <xsl:for-each select="geograph">
		Geographic: 	<xsl:for-each select="latres">
			Latitude_Resolution: <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="longres">
			Longitude_Resolution: <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="geogunit">
			Geographic_Coordinate_Units: <xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="planar">
				Planar: 	<xsl:for-each select="mapproj">
					Map_Projection: <xsl:for-each select="mapprojn">
						Map_Projection_Name: <xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="albers">
							Albers_Conical_Equal_Area: </xsl:for-each>
													<xsl:for-each select="azimequi">
							Azimuthal_Equidistant: </xsl:for-each>
													<xsl:for-each select="equicon">
							Equidistant_Conic:  </xsl:for-each>
													<xsl:for-each select="equirect">
							Equirectangular:  </xsl:for-each>
													<xsl:for-each select="gvnsp">
							General_Vertical_Near-sided_Perspective: </xsl:for-each>
													<xsl:for-each select="gnomonic">
							Gnomonic:  </xsl:for-each>
													<xsl:for-each select="lamberta">
							Lambert_Azimuthal_Equal_Area: </xsl:for-each>
													<xsl:for-each select="lambertc"> 
							Lambert_Conformal_Conic:  </xsl:for-each>
													<xsl:for-each select="mercator">
							Mercator:  </xsl:for-each>
													<xsl:for-each select="modsak">
							Modified_Stereographic_for_Alaska: </xsl:for-each>
													<xsl:for-each select="miller">
							Miller_Cylindrical: </xsl:for-each>
													<xsl:for-each select="obqmerc">
							Oblique_Mercator: </xsl:for-each>
													<xsl:for-each select="orthogr">
							Orthographic: </xsl:for-each>
													<xsl:for-each select="polarst">
							Polar_Stereographic: </xsl:for-each>
													<xsl:for-each select="polycon">
							Polyconic: </xsl:for-each>
													<xsl:for-each select="robinson">
							Robinson: </xsl:for-each>
													<xsl:for-each select="sinusoid">
							Sinusoidal: </xsl:for-each>
													<xsl:for-each select="spaceobq">
							Space_Oblique_Mercator_(Landsat): </xsl:for-each>
													<xsl:for-each select="stereo">
							Stereographic: </xsl:for-each>
													<xsl:for-each select="transmer">
							Transverse_Mercator: </xsl:for-each>
													<xsl:for-each select="vdgrin">
							van_der_Grinten: </xsl:for-each>
													<xsl:apply-templates select="*"/>
													<!-- this is where the work gets done, in the template for each projection -->
												</xsl:for-each>
												<xsl:for-each select="gridsys">
Grid_Coordinate_System: 	<xsl:for-each select="gridsysn">
	Grid_Coordinate_System_Name: <xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="utm">
	Universal_Transverse_Mercator: 	<xsl:for-each select="utmzone">
		UTM_Zone_Number: <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="transmer">
		Transverse_Mercator: 	</xsl:for-each>
														<xsl:apply-templates select="transmer"/>
													</xsl:for-each>
													<xsl:for-each select="ups">
		Universal_Polar_Stereographic: 
					<xsl:for-each select="upszone">
			UPS_Zone_Identifier: <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="polarst">
		Polar_Stereographic: 
					</xsl:for-each>
														<xsl:apply-templates select="polarst"/>
													</xsl:for-each>
													<xsl:for-each select="spcs">
		State_Plane_Coordinate_System: 
					<xsl:for-each select="spcszone">
			SPCS_Zone_Identifier:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="lambertc">
		Lambert_Conformal_Conic: 
					</xsl:for-each>
														<xsl:apply-templates select="lambertc"/>
														<xsl:for-each select="transmer">
		Transverse_Mercator: 
					</xsl:for-each>
														<xsl:apply-templates select="transmer"/>
														<xsl:for-each select="obqmerc">
		Oblique_Mercator: 
					</xsl:for-each>
														<xsl:apply-templates select="obqmerc"/>
														<xsl:for-each select="polycon">
		Polyconic: 
					</xsl:for-each>
														<xsl:apply-templates select="polycon"/>
													</xsl:for-each>
													<xsl:for-each select="arcsys">
		ARC_Coordinate_System: 
			<xsl:for-each select="arczone">
			ARC_System_Zone_Identifier:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="equirect">
		Equirectangular: 
			</xsl:for-each>
														<xsl:apply-templates select="equirect"/>
														<xsl:for-each select="azimequi">
		Azimuthal_Equidistant: </xsl:for-each>
														<xsl:apply-templates select="azimequi"/>
													</xsl:for-each>
													<xsl:for-each select="othergrd">
		Other_Grid_System's_Definition: <xsl:value-of select="."/>
													</xsl:for-each>
												</xsl:for-each>
												<xsl:for-each select="localp">
Local_Planar: 
	<xsl:for-each select="localpd">
	Local_Planar_Description: <xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="localpgi">
	Local_Planar_Georeference_Information: <xsl:value-of select="."/>
													</xsl:for-each>
												</xsl:for-each>
												<xsl:for-each select="planci">
	Planar_Coordinate_Information: <xsl:for-each select="plance">
		Planar_Coordinate_Encoding_Method: <xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="coordrep">
		Coordinate_Representation: <xsl:for-each select="absres">
			Abscissa_Resolution:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="ordres">
			Ordinate_Resolution:  <xsl:value-of select="."/>
														</xsl:for-each>
													</xsl:for-each>
													<xsl:for-each select="distbrep">
	Distance_and_Bearing_Representation: 
				<xsl:for-each select="distres">
			Distance_Resolution: <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="bearres">
			Bearing_Resolution:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="bearunit">
			Bearing_Units:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="bearrefd">
			Bearing_Reference_Direction:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="bearrefm">
			Bearing_Reference_Meridian:  <xsl:value-of select="."/>
														</xsl:for-each>
													</xsl:for-each>
													<xsl:for-each select="plandu">
	Planar_Distance_Units: <xsl:value-of select="."/>
													</xsl:for-each>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="local">
Local: <xsl:for-each select="localdes">
	Local_Description:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="localgeo">
	Local_Georeference_Information:  <xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="geodetic">
Geodetic_Model: <xsl:for-each select="horizdn">
	Horizontal_Datum_Name:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="ellips">
	Ellipsoid_Name:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="semiaxis">
	Semi-major_Axis: <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="denflat">
	Denominator_of_Flattening_Ratio:  <xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
										</xsl:for-each>
										<xsl:for-each select="vertdef">
Vertical_Coordinate_System_Definition: <xsl:for-each select="altsys">
		Altitude_System_Definition: <xsl:for-each select="altdatum">
			Altitude_Datum_Name:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="altres">
			Altitude_Resolution:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="altunits">
				Altitude_Distance_Units:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="altenc">
				Altitude_Encoding_Method:  <xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="depthsys">
		Depth_System_Definition: <xsl:for-each select="depthdn">
				Depth_Datum_Name:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="depthres">
				Depth_Resolution:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="depthdu">
				Depth_Distance_Units:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="depthem">
				Depth_Encoding_Method:  <xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
										</xsl:for-each>
									</xsl:for-each>
									<!-- End spatial reference section -->
									<!-- Entity and Attribute -->
									<xsl:for-each select="$var_metadataRoot/eainfo">
Entity_and_Attribute_Information: <xsl:for-each select="detailed">
Detailed_Description: <xsl:for-each select="enttyp">
Entity_Type: <xsl:for-each select="enttypl">
	Entity_Label:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="enttypd">
		Entity_Definition:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="enttypds">
		Definition_Source:  <xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="attr">
		Attribute: <xsl:for-each select="attrlabl">
			Attribute_Label:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="attrdef">
			Attribute_Definition: <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="attrdefs">
			Attribute_Definition_Source:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="attrdomv">
			Attribute_Domain_Values: <xsl:for-each select="edom">
				Enumerated_Domain: <xsl:for-each select="edomv">
					Enumerated_Domain_Value: <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="edomvd">
					Enumerated_Domain_Value_Definition:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="edomvds">
					Enumerated_Domain_Value_Definition_Source:  <xsl:value-of select="."/>
														</xsl:for-each>
						Domain Value Attribute: <xsl:apply-templates select="attr"/>
													</xsl:for-each>
													<!-- end enumerated domain -->
													<xsl:for-each select="rdom">
				Range_Domain: <xsl:for-each select="rdommin">
					Range_Domain_Minimum:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="rdommax">
					Range_Domain_Maximum:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="attrunit">
					Attribute_Units_of_Measure:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="attrmres">
					Attribute_Measurement_Resolution:  <xsl:value-of select="."/>
														</xsl:for-each>
						Range Domain Attribute: <xsl:apply-templates select="attr"/>
													</xsl:for-each>
													<xsl:for-each select="codesetd">
				Codeset_Domain: <xsl:for-each select="codesetn">
						Codeset_Name:  <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="codesets">
						Codeset_Source:  <xsl:value-of select="."/>
														</xsl:for-each>
													</xsl:for-each>
													<xsl:for-each select="udom">
				Unrepresentable_Domain:  <xsl:value-of select="."/>
													</xsl:for-each>
												</xsl:for-each>
												<xsl:for-each select="begdatea">
Beginning_Date_of_Attribute_Values:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="enddatea">
Ending_Date_of_Attribute_Values:  <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="attrvai">
Attribute_Value_Accuracy_Information: <xsl:for-each select="attrva">
	Attribute_Value_Accuracy:  <xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="attrvae">
	Attribute_Value_Accuracy_Explanation: <xsl:value-of select="."/>
													</xsl:for-each>
												</xsl:for-each>
												<xsl:for-each select="attrmfrq">
Attribute_Measurement_Frequency:  <xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
										</xsl:for-each>
										<xsl:for-each select="overview">
Overview_Description: <xsl:for-each select="eaover">
		Entity_and_Attribute_Overview:  <xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="eadetcit">
		Entity_and_Attribute_Detail_Citation:  <xsl:value-of select="."/>
											</xsl:for-each>
										</xsl:for-each>
									</xsl:for-each>
									<!-- end of Entity Attribute section text blob, end of text for abstract element -->
									<!--  /xsl:template -->
								</gco:CharacterString>
							</gmd:abstract>
							<!-- /xsl:for-each -->
							<xsl:for-each select="descript/purpose">
								<gmd:purpose>
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
									</gco:CharacterString>
								</gmd:purpose>
							</xsl:for-each>
							<xsl:for-each select="datacred">
								<gmd:credit>
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
									</gco:CharacterString>
								</gmd:credit>
							</xsl:for-each>
							<gmd:status>
								<!-- xsl:variable name="var395_map_select_status" as="xs:string*">
									<xsl:for-each select="status/progress">
										<xsl:sequence select="xs:string(.)"/>
									</xsl:for-each>
								</xsl:variable -->
								<xsl:variable name="var_checkHasStatusProgress" as="xs:string?">
									<xsl:choose>
										<xsl:when test="fn:exists(status/progress)">
											<xsl:variable name="var_checkStatusProgress" as="xs:string*">
												<xsl:for-each select="status/progress">
													<xsl:variable name="var_checkStatusTypeLookup" as="xs:string?">
														<xsl:call-template name="vmf:statusType">
															<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(.)))"/>
														</xsl:call-template>
													</xsl:variable>
													<xsl:if test="fn:exists($var_checkStatusTypeLookup)">
														<xsl:sequence select="$var_checkStatusTypeLookup"/>
													</xsl:if>
												</xsl:for-each>
											</xsl:variable>
											<xsl:if test="fn:exists($var_checkStatusProgress)">
												<xsl:sequence select="xs:string(fn:string-join($var_checkStatusProgress, ' '))"/>
											</xsl:if>
										</xsl:when>
										<xsl:otherwise>
											<xsl:sequence select="''"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:for-each select="$var_checkHasStatusProgress">
									<gmd:MD_ProgressCode>
										<xsl:attribute name="codeList"><xsl:variable name="var381_map_select_status" as="xs:string*"><xsl:for-each select="$var_idinfoSourceNode/status/progress"><xsl:sequence select="xs:string(.)"/></xsl:for-each></xsl:variable><xsl:variable name="var380_cond_result_exists" as="xs:string" select="(if (fn:exists($var381_map_select_status)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ProgressCode' else '')"/><xsl:sequence select="xs:string(xs:anyURI($var380_cond_result_exists))"/></xsl:attribute>
										<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI(.))"/></xsl:attribute>
										<xsl:variable name="var387_map_select_status" as="xs:string*">
											<xsl:for-each select="$var_idinfoSourceNode/status/progress">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:variable>
										<xsl:variable name="var384_cond_result_exists" as="xs:string?">
											<xsl:choose>
												<xsl:when test="fn:exists($var387_map_select_status)">
													<xsl:variable name="var389_map_select_status" as="xs:string*">
														<xsl:for-each select="$var_idinfoSourceNode/status/progress">
															<xsl:variable name="var392_result_statusCode" as="xs:string?">
																<xsl:call-template name="vmf:statusCode">
																	<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(.)))"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:if test="fn:exists($var392_result_statusCode)">
																<xsl:sequence select="$var392_result_statusCode"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:if test="fn:exists($var389_map_select_status)">
														<xsl:sequence select="xs:string(fn:string-join($var389_map_select_status, ' '))"/>
													</xsl:if>
												</xsl:when>
												<xsl:otherwise>
													<xsl:sequence select="''"/>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<xsl:for-each select="$var384_cond_result_exists">
											<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI(.))"/></xsl:attribute>
										</xsl:for-each>
										<xsl:sequence select="."/>
									</gmd:MD_ProgressCode>
								</xsl:for-each>
							</gmd:status>
							<xsl:for-each select="ptcontac">
								<gmd:pointOfContact>
									<!-- ptcontac/cntinfo -->
									<xsl:for-each select="cntinfo">
										<!-- xsl:variable name="var_ptcontac-cntinfo_node" as="node()" select="."/ -->
										<gmd:CI_ResponsibleParty>
											<!-- gmd:individualName -->
											<xsl:variable name="var_cntIndividualName" as="xs:string*">
												<xsl:choose>
													<xsl:when test="fn:exists(cntperp/cntper)">
														<xsl:for-each select="cntperp/cntper">
															<xsl:sequence select="xs:string(.)"/>
														</xsl:for-each>
													</xsl:when>
													<xsl:otherwise>
														<xsl:for-each select="cntorgp/cntper">
															<xsl:sequence select="xs:string(.)"/>
														</xsl:for-each>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:variable>
											<xsl:variable name="var_cntOrgName" as="xs:string*">
												<xsl:choose>
													<xsl:when test="fn:exists(cntperp/cntorg)">
														<xsl:for-each select="cntperp/cntorg">
															<xsl:sequence select="xs:string(.)"/>
														</xsl:for-each>
													</xsl:when>
													<xsl:otherwise>
														<xsl:for-each select="cntorgp/cntorg">
															<xsl:sequence select="xs:string(.)"/>
														</xsl:for-each>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:variable>
											<xsl:call-template name="usgin:contactName">
												<xsl:with-param name="inputPersonNode" select="$var_cntIndividualName"/>
												<xsl:with-param name="inputOrganizationNode" select="$var_cntOrgName"/>
												<xsl:with-param name="inputPositionNode" select="cntpos"/>
											</xsl:call-template>
											<gmd:contactInfo>
												<gmd:CI_Contact>
													<xsl:call-template name="usgin:telephoneFormat">
														<xsl:with-param name="telNode" select="(.)"/>
													</xsl:call-template>
													<!--gmd:phone>
														<gmd:CI_Telephone>
															<gmd:voice>
																<xsl:for-each select="cntvoice">
																	<gco:CharacterString>
																		<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</xsl:for-each>
															</gmd:voice>
															<gmd:facsimile>
																<xsl:for-each select="cntfax">
																	<gco:CharacterString>
																		<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</xsl:for-each>
															</gmd:facsimile>
														</gmd:CI_Telephone>
													</gmd:phone -->
													<gmd:address>
														<gmd:CI_Address>
															<xsl:call-template name="usgin:addressFormat">
																<xsl:with-param name="inputAddr" select="cntaddr[1]"/>
															</xsl:call-template>
															<!-- done with postal address elements, now the e-mail. Set this up so that some value gets inserted -->
															<!-- xsl:for-each select="cntaddr/address">
																<gmd:deliveryPoint>
																	<gco:CharacterString>
																		<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</gmd:deliveryPoint>
															</xsl:for-each>
															<xsl:for-each select="cntaddr/city">
																<gmd:city>
																	<gco:CharacterString>
																		<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</gmd:city>
															</xsl:for-each>
															<xsl:for-each select="cntaddr/state">
																<gmd:administrativeArea>
																	<gco:CharacterString>
																		<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</gmd:administrativeArea>
															</xsl:for-each>
															<xsl:for-each select="cntaddr/postal">
																<gmd:postalCode>
																	<gco:CharacterString>
																		<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</gmd:postalCode>
															</xsl:for-each>
															<xsl:for-each select="cntaddr/country">
																<gmd:country>
																	<gco:CharacterString>
																		<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</gmd:coun try>
															</xsl:for-each -->
															<xsl:for-each select="cntemail">
																<xsl:call-template name="usgin:emailFormat">
																	<xsl:with-param name="emailNode" select="(.)"/>
																</xsl:call-template>
																<!-- gmd:electronicMailAddress>
																	<gco:CharacterString>
																		<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</gmd:electronicMailAddress -->
															</xsl:for-each>
														</gmd:CI_Address>
													</gmd:address>
													<xsl:for-each select="hours">
														<gmd:hoursOfService>
															<gco:CharacterString>
																<xsl:sequence select="xs:string(.)"/>
															</gco:CharacterString>
														</gmd:hoursOfService>
													</xsl:for-each>
													<xsl:for-each select="cntinst">
														<gmd:contactInstructions>
															<gco:CharacterString>
																<xsl:sequence select="xs:string(.)"/>
															</gco:CharacterString>
														</gmd:contactInstructions>
													</xsl:for-each>
												</gmd:CI_Contact>
											</gmd:contactInfo>
											<gmd:role>
												<gmd:CI_RoleCode>
													<xsl:attribute name="codeList"><xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/></xsl:attribute>
													<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI('pointOfContact'))"/></xsl:attribute>
													<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI('007'))"/></xsl:attribute>
													<xsl:sequence select="'pointOfContact'"/>
												</gmd:CI_RoleCode>
											</gmd:role>
										</gmd:CI_ResponsibleParty>
									</xsl:for-each>
								</gmd:pointOfContact>
							</xsl:for-each>
							<!-- +++ Resource maintenance section -->
							<gmd:resourceMaintenance>
								<gmd:MD_MaintenanceInformation>
									<gmd:maintenanceAndUpdateFrequency>
										<xsl:variable name="var338_result_vmf11_inputtoresult" as="xs:string?">
											<xsl:call-template name="vmf:updateFrequency">
												<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(status/update)))"/>
											</xsl:call-template>
										</xsl:variable>
										<xsl:variable name="var335_cond_result_exists" as="xs:string?" select="(if (fn:exists($var338_result_vmf11_inputtoresult)) then $var338_result_vmf11_inputtoresult else ())"/>
										<xsl:if test="fn:exists($var335_cond_result_exists)">
											<gmd:MD_MaintenanceFrequencyCode>
												<xsl:attribute name="codeList"><xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MaintenanceFrequencyCode'))"/></xsl:attribute>
												<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI($var335_cond_result_exists))"/></xsl:attribute>
												<xsl:variable name="var337_result_vmf12_inputtoresult" as="xs:string?">
													<xsl:call-template name="vmf:updateFrequencyCode">
														<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(idinfo/status/update))))"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:variable name="var336_cond_result_exists" as="xs:string?" select="(if (fn:exists($var337_result_vmf12_inputtoresult)) then $var337_result_vmf12_inputtoresult else ())"/>
												<xsl:if test="fn:exists($var336_cond_result_exists)">
													<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI($var336_cond_result_exists))"/></xsl:attribute>
												</xsl:if>
												<xsl:sequence select="$var335_cond_result_exists"/>
											</gmd:MD_MaintenanceFrequencyCode>
										</xsl:if>
									</gmd:maintenanceAndUpdateFrequency>
								</gmd:MD_MaintenanceInformation>
							</gmd:resourceMaintenance>
							<xsl:for-each select="$var_metadataRoot/eainfo/detailed/attr/attrmfrq">
								<gmd:resourceMaintenance>
									<gmd:MD_MaintenanceInformation>
										<gmd:maintenanceAndUpdateFrequency>
											<xsl:variable name="var344_result_vmf11_inputtoresult" as="xs:string?">
												<xsl:call-template name="vmf:updateFrequency">
													<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(.)))"/>
												</xsl:call-template>
											</xsl:variable>
											<xsl:variable name="var341_cond_result_exists" as="xs:string?" select="(if (fn:exists($var344_result_vmf11_inputtoresult)) then $var344_result_vmf11_inputtoresult else ())"/>
											<xsl:if test="fn:exists($var341_cond_result_exists)">
												<gmd:MD_MaintenanceFrequencyCode>
													<xsl:attribute name="codeList"><xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MaintenanceFrequencyCode'))"/></xsl:attribute>
													<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI($var341_cond_result_exists))"/></xsl:attribute>
													<xsl:variable name="var343_result_vmf12_inputtoresult" as="xs:string?">
														<xsl:call-template name="vmf:updateFrequencyCode">
															<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
														</xsl:call-template>
													</xsl:variable>
													<xsl:variable name="var342_cond_result_exists" as="xs:string?" select="(if (fn:exists($var343_result_vmf12_inputtoresult)) then $var343_result_vmf12_inputtoresult else ())"/>
													<xsl:if test="fn:exists($var342_cond_result_exists)">
														<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI($var342_cond_result_exists))"/></xsl:attribute>
													</xsl:if>
													<xsl:sequence select="$var341_cond_result_exists"/>
												</gmd:MD_MaintenanceFrequencyCode>
											</xsl:if>
										</gmd:maintenanceAndUpdateFrequency>
										<gmd:updateScope>
											<gmd:MD_ScopeCode>
												<xsl:attribute name="codeList"><xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode'))"/></xsl:attribute>
												<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI('attribute'))"/></xsl:attribute>
											</gmd:MD_ScopeCode>
										</gmd:updateScope>
									</gmd:MD_MaintenanceInformation>
								</gmd:resourceMaintenance>
							</xsl:for-each>
							<!-- Handle browse graphic if it exists -->
							<xsl:for-each select="browse">
								<gmd:graphicOverview>
									<gmd:MD_BrowseGraphic>
										<gmd:fileName>
											<xsl:for-each-group select="." group-by="xs:string(browsen)">
												<xsl:variable name="var349_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
												<gco:CharacterString>
													<xsl:sequence select="$var349_cur_result_groupby"/>
												</gco:CharacterString>
											</xsl:for-each-group>
										</gmd:fileName>
										<gmd:fileDescription>
											<gco:CharacterString>
												<xsl:sequence select="xs:string(browsed)"/>
											</gco:CharacterString>
										</gmd:fileDescription>
										<gmd:fileType>
											<gco:CharacterString>
												<xsl:sequence select="xs:string(xs:string(browset))"/>
											</gco:CharacterString>
										</gmd:fileType>
									</gmd:MD_BrowseGraphic>
								</gmd:graphicOverview>
							</xsl:for-each>
							<!-- handle Keywords, grouped by theme with a thesaurus element for each theme -->
							<!-- if ...kt (keyword thesaurus) is missing, fgdc xml should be invalid, but in real world... -->
							<xsl:choose>
								<xsl:when test="fn:exists(keywords/theme/themekt)">
									<xsl:for-each-group select="keywords/theme" group-by="(if (fn:contains(xs:string(themekt), 'ISO 19115')) then () else xs:string(themekt))">
										<xsl:variable name="var352_cur_result_groupby" as="item()+" select="current-group()"/>
										<xsl:variable name="var353_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
										<gmd:descriptiveKeywords>
											<gmd:MD_Keywords>
												<xsl:for-each select="$var352_cur_result_groupby/themekey">
													<gmd:keyword>
														<gco:CharacterString>
															<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
														</gco:CharacterString>
													</gmd:keyword>
												</xsl:for-each>
												<gmd:type>
													<gmd:MD_KeywordTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode" codeListValue="theme" codeSpace="005">
														<xsl:sequence select="'theme'"/>
													</gmd:MD_KeywordTypeCode>
												</gmd:type>
												<gmd:thesaurusName>
													<gmd:CI_Citation>
														<gmd:title>
															<gco:CharacterString>
																<xsl:sequence select="fn:normalize-space($var353_cur_result_groupby)"/>
															</gco:CharacterString>
														</gmd:title>
														<gmd:date>
															<xsl:attribute name="gco:nilReason"><xsl:sequence select="xs:string('unknown')"/></xsl:attribute>
														</gmd:date>
													</gmd:CI_Citation>
												</gmd:thesaurusName>
											</gmd:MD_Keywords>
										</gmd:descriptiveKeywords>
									</xsl:for-each-group>
								</xsl:when>
								<!-- thesaurus name is missing... -->
								<xsl:otherwise>
									<xsl:for-each select="keywords/theme">
										<gmd:descriptiveKeywords>
											<gmd:MD_Keywords>
												<xsl:for-each select="themekey">
													<gmd:keyword>
														<gco:CharacterString>
															<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
														</gco:CharacterString>
													</gmd:keyword>
												</xsl:for-each>
												<gmd:type>
													<gmd:MD_KeywordTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode" codeListValue="theme" codeSpace="005">
														<xsl:sequence select="'theme'"/>
													</gmd:MD_KeywordTypeCode>
												</gmd:type>
												<gmd:thesaurusName gco:nilReason="missing"/>
											</gmd:MD_Keywords>
										</gmd:descriptiveKeywords>
									</xsl:for-each>
								</xsl:otherwise>
							</xsl:choose>
							<!-- place keywords -->
							<xsl:choose>
								<xsl:when test="fn:exists(keywords/place/placekt)">
									<xsl:for-each-group select="keywords/place" group-by="xs:string(xs:string(placekt))">
										<xsl:variable name="var_placeKeywordList" as="item()+" select="current-group()"/>
										<xsl:variable name="var_placeGroupKeyValue" as="xs:string" select="current-grouping-key()"/>
										<gmd:descriptiveKeywords>
											<gmd:MD_Keywords>
												<xsl:for-each select="$var_placeKeywordList/placekey">
													<gmd:keyword>
														<gco:CharacterString>
															<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
														</gco:CharacterString>
													</gmd:keyword>
												</xsl:for-each>
												<gmd:type>
													<gmd:MD_KeywordTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode" codeListValue="place" codeSpace="002">
														<xsl:sequence select="'place'"/>
													</gmd:MD_KeywordTypeCode>
												</gmd:type>
												<gmd:thesaurusName>
													<gmd:CI_Citation>
														<gmd:title>
															<gco:CharacterString>
																<xsl:sequence select="fn:normalize-space($var_placeGroupKeyValue)"/>
															</gco:CharacterString>
														</gmd:title>
														<gmd:date>
															<xsl:attribute name="gco:nilReason"><xsl:sequence select="xs:string('unknown')"/></xsl:attribute>
														</gmd:date>
													</gmd:CI_Citation>
												</gmd:thesaurusName>
											</gmd:MD_Keywords>
										</gmd:descriptiveKeywords>
									</xsl:for-each-group>
								</xsl:when>
								<xsl:otherwise>
									<!-- no thesaurus -->
									<xsl:for-each select="keywords/place">
										<gmd:descriptiveKeywords>
											<gmd:MD_Keywords>
												<xsl:for-each select="placekey">
													<gmd:keyword>
														<gco:CharacterString>
															<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
														</gco:CharacterString>
													</gmd:keyword>
												</xsl:for-each>
												<gmd:type>
													<gmd:MD_KeywordTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode" codeListValue="place" codeSpace="002">
														<xsl:sequence select="'place'"/>
													</gmd:MD_KeywordTypeCode>
												</gmd:type>
												<gmd:thesaurusName gco:nilReason="missing"/>
											</gmd:MD_Keywords>
										</gmd:descriptiveKeywords>
									</xsl:for-each>
								</xsl:otherwise>
							</xsl:choose>
							<!-- stratum keywords -->
							<!-- alternate logic for thesaurus name -->
							<!--xsl:for-each-group select="keywords/stratum" group-by="xs:string(xs:string(stratkt))">
								<xsl:variable name="var364_cur_result_groupby" as="item()+" select="current-group()"/>
								<xsl:variable name="var365_cur_result_groupby" as="xs:string" select="current-grouping-key()"/ -->
							<xsl:for-each select="keywords/stratum">
								<gmd:descriptiveKeywords>
									<gmd:MD_Keywords>
										<xsl:for-each select="stratkey">
											<gmd:keyword>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
												</gco:CharacterString>
											</gmd:keyword>
										</xsl:for-each>
										<gmd:type>
											<gmd:MD_KeywordTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode" codeListValue="stratum" codeSpace="003">
												<xsl:sequence select="'stratum'"/>
											</gmd:MD_KeywordTypeCode>
										</gmd:type>
										<xsl:choose>
											<xsl:when test="fn:exists(stratkt)">
												<gmd:thesaurusName>
													<gmd:CI_Citation>
														<gmd:title>
															<gco:CharacterString>
																<xsl:sequence select="fn:normalize-space(xs:string(stratkt))"/>
															</gco:CharacterString>
														</gmd:title>
														<gmd:date>
															<xsl:attribute name="gco:nilReason"><xsl:sequence select="xs:string(xs:string('unknown'))"/></xsl:attribute>
														</gmd:date>
													</gmd:CI_Citation>
												</gmd:thesaurusName>
											</xsl:when>
											<xsl:otherwise>
												<gmd:thesaurusName gco:nilReason="missing"/>
											</xsl:otherwise>
										</xsl:choose>
									</gmd:MD_Keywords>
								</gmd:descriptiveKeywords>
							</xsl:for-each>
							<xsl:if test="fn:string-length(xs:string(keywords/temporal[1]/tempkey[1]))>0">
								<xsl:for-each select="keywords/temporal">
									<!--xsl:variable name="var370_cur_result_groupby" as="item()+" select="current-group()"/>
								<xsl:variable name="var371_cur_result_groupby" as="xs:string" select="current-grouping-key()"/ -->
									<gmd:descriptiveKeywords>
										<gmd:MD_Keywords>
											<xsl:for-each select="tempkey">
												<gmd:keyword>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</gmd:keyword>
											</xsl:for-each>
											<gmd:type>
												<gmd:MD_KeywordTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode" codeListValue="temporal" codeSpace="004">
													<xsl:sequence select="'temporal'"/>
												</gmd:MD_KeywordTypeCode>
											</gmd:type>
											<xsl:choose>
												<xsl:when test="fn:exists(tempkt)">
													<gmd:thesaurusName>
														<gmd:CI_Citation>
															<gmd:title>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(tempkt))"/>
																</gco:CharacterString>
															</gmd:title>
															<gmd:date>
																<xsl:attribute name="gco:nilReason"><xsl:sequence select="xs:string(xs:string('unknown'))"/></xsl:attribute>
															</gmd:date>
														</gmd:CI_Citation>
													</gmd:thesaurusName>
												</xsl:when>
												<xsl:otherwise>
													<gmd:thesaurusName gco:nilReason="missing"/>
												</xsl:otherwise>
											</xsl:choose>
										</gmd:MD_Keywords>
									</gmd:descriptiveKeywords>
								</xsl:for-each>
							</xsl:if>
							<!-- resource constraints section, distribution liability, access constraint, and use constraints get concatenated into a single gmd:useConstraint 
								text blob -->
							<xsl:variable name="var_distributionLiability_exists" as="xs:string?">
								<xsl:if test="fn:exists($var_metadataRoot/distinfo/distliab)">
									<xsl:sequence select="fn:concat('Distribution Liability: ', fn:string-join($var_metadataRoot/distinfo/distliab, ' '))"/>
								</xsl:if>
							</xsl:variable>
							<xsl:variable name="var_accessConstraints_exists" as="xs:string?">
								<xsl:if test="fn:exists(accconst)">
									<xsl:sequence select="fn:concat('Access Constraints: ', fn:string-join($var_metadataRoot//idinfo/accconst, ' '))"/>
								</xsl:if>
							</xsl:variable>
							<xsl:variable name="var_useLimitation_exists" as="xs:string?">
								<xsl:if test="fn:exists(useconst)">
									<xsl:sequence select="fn:concat('Use Limitation: ', fn:string-join($var_metadataRoot/idinfo/useconst, ' '))"/>
								</xsl:if>
							</xsl:variable>
							<xsl:if test="fn:exists($var_distributionLiability_exists) or fn:exists($var_accessConstraints_exists) or fn:exists($var_useLimitation_exists)">
								<gmd:resourceConstraints>
									<gmd:MD_LegalConstraints>
										<xsl:if test="fn:exists($var_accessConstraints_exists)">
											<gmd:accessConstraints>
												<gmd:MD_RestrictionCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode" codeListValue="otherRestrictions" codeSpace="008">
													<xsl:sequence select="'otherRestrictions'"/>
												</gmd:MD_RestrictionCode>
											</gmd:accessConstraints>
										</xsl:if>
										<xsl:if test="fn:exists($var_useLimitation_exists)">
											<gmd:useConstraints>
												<gmd:MD_RestrictionCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode" codeListValue="otherRestrictions" codeSpace="008">
													<xsl:sequence select="'otherRestrictions'"/>
												</gmd:MD_RestrictionCode>
											</gmd:useConstraints>
										</xsl:if>
										<gmd:otherConstraints>
											<gco:CharacterString>
												<xsl:value-of select="fn:normalize-space(fn:concat( $var_accessConstraints_exists, ' ',   $var_useLimitation_exists, ' ',   $var_distributionLiability_exists))"/>
											</gco:CharacterString>
										</gmd:otherConstraints>
									</gmd:MD_LegalConstraints>
								</gmd:resourceConstraints>
							</xsl:if>
							<xsl:for-each select="secinfo">
								<gmd:resourceConstraints>
									<gmd:MD_SecurityConstraints>
										<gmd:classification>
											<xsl:variable name="var388_result_securityClassType" as="xs:string?">
												<xsl:call-template name="vmf:securityClassType">
													<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(secclass)))"/>
												</xsl:call-template>
											</xsl:variable>
											<xsl:variable name="var385_cond_result_exists" as="xs:string?" select="(if (fn:exists($var388_result_securityClassType)) then $var388_result_securityClassType else ())"/>
											<xsl:if test="fn:exists($var385_cond_result_exists)">
												<gmd:MD_ClassificationCode>
													<xsl:attribute name="codeList"><xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ClassificationCode'))"/></xsl:attribute>
													<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI($var385_cond_result_exists))"/></xsl:attribute>
													<xsl:variable name="var387_result_securityClassCode" as="xs:string?">
														<xsl:call-template name="vmf:securityClassCode">
															<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(secclass))))"/>
														</xsl:call-template>
													</xsl:variable>
													<xsl:variable name="var386_cond_result_exists" as="xs:string?" select="(if (fn:exists($var387_result_securityClassCode)) then $var387_result_securityClassCode else ())"/>
													<xsl:if test="fn:exists($var386_cond_result_exists)">
														<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI($var386_cond_result_exists))"/></xsl:attribute>
													</xsl:if>
													<xsl:sequence select="$var385_cond_result_exists"/>
												</gmd:MD_ClassificationCode>
											</xsl:if>
										</gmd:classification>
										<gmd:classificationSystem>
											<gco:CharacterString>
												<xsl:sequence select="xs:string(secsys)"/>
											</gco:CharacterString>
										</gmd:classificationSystem>
										<gmd:handlingDescription>
											<gco:CharacterString>
												<xsl:sequence select="xs:string(sechandl)"/>
											</gco:CharacterString>
										</gmd:handlingDescription>
									</gmd:MD_SecurityConstraints>
								</gmd:resourceConstraints>
							</xsl:for-each>
							<!--  put in relationships to larger work and cross references using gmd:aggregationInfo elements -->
							<xsl:if test="fn:exists(citation/citeinfo/lworkcit)">
								<xsl:for-each select="citation/citeinfo/lworkcit">
									<xsl:variable name="var_largerWorkCitationNode" as="node()" select="."/>
									<gmd:aggregationInfo>
										<gmd:MD_AggregateInformation>
											<gmd:aggregateDataSetName>
												<gmd:CI_Citation>
													<gmd:title>
														<xsl:for-each select="citeinfo/title">
															<gco:CharacterString>
																<xsl:sequence select="xs:string(.)"/>
															</gco:CharacterString>
														</xsl:for-each>
													</gmd:title>
													<gmd:date>
														<gmd:CI_Date>
															<gmd:date>
																<xsl:call-template name="usgin:dateFormat">
																	<xsl:with-param name="inputDate" select="citeinfo/pubdate"/>
																	<xsl:with-param name="inputTime" select="citeinfo/pubtime"/>
																</xsl:call-template>
															</gmd:date>
															<gmd:dateType>
																<xsl:variable name="var647_cond_result_exists" as="xs:string?" select="(if (fn:exists(citeinfo/pubdate)) then 'publication' else ())"/>
																<xsl:if test="fn:exists($var647_cond_result_exists)">
																	<gmd:CI_DateTypeCode>
																		<xsl:variable name="var648_cond_result_exists" as="xs:string?" select="(if (fn:exists(citeinfo/pubdate)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode' else ())"/>
																		<xsl:if test="fn:exists($var648_cond_result_exists)">
																			<xsl:attribute name="codeList"><xsl:sequence select="xs:string(xs:anyURI($var648_cond_result_exists))"/></xsl:attribute>
																		</xsl:if>
																		<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI($var647_cond_result_exists))"/></xsl:attribute>
																		<xsl:variable name="var649_cond_result_exists" as="xs:string?" select="(if (fn:exists(citeinfo/pubdate)) then '002' else ())"/>
																		<xsl:if test="fn:exists($var649_cond_result_exists)">
																			<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI($var649_cond_result_exists))"/></xsl:attribute>
																		</xsl:if>
																		<xsl:sequence select="$var647_cond_result_exists"/>
																	</gmd:CI_DateTypeCode>
																</xsl:if>
															</gmd:dateType>
														</gmd:CI_Date>
													</gmd:date>
													<gmd:edition>
														<xsl:for-each select="citeinfo/edition">
															<gco:CharacterString>
																<xsl:sequence select="xs:string(.)"/>
															</gco:CharacterString>
														</xsl:for-each>
													</gmd:edition>
													<gmd:citedResponsibleParty>
														<gmd:CI_ResponsibleParty>
															<gmd:organisationName>
																<!-- xsl:for-each select="citeinfo/origin" -->
																<gco:CharacterString>
																	<xsl:variable name="orgCount" as="xs:integer">
																		<xsl:value-of select="xs:integer(fn:count(citeinfo/origin))"/>
																	</xsl:variable>
																	<xsl:for-each select="citeinfo/origin">
																		<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																		<xsl:if test="($orgCount>1)">
																			<xsl:value-of select="xs:string(' ')"/>
																		</xsl:if>
																	</xsl:for-each>
																</gco:CharacterString>
																<!-- /xsl:for-each -->
															</gmd:organisationName>
															<gmd:role>
																<gmd:CI_RoleCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode" codeListValue="originator" codeSpace="006">
																	<xsl:sequence select="'originator'"/>
																</gmd:CI_RoleCode>
															</gmd:role>
														</gmd:CI_ResponsibleParty>
													</gmd:citedResponsibleParty>
													<gmd:presentationForm>
														<xsl:variable name="var672_map_select_citeinfo" as="xs:string*">
															<xsl:for-each select="citeinfo/geoform">
																<xsl:sequence select="xs:string(.)"/>
															</xsl:for-each>
														</xsl:variable>
														<xsl:variable name="var654_cond_result_exists" as="xs:string?">
															<xsl:choose>
																<xsl:when test="fn:exists($var672_map_select_citeinfo)">
																	<xsl:variable name="var674_map_select_citeinfo" as="xs:string*">
																		<xsl:for-each select="citeinfo/geoform">
																			<xsl:variable name="var677_result_statusType" as="xs:string?">
																				<xsl:call-template name="vmf:statusType">
																					<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(.)))"/>
																				</xsl:call-template>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var677_result_statusType)">
																				<xsl:sequence select="$var677_result_statusType"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var674_map_select_citeinfo)">
																		<xsl:sequence select="xs:string(fn:string-join($var674_map_select_citeinfo, ' '))"/>
																	</xsl:if>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:sequence select="''"/>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:variable>
														<xsl:for-each select="$var654_cond_result_exists">
															<gmd:CI_PresentationFormCode>
																<xsl:attribute name="codeList"><xsl:variable name="var658_map_select_citeinfo" as="xs:string*"><xsl:for-each select="$var_largerWorkCitationNode/citeinfo/geoform"><xsl:sequence select="xs:string(.)"/></xsl:for-each></xsl:variable><xsl:variable name="var657_cond_result_exists" as="xs:string" select="(if (fn:exists($var658_map_select_citeinfo)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ProgressCode' else '')"/><xsl:sequence select="xs:string(xs:anyURI($var657_cond_result_exists))"/></xsl:attribute>
																<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI(.))"/></xsl:attribute>
																<xsl:variable name="var664_map_select_citeinfo" as="xs:string*">
																	<xsl:for-each select="$var_largerWorkCitationNode/citeinfo/geoform">
																		<xsl:sequence select="xs:string(.)"/>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:variable name="var661_cond_result_exists" as="xs:string?">
																	<xsl:choose>
																		<xsl:when test="fn:exists($var664_map_select_citeinfo)">
																			<xsl:variable name="var666_map_select_citeinfo" as="xs:string*">
																				<xsl:for-each select="$var_largerWorkCitationNode/citeinfo/geoform">
																					<xsl:variable name="var669_result_statusCode" as="xs:string?">
																						<xsl:call-template name="vmf:statusCode">
																							<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(.)))"/>
																						</xsl:call-template>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var669_result_statusCode)">
																						<xsl:sequence select="$var669_result_statusCode"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var666_map_select_citeinfo)">
																				<xsl:sequence select="xs:string(fn:string-join($var666_map_select_citeinfo, ' '))"/>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:sequence select="''"/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:for-each select="$var661_cond_result_exists">
																	<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI(.))"/></xsl:attribute>
																</xsl:for-each>
																<xsl:sequence select="."/>
															</gmd:CI_PresentationFormCode>
														</xsl:for-each>
													</gmd:presentationForm>
													<xsl:for-each select="citeinfo/serinfo">
														<gmd:series>
															<gmd:CI_Series>
																<gmd:name>
																	<xsl:for-each select="sername">
																		<gco:CharacterString>
																			<xsl:sequence select="xs:string(.)"/>
																		</gco:CharacterString>
																	</xsl:for-each>
																</gmd:name>
																<gmd:issueIdentification>
																	<xsl:for-each select="issue">
																		<gco:CharacterString>
																			<xsl:sequence select="xs:string(.)"/>
																		</gco:CharacterString>
																	</xsl:for-each>
																</gmd:issueIdentification>
															</gmd:CI_Series>
														</gmd:series>
													</xsl:for-each>
													<gmd:otherCitationDetails>
														<xsl:for-each select="citeinfo/othercit">
															<gco:CharacterString>
																<xsl:sequence select="xs:string(.)"/>
															</gco:CharacterString>
														</xsl:for-each>
													</gmd:otherCitationDetails>
												</gmd:CI_Citation>
											</gmd:aggregateDataSetName>
											<gmd:associationType>
												<!-- xsl:variable name="var688_cond_result_exists" as="xs:string?" select="(if (fn:exists(citeinfo/origin)) then 'largerWorkCitation' else ())"/>
												<xsl:if test="fn:exists($var688_cond_result_exists)" -->
												<gmd:DS_AssociationTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode" codeListValue="largerWorkCitation" codeSpace="002">
													<!--xsl:variable name="var689_cond_result_exists" as="xs:string?">
															<xsl:if test="fn:exists(citeinfo/origin)">
																<xsl:variable name="var691_cond_result_exists" as="xs:string?" select="(if (fn:exists(citeinfo/origin)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode' else ())"/>
																<xsl:if test="fn:exists($var691_cond_result_exists)">
																	<xsl:sequence select="$var691_cond_result_exists"/>
																</xsl:if>
															</xsl:if>
														</xsl:variable>
														<xsl:if test="fn:exists($var689_cond_result_exists)">
															<xsl:attribute name="codeList"><xsl:sequence select="xs:string(xs:anyURI($var689_cond_result_exists))"/></xsl:attribute>
														</xsl:if>
														<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI($var688_cond_result_exists))"/></xsl:attribute>
														<xsl:variable name="var692_cond_result_exists" as="xs:string?" select="(if (fn:exists(citeinfo/origin)) then '002' else ())"/>
														<xsl:if test="fn:exists($var692_cond_result_exists)">
															<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI($var692_cond_result_exists))"/></xsl:attribute>
														</xsl:if -->
													<xsl:value-of select="largerWorkCitation"/>
												</gmd:DS_AssociationTypeCode>
												<!--/xsl:if -->
											</gmd:associationType>
										</gmd:MD_AggregateInformation>
									</gmd:aggregationInfo>
								</xsl:for-each>
							</xsl:if>
							<xsl:if test="fn:exists(crossref)">
								<xsl:for-each select="crossref">
									<gmd:aggregationInfo>
										<gmd:MD_AggregateInformation>
											<xsl:variable name="var693_crossref" as="node()" select="."/>
											<gmd:aggregateDataSetName>
												<gmd:CI_Citation>
													<gmd:title>
														<xsl:for-each select="citeinfo/title">
															<gco:CharacterString>
																<xsl:sequence select="xs:string(.)"/>
															</gco:CharacterString>
														</xsl:for-each>
													</gmd:title>
													<gmd:date>
														<gmd:CI_Date>
															<gmd:date>
																<xsl:call-template name="usgin:dateFormat">
																	<xsl:with-param name="inputDate" select="citeinfo/pubdate"/>
																	<xsl:with-param name="inputTime" select="citeinfo/pubtime"/>
																</xsl:call-template>
															</gmd:date>
															<gmd:dateType>
																<xsl:variable name="var733_cond_result_exists" as="xs:string?" select="(if (fn:exists(citeinfo/pubdate)) then 'publication' else ())"/>
																<xsl:if test="fn:exists($var733_cond_result_exists)">
																	<gmd:CI_DateTypeCode>
																		<xsl:variable name="var734_cond_result_exists" as="xs:string?" select="(if (fn:exists(citeinfo/pubdate)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode' else ())"/>
																		<xsl:if test="fn:exists($var734_cond_result_exists)">
																			<xsl:attribute name="codeList"><xsl:sequence select="xs:string(xs:anyURI($var734_cond_result_exists))"/></xsl:attribute>
																		</xsl:if>
																		<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI($var733_cond_result_exists))"/></xsl:attribute>
																		<xsl:variable name="var735_cond_result_exists" as="xs:string?" select="(if (fn:exists(citeinfo/pubdate)) then '002' else ())"/>
																		<xsl:if test="fn:exists($var735_cond_result_exists)">
																			<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI($var735_cond_result_exists))"/></xsl:attribute>
																		</xsl:if>
																		<xsl:sequence select="$var733_cond_result_exists"/>
																	</gmd:CI_DateTypeCode>
																</xsl:if>
															</gmd:dateType>
														</gmd:CI_Date>
													</gmd:date>
													<gmd:edition>
														<xsl:for-each select="citeinfo/edition">
															<gco:CharacterString>
																<xsl:sequence select="xs:string(.)"/>
															</gco:CharacterString>
														</xsl:for-each>
													</gmd:edition>
													<gmd:citedResponsibleParty>
														<gmd:CI_ResponsibleParty>
															<gmd:organisationName>
																<!--	<xsl:for-each select="citeinfo/origin"> -->
																<gco:CharacterString>
																	<xsl:variable name="orgCount" as="xs:integer">
																		<xsl:value-of select="xs:integer(fn:count(citeinfo/origin))"/>
																	</xsl:variable>
																	<xsl:for-each select="citeinfo/origin">
																		<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																		<xsl:if test="($orgCount>1)">
																			<xsl:value-of select="xs:string(' ')"/>
																		</xsl:if>
																	</xsl:for-each>
																</gco:CharacterString>
																<!--/xsl:for-each> -->
															</gmd:organisationName>
															<gmd:role>
																<gmd:CI_RoleCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode" codeListValue="originator" codeSpace="006">
																	<xsl:sequence select="'originator'"/>
																</gmd:CI_RoleCode>
															</gmd:role>
														</gmd:CI_ResponsibleParty>
													</gmd:citedResponsibleParty>
													<gmd:presentationForm>
														<xsl:variable name="var740_cond_result_exists" as="xs:string?">
															<xsl:choose>
																<xsl:when test="fn:exists(citeinfo/geoform)">
																	<xsl:variable name="var754_map_select_citeinfo" as="xs:string*">
																		<xsl:for-each select="citeinfo/geoform">
																			<xsl:variable name="var757_result_docType" as="xs:string?">
																				<xsl:call-template name="vmf:docType">
																					<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																				</xsl:call-template>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var757_result_docType)">
																				<xsl:sequence select="$var757_result_docType"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var754_map_select_citeinfo)">
																		<xsl:sequence select="xs:string(fn:string-join($var754_map_select_citeinfo, ' '))"/>
																	</xsl:if>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:variable name="var758_map_select_citeinfo" as="xs:string*">
																		<xsl:for-each select="citeinfo/geoform">
																			<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var758_map_select_citeinfo)">
																		<xsl:sequence select="xs:string(fn:string-join($var758_map_select_citeinfo, ' '))"/>
																	</xsl:if>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:variable>
														<xsl:for-each select="$var740_cond_result_exists">
															<gmd:CI_PresentationFormCode>
																<xsl:variable name="var743_cond_result_exists" as="xs:string?" select="(if (fn:exists($var693_crossref/citeinfo/geoform)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode' else ())"/>
																<xsl:if test="fn:exists($var743_cond_result_exists)">
																	<xsl:attribute name="codeList"><xsl:sequence select="xs:string(xs:anyURI($var743_cond_result_exists))"/></xsl:attribute>
																</xsl:if>
																<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI(.))"/></xsl:attribute>
																<xsl:variable name="var744_cond_result_exists" as="xs:string?">
																	<xsl:if test="fn:exists($var693_crossref/citeinfo/geoform)">
																		<xsl:variable name="var748_map_select_citeinfo" as="xs:string*">
																			<xsl:for-each select="$var693_crossref/citeinfo/geoform">
																				<xsl:variable name="var751_result_docCode" as="xs:string?">
																					<xsl:call-template name="vmf:docCode">
																						<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var751_result_docCode)">
																					<xsl:sequence select="$var751_result_docCode"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var748_map_select_citeinfo)">
																			<xsl:sequence select="xs:string(fn:string-join($var748_map_select_citeinfo, ' '))"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:variable>
																<xsl:for-each select="$var744_cond_result_exists">
																	<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI(.))"/></xsl:attribute>
																</xsl:for-each>
																<xsl:sequence select="."/>
															</gmd:CI_PresentationFormCode>
														</xsl:for-each>
													</gmd:presentationForm>
													<gmd:series>
														<gmd:CI_Series>
															<gmd:name>
																<xsl:for-each select="citeinfo/serinfo/sername">
																	<gco:CharacterString>
																		<xsl:sequence select="xs:string(.)"/>
																	</gco:CharacterString>
																</xsl:for-each>
															</gmd:name>
															<gmd:issueIdentification>
																<xsl:for-each select="citeinfo/serinfo/issue">
																	<gco:CharacterString>
																		<xsl:sequence select="xs:string(.)"/>
																	</gco:CharacterString>
																</xsl:for-each>
															</gmd:issueIdentification>
														</gmd:CI_Series>
													</gmd:series>
													<gmd:otherCitationDetails>
														<xsl:for-each select="citeinfo/othercit">
															<gco:CharacterString>
																<xsl:sequence select="xs:string(.)"/>
															</gco:CharacterString>
														</xsl:for-each>
													</gmd:otherCitationDetails>
												</gmd:CI_Citation>
											</gmd:aggregateDataSetName>
											<!-- /xsl:for-each -->
											<gmd:associationType>
												<xsl:variable name="var767_cond_result_exists" as="xs:string?" select="(if (fn:exists($var_idinfoSourceNode/crossref/citeinfo/origin)) then 'crossReference' else ())"/>
												<xsl:if test="fn:exists($var767_cond_result_exists)">
													<gmd:DS_AssociationTypeCode>
														<xsl:variable name="var768_cond_result_exists" as="xs:string?">
															<xsl:if test="fn:exists($var_idinfoSourceNode/crossref/citeinfo/origin)">
																<xsl:variable name="var770_cond_result_exists" as="xs:string?" select="(if (fn:exists(citeinfo/origin)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode' else ())"/>
																<xsl:if test="fn:exists($var770_cond_result_exists)">
																	<xsl:sequence select="$var770_cond_result_exists"/>
																</xsl:if>
															</xsl:if>
														</xsl:variable>
														<xsl:if test="fn:exists($var768_cond_result_exists)">
															<xsl:attribute name="codeList"><xsl:sequence select="xs:string(xs:anyURI($var768_cond_result_exists))"/></xsl:attribute>
														</xsl:if>
														<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI($var767_cond_result_exists))"/></xsl:attribute>
														<xsl:variable name="var771_cond_result_exists" as="xs:string?" select="(if (fn:exists($var_idinfoSourceNode/crossref/citeinfo/origin)) then '001' else ())"/>
														<xsl:if test="fn:exists($var771_cond_result_exists)">
															<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI($var771_cond_result_exists))"/></xsl:attribute>
														</xsl:if>
														<xsl:sequence select="$var767_cond_result_exists"/>
													</gmd:DS_AssociationTypeCode>
												</xsl:if>
											</gmd:associationType>
										</gmd:MD_AggregateInformation>
									</gmd:aggregationInfo>
								</xsl:for-each>
							</xsl:if>
							<!-- ******************************************************************************************************************* -->
							<!-- Spatial Representation -->
							<xsl:for-each select="$var_metadataRoot/spdoinfo">
								<gmd:spatialRepresentationType>
									<xsl:for-each select="direct">
										<xsl:variable name="var563_result_spatialRepresentationType" as="xs:string?">
											<xsl:call-template name="vmf:spatialRepresentationType">
												<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
											</xsl:call-template>
										</xsl:variable>
										<xsl:if test="fn:exists($var563_result_spatialRepresentationType)">
											<gmd:MD_SpatialRepresentationTypeCode>
												<xsl:attribute name="codeList"><xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_SpatialRepresentationTypeCode'))"/></xsl:attribute>
												<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI($var563_result_spatialRepresentationType))"/></xsl:attribute>
												<xsl:variable name="var564_result_spatialRepresentationCode" as="xs:string?">
													<xsl:call-template name="vmf:spatialRepresentationCode">
														<xsl:with-param name="input" select="$var563_result_spatialRepresentationType"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:if test="fn:exists($var564_result_spatialRepresentationCode)">
													<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI($var564_result_spatialRepresentationCode))"/></xsl:attribute>
												</xsl:if>
												<xsl:sequence select="$var563_result_spatialRepresentationType"/>
											</gmd:MD_SpatialRepresentationTypeCode>
										</xsl:if>
									</xsl:for-each>
								</gmd:spatialRepresentationType>
							</xsl:for-each>
							<!-- resource language -->
							<gmd:language>
								<gco:CharacterString>
									<xsl:sequence select="'eng'"/>
								</gco:CharacterString>
							</gmd:language>
							<!-- messy logic to extract ISO topic category  -->
							<xsl:variable name="hasISOtopic">
								<xsl:for-each select="keywords/theme">
									<xsl:for-each select="themekey">
										<xsl:if test="fn:contains(' biota boundaries climatologyMeteorologyAtmosphere 
economy elevation environment farming geoscientificInformation 
health imageryBaseMapsEarthCover inlandWaters intelligenceMilitary 
location oceans planningCadastre society structure transportation 
utilitiesCommunication', concat(' ',string(.)))">
											<!-- set hasISOtopic variable -->
											<xsl:value-of select="string(.)"/>
										</xsl:if>
									</xsl:for-each>
									<!--		</xsl:if>  -->
								</xsl:for-each>
								<!--	 flag to indicate if catch an ISO topic -->
							</xsl:variable>
							<xsl:choose>
								<xsl:when test="string-length($hasISOtopic)>0">
									<gmd:topicCategory>
										<gmd:MD_TopicCategoryCode>
											<xsl:value-of select="string($hasISOtopic)"/>
										</gmd:MD_TopicCategoryCode>
									</gmd:topicCategory>
									<xsl:value-of select="$hasISOtopic"/>
								</xsl:when>
								<xsl:otherwise>
									<gmd:topicCategory gco:nilReason="missing">
										<gmd:MD_TopicCategoryCode>
											<!-- put in a dummy value so will pass profile rules -->
											<xsl:value-of select="string('geoscientificInformation')"/>
										</gmd:MD_TopicCategoryCode>
									</gmd:topicCategory>
								</xsl:otherwise>
							</xsl:choose>
							<!-- end topic category section -->
							<xsl:for-each select="native">
								<xsl:variable name="var_nativeEnvironmentNode" as="node()" select="."/>
								<gmd:environmentDescription>
									<xsl:variable name="var574_cond_result_exists" as="xs:string?">
										<xsl:choose>
											<xsl:when test="fn:exists($var_metadataRoot/distinfo/techpreq)">
												<xsl:variable name="var579_map_select_distinfo" as="xs:string*">
													<xsl:for-each select="$var_metadataRoot/distinfo/techpreq">
														<xsl:sequence select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:variable>
												<xsl:if test="fn:exists($var579_map_select_distinfo)">
													<xsl:sequence select="fn:string-join($var579_map_select_distinfo, ' ')"/>
												</xsl:if>
											</xsl:when>
											<xsl:otherwise>
												<xsl:sequence select="' '"/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:for-each select="$var574_cond_result_exists">
										<gco:CharacterString>
											<xsl:variable name="var577_cond_result_exists" as="xs:string" select="(if (fn:exists($var_metadataRoot/distinfo/techpreq)) then ' Technical Prerequisites: ' else ' ')"/>
											<xsl:sequence select="fn:normalize-space(fn:string(fn:concat('Native Dataset Environment: ', xs:string($var_nativeEnvironmentNode), $var577_cond_result_exists, .)))"/>
										</gco:CharacterString>
									</xsl:for-each>
								</gmd:environmentDescription>
							</xsl:for-each>
							<!-- Extent section, geographic, vertical, temporal... -->
							<gmd:extent>
								<gmd:EX_Extent>
									<xsl:attribute name="id"><xsl:sequence select="generate-id()"/></xsl:attribute>
									<gmd:geographicElement>
										<!-- bounding box is mandatory, spatial reference should be EPSG 4326, ie WGS 84 -->
										<!-- geographic extent, lat long bounding box required for USGIN -->
										<gmd:EX_GeographicBoundingBox>
											<xsl:attribute name="id"><xsl:sequence select="fn:concat('gbb.', generate-id())"/></xsl:attribute>
											<gmd:westBoundLongitude>
												<gco:Decimal>
													<xsl:choose>
														<xsl:when test="spdom/bounding/westbc castable as xs:decimal">
															<xsl:value-of select="xs:string(xs:decimal(spdom/bounding/westbc))"/>
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="xs:string(-179.9)"/>
														</xsl:otherwise>
													</xsl:choose>
												</gco:Decimal>
											</gmd:westBoundLongitude>
											<gmd:eastBoundLongitude>
												<gco:Decimal>
													<xsl:choose>
														<xsl:when test="spdom/bounding/eastbc castable as xs:decimal">
															<xsl:value-of select="xs:string(xs:decimal(spdom/bounding/eastbc))"/>
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="xs:string(-60)"/>
														</xsl:otherwise>
													</xsl:choose>
												</gco:Decimal>
											</gmd:eastBoundLongitude>
											<gmd:southBoundLatitude>
												<gco:Decimal>
													<xsl:choose>
														<xsl:when test="spdom/bounding/southbc castable as xs:decimal">
															<xsl:value-of select="xs:string(xs:decimal(spdom/bounding/southbc))"/>
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="xs:string(14)"/>
														</xsl:otherwise>
													</xsl:choose>
												</gco:Decimal>
											</gmd:southBoundLatitude>
											<gmd:northBoundLatitude>
												<gco:Decimal>
													<xsl:choose>
														<xsl:when test="spdom/bounding/northbc castable as xs:decimal">
															<xsl:value-of select="xs:string(xs:decimal(spdom/bounding/northbc))"/>
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="xs:string(170)"/>
														</xsl:otherwise>
													</xsl:choose>
												</gco:Decimal>
											</gmd:northBoundLatitude>
										</gmd:EX_GeographicBoundingBox>
									</gmd:geographicElement>
									<xsl:for-each select="spdom/dsgpoly">
										<gmd:geographicElement>
											<!-- handle extent encoded as a polygon -->
											<xsl:variable name="var582_dsgpoly" as="node()" select="."/>
											<gmd:EX_BoundingPolygon>
												<gmd:polygon>
													<gml:Polygon>
														<xsl:attribute name="gml:id"><xsl:sequence select="fn:concat('boundingPoly.',generate-id())"/></xsl:attribute>
														<gml:interior>
															<gml:LinearRing>
																<gml:coordinates>
																	<xsl:variable name="var587_map_select_grngpoin" as="xs:string*">
																		<xsl:for-each select="dsgpolyo/grngpoin">
																			<xsl:sequence select="fn:concat(xs:string(gringlat), ', ', xs:string(gringlon), '; ')"/>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var584_cond_result_exists" as="xs:string*">
																		<xsl:choose>
																			<xsl:when test="fn:exists($var587_map_select_grngpoin)">
																				<xsl:for-each select="dsgpolyo/grngpoin">
																					<xsl:sequence select="fn:concat(xs:string(gringlat), ', ', xs:string(gringlon), '; ')"/>
																				</xsl:for-each>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:for-each select="dsgpolyo/gring">
																					<xsl:sequence select="xs:string(.)"/>
																				</xsl:for-each>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:for-each select="$var584_cond_result_exists">
																		<xsl:attribute name="decimal"><xsl:sequence select="fn:normalize-space(.)"/></xsl:attribute>
																	</xsl:for-each>
																</gml:coordinates>
															</gml:LinearRing>
														</gml:interior>
													</gml:Polygon>
												</gmd:polygon>
											</gmd:EX_BoundingPolygon>
										</gmd:geographicElement>
									</xsl:for-each>
									<!-- temporal extent, single date -->
									<xsl:for-each select="timeperd/timeinfo/sngdate">
										<xsl:variable name="var_extentSingleDate" as="node()" select="."/>
										<gmd:temporalElement>
											<gmd:EX_TemporalExtent>
												<xsl:attribute name="id"><xsl:sequence select="fn:concat('TempEx.', generate-id())"/></xsl:attribute>
												<gmd:extent>
													<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished'))">
														<xsl:attribute name="gco:nilReason"><xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(caldate)))))"/></xsl:attribute>
													</xsl:if>
													<gml:TimeInstant>
														<xsl:attribute name="gml:id"><xsl:sequence select="fn:concat('TInst.',generate-id())"/></xsl:attribute>
														<gml:description>
															<xsl:sequence select="xs:string(xs:string($var_metadataRoot/idinfo/timeperd/current))"/>
														</gml:description>
														<!-- now process the dates -->
														<!--						<xsl:variable name="var_DateTemp" as="node()"> -->
														<xsl:variable name="var_TimePos" as="xs:string">
															<xsl:call-template name="usgin:TimePositionFormat">
																<xsl:with-param name="inputDate" select="(caldate)"/>
																<xsl:with-param name="inputTime" select="(time)"/>
															</xsl:call-template>
														</xsl:variable>
														<gml:timePosition>
															<xsl:choose>
																<xsl:when test="$var_TimePos castable as xs:dateTime">
																	<xsl:value-of select="$var_TimePos"/>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:attribute name="indeterminatePosition"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
																</xsl:otherwise>
															</xsl:choose>
														</gml:timePosition>
														<!-- /xsl:for-each -->
													</gml:TimeInstant>
												</gmd:extent>
											</gmd:EX_TemporalExtent>
										</gmd:temporalElement>
									</xsl:for-each>
									<!-- temmporal extent, multiple individual dates and times. 
						 guess the idea is there might be multple mdattim/sngdate elements?-->
									<xsl:for-each select="timeperd/timeinfo/mdattim/sngdate">
										<xsl:variable name="var713_sngdate" as="node()" select="."/>
										<gmd:temporalElement>
											<gmd:EX_TemporalExtent>
												<xsl:attribute name="id"><xsl:sequence select="fn:concat('TimePeriodEx.', generate-id())"/></xsl:attribute>
												<gmd:extent>
													<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished'))">
														<xsl:attribute name="gco:nilReason"><xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(caldate)))))"/></xsl:attribute>
													</xsl:if>
													<gml:TimeInstant>
														<xsl:attribute name="gml:id"><xsl:sequence select="fn:concat('ATimeInstant.',generate-id())"/></xsl:attribute>
														<gml:description>
															<xsl:sequence select="xs:string(xs:string($var_metadataRoot/idinfo/timeperd/current))"/>
														</gml:description>
														<gml:timePosition>
															<xsl:variable name="var718_cond_result_exists" as="xs:string?" select="(if (fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var713_sngdate/caldate))), 'present')) then 'now' else ()))) then (if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var713_sngdate/caldate))), 'present')) then 'now' else ()) else 'unknown')"/>
															<xsl:if test="fn:exists($var718_cond_result_exists)">
																<xsl:attribute name="indeterminatePosition"><xsl:sequence select="$var718_cond_result_exists"/></xsl:attribute>
															</xsl:if>
															<xsl:sequence select="xs:string(xs:string(.))"/>
														</gml:timePosition>
														<!-- /xsl:for-each -->
														<!-- can't use tempalate because that puts date in a gco:DateTime elelent, but needs to be gml:TimePosition here -->
														<xsl:variable name="var_DateTemp" as="node()">
															<xsl:call-template name="usgin:dateFormat">
																<xsl:with-param name="inputDate" select="(caldate)"/>
																<xsl:with-param name="inputTime" select="(time)"/>
															</xsl:call-template>
														</xsl:variable>
														<gml:timePosition>
															<xsl:for-each select="var_DateTemp">
																<xsl:choose>
																	<xsl:when test="fn:exists(gco:DateTime)">
																		<xsl:value-of select="fn:string(gco:DateTime)"/>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:attribute name="indeterminatePosition"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:for-each>
														</gml:timePosition>
													</gml:TimeInstant>
												</gmd:extent>
											</gmd:EX_TemporalExtent>
										</gmd:temporalElement>
									</xsl:for-each>
									<!-- temporal extent, range of dates and time -->
									<!-- each rngdates has a rngdates/begdate begtime, and /enddate /endtime -->
									<xsl:for-each select="timeperd/timeinfo/rngdates">
										<xsl:variable name="var_rngdatesNode" as="node()" select="."/>
										<gmd:temporalElement>
											<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished'))">
												<xsl:attribute name="gco:nilReason"><xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(begdate)))))"/></xsl:attribute>
											</xsl:if>
											<gmd:EX_TemporalExtent>
												<xsl:attribute name="id"><xsl:sequence select="fn:concat('DateRngEx.', generate-id())"/></xsl:attribute>
												<gmd:extent>
													<gml:TimePeriod>
														<xsl:attribute name="gml:id"><xsl:sequence select="fn:concat('bndTimePeriod.',generate-id())"/></xsl:attribute>
														<gml:description>
															<xsl:sequence select="xs:string(xs:string($var_metadataRoot/idinfo/timeperd/current))"/>
														</gml:description>
														<gml:beginPosition>
															<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var_rngdatesNode/begdate))), 'present')) then 'now' else ()))">
																<xsl:attribute name="indeterminatePosition"><xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var_rngdatesNode/begdate))), 'present')) then 'now' else ())"/></xsl:attribute>
															</xsl:if>
															<!-- xsl:sequence select="xs:string(xs:string(.))"/ -->
															<!-- can't use tempalate because that puts date in a gco:DateTime elelent, but needs to be gml:TimePosition here -->
															<xsl:variable name="var_DateTemp" as="node()">
																<xsl:call-template name="usgin:dateFormat">
																	<xsl:with-param name="inputDate" select="(begdate)"/>
																	<xsl:with-param name="inputTime" select="(begtime)"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:for-each select="var_DateTemp">
																<xsl:choose>
																	<xsl:when test="fn:exists(gco:DateTime)">
																		<xsl:value-of select="fn:string(gco:DateTime)"/>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:attribute name="indeterminatePosition"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:for-each>
														</gml:beginPosition>
														<!-- /xsl:for-each -->
														<gml:endPosition>
															<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var_rngdatesNode/enddate))), 'present')) then 'now' else ()))">
																<xsl:attribute name="indeterminatePosition"><xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var_rngdatesNode/enddate))), 'present')) then 'now' else ())"/></xsl:attribute>
															</xsl:if>
															<xsl:variable name="var_DateTemp" as="node()">
																<xsl:call-template name="usgin:dateFormat">
																	<xsl:with-param name="inputDate" select="(enddate)"/>
																	<xsl:with-param name="inputTime" select="(endtime)"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:for-each select="var_DateTemp">
																<xsl:choose>
																	<xsl:when test="fn:exists(gco:DateTime)">
																		<xsl:value-of select="fn:string(gco:DateTime)"/>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:attribute name="indeterminatePosition"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:for-each>
														</gml:endPosition>
													</gml:TimePeriod>
												</gmd:extent>
											</gmd:EX_TemporalExtent>
										</gmd:temporalElement>
									</xsl:for-each>
								</gmd:EX_Extent>
							</gmd:extent>
							<!-- supplemental information text blob... -->
							<xsl:for-each select="descript/supplinf">
								<gmd:supplementalInformation>
									<gco:CharacterString>
										<xsl:sequence select="xs:string(.)"/>
									</gco:CharacterString>
								</gmd:supplementalInformation>
							</xsl:for-each>
						</gmd:MD_DataIdentification>
					</gmd:identificationInfo>
				</xsl:for-each>
			</xsl:for-each>
			<!-- content information section -->
			<!-- replaced contentInfo with choose -->
			<gmd:contentInfo>
				<xsl:choose>
					<xsl:when test="(fn:exists($var_metadataRoot/eainfo/detailed))">
						<gmd:MD_FeatureCatalogueDescription>
							<gmd:includedWithDataset>
								<gco:Boolean>
									<xsl:variable name="var1068_cond_result_exists" as="xs:decimal" select="(if (fn:exists($var_metadataRoot/eainfo/detailed)) then xs:decimal(1) else xs:decimal(0))"/>
									<xsl:sequence select="xs:string(fn:boolean($var1068_cond_result_exists))"/>
								</gco:Boolean>
							</gmd:includedWithDataset>
							<xsl:for-each select="$var_metadataRoot/eainfo/detailed">
								<gmd:featureTypes>
									<gco:LocalName>
										<xsl:attribute name="codeSpace"><xsl:sequence select="fn:normalize-space(xs:string(enttyp/enttypl))"/></xsl:attribute>
									</gco:LocalName>
								</gmd:featureTypes>
							</xsl:for-each>
							<gmd:featureCatalogueCitation>
								<xsl:variable name="var_eainfoDetailedExists" as="xs:decimal" select="(if (fn:exists($var_metadataRoot/eainfo/detailed)) then xs:decimal(1) else xs:decimal(0))"/>
								<xsl:if test="fn:exists((if ((xs:string($var_eainfoDetailedExists) = 'false')) then () else 'unknown'))">
									<xsl:attribute name="gco:nilReason"><xsl:sequence select="xs:string((if ((xs:string($var_eainfoDetailedExists) = 'false')) then () else 'unknown'))"/></xsl:attribute>
								</xsl:if>
								<xsl:variable name="var_eainfoEaoverLabel" as="xs:string?" select="(if (fn:exists($var_metadataRoot/eainfo/overview/eaover)) then 'Entity and Attribute Overview: ' else ())"/>
								<xsl:if test="fn:exists($var_eainfoEaoverLabel)">
									<xsl:variable name="var_eainfoEaoverText" as="xs:string?">
										<xsl:variable name="var_eainfoEaoverTextSeq" as="xs:string*">
											<xsl:for-each select="$var_metadataRoot/eainfo/overview">
												<xsl:sequence select="xs:string(eaover)"/>
											</xsl:for-each>
										</xsl:variable>
										<xsl:if test="fn:exists($var_eainfoEaoverTextSeq)">
											<xsl:sequence select="fn:string-join($var_eainfoEaoverTextSeq, ' ')"/>
										</xsl:if>
									</xsl:variable>
									<xsl:for-each select="$var_eainfoEaoverText">
										<!-- xsl:variable name="var1074_cur_cond_result_exists" as="xs:string" select="."/ -->
										<xsl:variable name="var_eainfoEadetcitLabel" as="xs:string?" select="(if (fn:exists($var_metadataRoot/eainfo/overview/eadetcit)) then '   Entity and Attribute Detail Citation: ' else ())"/>
										<xsl:if test="fn:exists($var_eainfoEadetcitLabel)">
											<xsl:variable name="var_eainfoEadetcitText" as="xs:string?">
												<xsl:if test="fn:exists($var_metadataRoot/eainfo/overview/eadetcit)">
													<xsl:variable name="var1081_map_select_metadata" as="xs:string*">
														<xsl:for-each select="$var_metadataRoot/eainfo/overview/eadetcit">
															<xsl:sequence select="xs:string(.)"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:if test="fn:exists($var1081_map_select_metadata)">
														<xsl:sequence select="fn:string-join($var1081_map_select_metadata, ' ')"/>
													</xsl:if>
												</xsl:if>
											</xsl:variable>
											<gmd:CI_Citation>
												<gmd:title>
													<gco:CharacterString>
														<xsl:sequence select="'Entity and Attribute Information'"/>
													</gco:CharacterString>
												</gmd:title>
												<gmd:date>
													<xsl:attribute name="gco:nilReason"><xsl:sequence select="xs:string('unknown')"/></xsl:attribute>
												</gmd:date>
												<gmd:otherCitationDetails>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(fn:concat($var_eainfoEaoverLabel, $var_eainfoEaoverText, $var_eainfoEadetcitLabel, $var_eainfoEadetcitText))"/>
													</gco:CharacterString>
												</gmd:otherCitationDetails>
											</gmd:CI_Citation>
											<!-- /xsl:for-each -->
										</xsl:if>
									</xsl:for-each>
								</xsl:if>
							</gmd:featureCatalogueCitation>
						</gmd:MD_FeatureCatalogueDescription>
					</xsl:when>
					<xsl:otherwise>
						<xsl:if test="fn:exists($var_metadataRoot/dataqual/cloud)">
							<gmd:MD_ImageDescription>
								<gmd:cloudCoverPercentage>
									<xsl:choose>
										<xsl:when test="fn:contains(fn:lower-case(xs:string($var_metadataRoot/dataqual/cloud)), 'unknown')">
											<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
										</xsl:when>
										<xsl:when test="xs:string($var_metadataRoot/dataqual/cloud[1]) castable as xs:decimal">
											<gco:Real>
												<xsl:value-of select="xs:string($var_metadataRoot/dataqual/cloud[1])"/>
											</gco:Real>
										</xsl:when>
										<xsl:otherwise>
											<xsl:attribute name="gco:nilReason"><xsl:value-of select="xs:string('missing')"/></xsl:attribute>
										</xsl:otherwise>
									</xsl:choose>
								</gmd:cloudCoverPercentage>
							</gmd:MD_ImageDescription>
						</xsl:if>
						<!--/xsl:value-of> -->
					</xsl:otherwise>
				</xsl:choose>
			</gmd:contentInfo>
			<!-- for FGDC record, assume only a single distribution distributor/transferOption/format will be specified -->
			<gmd:distributionInfo>
				<gmd:MD_Distribution>
					<xsl:for-each select="$var_metadataRoot/distinfo/stdorder/digform">
						<xsl:variable name="var1090_digform" as="node()" select="."/>
						<!-- distribution format -->
						<gmd:distributionFormat>
							<gmd:MD_Format>
								<gmd:name>
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(xs:string(digtinfo/formname))"/>
									</gco:CharacterString>
								</gmd:name>
								<gmd:version>
									<xsl:variable name="var1092_cond_result_exists" as="xs:string?">
										<xsl:choose>
											<xsl:when test="$var1090_digform/digtinfo/formvern">
												<xsl:for-each select="digtinfo/formvern">
													<xsl:sequence select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:when>
											<xsl:otherwise>
												<xsl:sequence select="'unknown'"/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:if test="fn:exists($var1092_cond_result_exists)">
										<xsl:if test="($var1092_cond_result_exists = 'unknown')">
											<xsl:attribute name="gco:nilReason"><xsl:sequence select="xs:string('unknown')"/></xsl:attribute>
										</xsl:if>
									</xsl:if>
									<xsl:for-each select="digtinfo/formvern">
										<xsl:variable name="var1099_cond_result_equal" as="xs:string?">
											<xsl:if test="not((fn:lower-case(xs:string(.)) = 'unknown'))">
												<xsl:variable name="var1103_map_select_formverd" as="xs:string?">
													<xsl:for-each select="$var1090_digform/digtinfo/formverd">
														<xsl:sequence select="fn:string(.)"/>
													</xsl:for-each>
												</xsl:variable>
												<xsl:variable name="var1102_cond_result_exists" as="xs:string?">
													<xsl:choose>
														<xsl:when test="fn:exists($var1103_map_select_formverd)">
															<xsl:for-each select="$var1090_digform/digtinfo/formverd">
																<xsl:sequence select="fn:string(.)"/>
															</xsl:for-each>
														</xsl:when>
														<xsl:otherwise>
															<xsl:sequence select="' '"/>
														</xsl:otherwise>
													</xsl:choose>
												</xsl:variable>
												<xsl:if test="fn:exists($var1102_cond_result_exists)">
													<xsl:sequence select="fn:normalize-space(fn:string(fn:concat(xs:string(.), $var1102_cond_result_exists)))"/>
												</xsl:if>
											</xsl:if>
										</xsl:variable>
										<xsl:if test="fn:exists($var1099_cond_result_equal)">
											<gco:CharacterString>
												<xsl:sequence select="$var1099_cond_result_equal"/>
											</gco:CharacterString>
										</xsl:if>
									</xsl:for-each>
								</gmd:version>
								<xsl:for-each select="digtinfo/formspec">
									<gmd:specification>
										<gco:CharacterString>
											<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
										</gco:CharacterString>
									</gmd:specification>
								</xsl:for-each>
								<xsl:for-each select="digtinfo/filedec">
									<gmd:fileDecompressionTechnique>
										<gco:CharacterString>
											<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
										</gco:CharacterString>
									</gmd:fileDecompressionTechnique>
								</xsl:for-each>
							</gmd:MD_Format>
						</gmd:distributionFormat>
					</xsl:for-each>
					<xsl:for-each select="$var_metadataRoot/distinfo">
						<xsl:variable name="var1113_distinfo" as="node()" select="."/>
						<!-- distributor information -->
						<gmd:distributor>
							<gmd:MD_Distributor>
								<gmd:distributorContact>
									<gmd:CI_ResponsibleParty>
										<xsl:variable name="var_contactIndividual_exists" as="xs:string*">
											<xsl:choose>
												<xsl:when test="fn:exists(distrib/cntinfo/cntperp/cntper)">
													<!-- old xsl:when test="fn:exists($var5_map_select_metadata)" -->
													<xsl:for-each select="distrib/cntinfo/cntperp/cntper">
														<xsl:sequence select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:when>
												<xsl:otherwise>
													<xsl:for-each select="distrib/cntinfo/cntorgp/cntper">
														<xsl:sequence select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<xsl:variable name="var_contactOrganisation_exists" as="xs:string*">
											<xsl:choose>
												<xsl:when test="fn:exists(distrib/cntinfo/cntperp/cntorg)">
													<xsl:for-each select="distrib/cntinfo/cntperp/cntorg">
														<xsl:sequence select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:when>
												<xsl:otherwise>
													<xsl:for-each select="distrib/cntinfo/cntorgp/cntorg">
														<xsl:sequence select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<!-- done scraping content for contact name -->
										<!-- now populate the elements count(individualName + OrganisationName + positionName) must be >0 -->
										<xsl:call-template name="usgin:contactName">
											<xsl:with-param name="inputPersonNode" select="$var_contactIndividual_exists"/>
											<xsl:with-param name="inputOrganizationNode" select="($var_contactOrganisation_exists)"/>
											<xsl:with-param name="inputPositionNode" select="(distrib/cntinfo/cntpos)"/>
										</xsl:call-template>
										<gmd:contactInfo>
											<gmd:CI_Contact>
												<xsl:call-template name="usgin:telephoneFormat">
													<xsl:with-param name="telNode" select="(distrib/cntinfo)"/>
												</xsl:call-template>
												<gmd:address>
													<gmd:CI_Address>
														<xsl:call-template name="usgin:addressFormat">
															<xsl:with-param name="inputAddr" select="distrib/cntinfo/cntaddr[1]"/>
														</xsl:call-template>
														<!-- done with postal address elements, now the e-mail. Set this up so that some value gets inserted -->
														<xsl:call-template name="usgin:emailFormat">
															<xsl:with-param name="emailNode" select="distrib/cntinfo"/>
														</xsl:call-template>
													</gmd:CI_Address>
												</gmd:address>
												<!-- /xsl:for-each -->
												<xsl:for-each select="distrib/cntinfo/hours">
													<gmd:hoursOfService>
														<gco:CharacterString>
															<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
														</gco:CharacterString>
													</gmd:hoursOfService>
												</xsl:for-each>
												<xsl:for-each select="distrib/cntinfo/cntinst">
													<gmd:contactInstructions>
														<gco:CharacterString>
															<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
														</gco:CharacterString>
													</gmd:contactInstructions>
												</xsl:for-each>
											</gmd:CI_Contact>
										</gmd:contactInfo>
										<gmd:role>
											<gmd:CI_RoleCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode" codeListValue="distributor" codeSpace="005">
												<xsl:value-of select="xs:string('distributor')"/>
											</gmd:CI_RoleCode>
										</gmd:role>
									</gmd:CI_ResponsibleParty>
								</gmd:distributorContact>
								<!-- ordering process information -->
								<xsl:for-each select="stdorder">
									<xsl:variable name="var1159_stdorder" as="node()" select="."/>
									<gmd:distributionOrderProcess>
										<gmd:MD_StandardOrderProcess>
											<gmd:fees>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(fees))"/>
												</gco:CharacterString>
											</gmd:fees>
											<xsl:for-each select="$var1113_distinfo/availabl">
												<xsl:if test="fn:exists(timeinfo/sngdate)">
													<gmd:plannedAvailableDateTime>
														<xsl:call-template name="usgin:dateFormat">
															<xsl:with-param name="inputDate" select="caldate"/>
															<xsl:with-param name="inputTime" select="(time)"/>
														</xsl:call-template>
													</gmd:plannedAvailableDateTime>
												</xsl:if>
											</xsl:for-each>
											<xsl:for-each select="ordering">
												<xsl:variable name="var1542_ordering" as="node()" select="."/>
												<gmd:orderingInstructions>
													<xsl:variable name="var1544_cond_result_exists" as="xs:string?">
														<xsl:choose>
															<xsl:when test="fn:exists($var1159_stdorder/digform/digtopt/onlinopt/accinstr)">
																<xsl:variable name="var1559_map_select_digform" as="xs:string*">
																	<xsl:for-each select="$var1159_stdorder/digform/digtopt/onlinopt/accinstr">
																		<xsl:sequence select="xs:string(.)"/>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:if test="fn:exists($var1559_map_select_digform)">
																	<xsl:sequence select="fn:string-join($var1559_map_select_digform, ' ')"/>
																</xsl:if>
															</xsl:when>
															<xsl:otherwise>
																<xsl:sequence select="' '"/>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:for-each select="$var1544_cond_result_exists">
														<xsl:variable name="var1547_cond_result_exists" as="xs:string?">
															<xsl:choose>
																<xsl:when test="$var1159_stdorder/nondig">
																	<xsl:for-each select="$var1159_stdorder/nondig">
																		<xsl:sequence select="xs:string(.)"/>
																	</xsl:for-each>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:sequence select="' '"/>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:variable>
														<xsl:if test="fn:exists($var1547_cond_result_exists)">
															<xsl:variable name="var1548_cond_result_exists" as="xs:string?">
																<xsl:choose>
																	<xsl:when test="$var1113_distinfo/custom">
																		<xsl:for-each select="$var1113_distinfo/custom">
																			<xsl:sequence select="xs:string(.)"/>
																		</xsl:for-each>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:sequence select="' '"/>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:if test="fn:exists($var1548_cond_result_exists)">
																<gco:CharacterString>
																	<xsl:variable name="var1549_cond_result_exists" as="xs:string" select="(if (fn:exists($var1159_stdorder/digform/digtopt/onlinopt/accinstr)) then 'Access Instructions: ' else ' ')"/>
																	<xsl:variable name="var1550_cond_result_exists" as="xs:string" select="(if (fn:exists($var1159_stdorder/nondig)) then 'Non-Digital Form: ' else ' ')"/>
																	<xsl:variable name="var1551_cond_result_exists" as="xs:string" select="(if (fn:exists($var1113_distinfo/custom)) then ' Custom Order Process: ' else ' ')"/>
																	<xsl:sequence select="fn:normalize-space(fn:string(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat($var1549_cond_result_exists, .), $var1550_cond_result_exists), ' '), $var1547_cond_result_exists), ' '), 'Ordering Instructions: '), ' '), xs:string($var1542_ordering)), $var1551_cond_result_exists), $var1548_cond_result_exists)))"/>
																</gco:CharacterString>
															</xsl:if>
														</xsl:if>
													</xsl:for-each>
												</gmd:orderingInstructions>
											</xsl:for-each>
											<xsl:for-each select="turnarnd">
												<gmd:turnaround>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</gmd:turnaround>
											</xsl:for-each>
										</gmd:MD_StandardOrderProcess>
									</gmd:distributionOrderProcess>
								</xsl:for-each>
							</gmd:MD_Distributor>
						</gmd:distributor>
					</xsl:for-each>
					<gmd:transferOptions>
						<gmd:MD_DigitalTransferOptions>
							<xsl:for-each select="$var_metadataRoot/distinfo/stdorder/digform/digtinfo/transize">
								<gmd:transferSize>
									<gco:Real>
										<xsl:sequence select="xs:string(xs:double(.))"/>
									</gco:Real>
								</gmd:transferSize>
							</xsl:for-each>
							<!-- find text to put in online linkage description and name -->
							<xsl:variable name="var_networkResourceName" as="xs:string*">
								<xsl:for-each select="$var_metadataRoot/distinfo/stdorder/digform/digtopt/onlinopt/computer/networka/networkr">
									<!-- The name of the data set on the network. When appropriate, Uniform Resource Locators (URL) should be provided. -->
									<xsl:sequence select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:variable>
							<xsl:variable name="var_ResourceIdentifer" as="xs:string*">
								<xsl:for-each select="$var_metadataRoot/distinfo/resdesc">
									<!-- the identifier by which the distributor knows the data set. -->
									<xsl:sequence select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:variable>
							<xsl:variable name="var_OnlineName" as="xs:string*">
								<xsl:value-of select="concat((if (fn:exists($var_ResourceIdentifer)) then $var_ResourceIdentifer else 'NoResdesc'),									
									(if (fn:exists($var_networkResourceName)) then $var_networkResourceName else ' NoNetworkr'))"/>
							</xsl:variable>
							<xsl:for-each select="$var_metadataRoot/idinfo/citation/citeinfo/onlink">
								<gmd:onLine>
									<gmd:CI_OnlineResource>
										<gmd:linkage>
											<gmd:URL>
												<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(.)))"/>
											</gmd:URL>
										</gmd:linkage>
										<gmd:name>
											<gco:CharacterString>
												<xsl:sequence select=" concat($var_OnlineName,substring(.,string-length(.)-3, 4))"/>
												<!-- if theres a 3 char file extension, it will help figure out the link -->
											</gco:CharacterString>
										</gmd:name>
										<gmd:description>
											<gco:CharacterString>
												<xsl:sequence select="$var_OnlineName"/>
											</gco:CharacterString>
										</gmd:description>
									</gmd:CI_OnlineResource>
								</gmd:onLine>
							</xsl:for-each>
						</gmd:MD_DigitalTransferOptions>
					</gmd:transferOptions>
					<xsl:for-each-group select="$var_metadataRoot/distinfo/stdorder/digform/digtopt/offoptn" group-by="xs:string(offmedia)">
						<xsl:variable name="var_offlineMediaOptionGroup" as="item()+" select="current-group()"/>
						<gmd:transferOptions>
							<gmd:MD_DigitalTransferOptions>
								<gmd:offLine>
									<gmd:MD_Medium>
										<gmd:name>
											<xsl:variable name="var1618_map_result_groupitems" as="xs:string+">
												<xsl:for-each select="$var_offlineMediaOptionGroup">
													<xsl:sequence select="fn:normalize-space(xs:string(xs:string(offmedia)))"/>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var1617_map_result_distinctvalues" as="xs:string*">
												<xsl:for-each select="fn:distinct-values($var1618_map_result_groupitems)">
													<xsl:variable name="var1621_result_mediumType" as="xs:string?">
														<xsl:call-template name="vmf:mediumType">
															<xsl:with-param name="input" select="fn:upper-case(.)"/>
														</xsl:call-template>
													</xsl:variable>
													<xsl:if test="fn:exists($var1621_result_mediumType)">
														<xsl:sequence select="$var1621_result_mediumType"/>
													</xsl:if>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var1608_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1617_map_result_distinctvalues)) then fn:string-join($var1617_map_result_distinctvalues, ' ') else ())"/>
											<xsl:variable name="var1581_cond_result_exists" as="xs:string?">
												<xsl:if test="$var1608_cond_result_exists">
													<xsl:variable name="var1611_map_result_groupitems" as="xs:string+">
														<xsl:for-each select="$var_offlineMediaOptionGroup">
															<xsl:sequence select="fn:normalize-space(xs:string(xs:string(offmedia)))"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var1610_map_result_distinctvalues" as="xs:string*">
														<xsl:for-each select="fn:distinct-values($var1611_map_result_groupitems)">
															<xsl:variable name="var1614_result_mediumType" as="xs:string?">
																<xsl:call-template name="vmf:mediumType">
																	<xsl:with-param name="input" select="fn:upper-case(.)"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:if test="fn:exists($var1614_result_mediumType)">
																<xsl:sequence select="$var1614_result_mediumType"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:if test="fn:exists($var1610_map_result_distinctvalues)">
														<xsl:sequence select="fn:string-join($var1610_map_result_distinctvalues, ' ')"/>
													</xsl:if>
												</xsl:if>
											</xsl:variable>
											<xsl:if test="fn:exists($var1581_cond_result_exists)">
												<gmd:MD_MediumNameCode>
													<xsl:variable name="var1585_map_result_groupitems" as="xs:string+">
														<xsl:for-each select="$var_offlineMediaOptionGroup">
															<xsl:sequence select="fn:normalize-space(xs:string(xs:string(offmedia)))"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var1584_map_result_distinctvalues" as="xs:string*">
														<xsl:for-each select="fn:distinct-values($var1585_map_result_groupitems)">
															<xsl:variable name="var1588_result_mediumType" as="xs:string?">
																<xsl:call-template name="vmf:mediumType">
																	<xsl:with-param name="input" select="fn:upper-case(.)"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:if test="fn:exists($var1588_result_mediumType)">
																<xsl:sequence select="$var1588_result_mediumType"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var1583_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1584_map_result_distinctvalues)) then fn:string-join($var1584_map_result_distinctvalues, ' ') else ())"/>
													<xsl:variable name="var1582_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1583_cond_result_exists)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MediumNameCode' else ())"/>
													<xsl:if test="fn:exists($var1582_cond_result_exists)">
														<xsl:attribute name="codeList"><xsl:sequence select="xs:string(xs:anyURI($var1582_cond_result_exists))"/></xsl:attribute>
													</xsl:if>
													<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI($var1581_cond_result_exists))"/></xsl:attribute>
													<xsl:variable name="var1602_map_result_groupitems" as="xs:string+">
														<xsl:for-each select="$var_offlineMediaOptionGroup">
															<xsl:sequence select="fn:normalize-space(xs:string(xs:string(offmedia)))"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var1601_map_result_distinctvalues" as="xs:string*">
														<xsl:for-each select="fn:distinct-values($var1602_map_result_groupitems)">
															<xsl:variable name="var1605_result_mediumType" as="xs:string?">
																<xsl:call-template name="vmf:mediumType">
																	<xsl:with-param name="input" select="fn:upper-case(.)"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:if test="fn:exists($var1605_result_mediumType)">
																<xsl:sequence select="$var1605_result_mediumType"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var1592_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1601_map_result_distinctvalues)) then fn:string-join($var1601_map_result_distinctvalues, ' ') else ())"/>
													<xsl:variable name="var1591_cond_result_exists" as="xs:string?">
														<xsl:if test="$var1592_cond_result_exists">
															<xsl:variable name="var1595_map_result_groupitems" as="xs:string+">
																<xsl:for-each select="$var_offlineMediaOptionGroup">
																	<xsl:sequence select="fn:normalize-space(xs:string(xs:string(offmedia)))"/>
																</xsl:for-each>
															</xsl:variable>
															<xsl:variable name="var1594_map_result_distinctvalues" as="xs:string*">
																<xsl:for-each select="fn:distinct-values($var1595_map_result_groupitems)">
																	<xsl:variable name="var1598_result_mediumCode" as="xs:string?">
																		<xsl:call-template name="vmf:mediumCode">
																			<xsl:with-param name="input" select="fn:upper-case(.)"/>
																		</xsl:call-template>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var1598_result_mediumCode)">
																		<xsl:sequence select="$var1598_result_mediumCode"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:variable>
															<xsl:if test="fn:exists($var1594_map_result_distinctvalues)">
																<xsl:sequence select="fn:string-join($var1594_map_result_distinctvalues, ' ')"/>
															</xsl:if>
														</xsl:if>
													</xsl:variable>
													<xsl:if test="fn:exists($var1591_cond_result_exists)">
														<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI($var1591_cond_result_exists))"/></xsl:attribute>
													</xsl:if>
													<xsl:sequence select="$var1581_cond_result_exists"/>
												</gmd:MD_MediumNameCode>
											</xsl:if>
										</gmd:name>
										<xsl:for-each select="$var_offlineMediaOptionGroup/reccap/recden">
											<gmd:density>
												<gco:Real>
													<xsl:sequence select="xs:string(xs:double(.))"/>
												</gco:Real>
											</gmd:density>
										</xsl:for-each>
										<xsl:for-each select="$var_offlineMediaOptionGroup/reccap">
											<gmd:densityUnits>
												<gco:CharacterString>
													<xsl:sequence select="xs:string(recdenu)"/>
												</gco:CharacterString>
											</gmd:densityUnits>
										</xsl:for-each>
										<gmd:mediumFormat>
											<xsl:variable name="var1638_map_result_groupitems" as="xs:string*">
												<xsl:for-each select="$var_offlineMediaOptionGroup/recfmt">
													<xsl:variable name="var1641_result_encodingType" as="xs:string?">
														<xsl:call-template name="vmf:encodingType">
															<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
														</xsl:call-template>
													</xsl:variable>
													<xsl:if test="fn:exists($var1641_result_encodingType)">
														<xsl:sequence select="$var1641_result_encodingType"/>
													</xsl:if>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var1628_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1638_map_result_groupitems)) then fn:string-join($var1638_map_result_groupitems, ' ') else ())"/>
											<xsl:for-each select="$var1628_cond_result_exists">
												<gmd:MD_MediumFormatCode>
													<xsl:attribute name="codeList"><xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MediumFormatCode'))"/></xsl:attribute>
													<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI(.))"/></xsl:attribute>
													<xsl:variable name="var1634_map_result_groupitems" as="xs:string*">
														<xsl:for-each select="$var_offlineMediaOptionGroup/recfmt">
															<xsl:variable name="var1637_result_encodingCode" as="xs:string?">
																<xsl:call-template name="vmf:encodingCode">
																	<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:if test="fn:exists($var1637_result_encodingCode)">
																<xsl:sequence select="$var1637_result_encodingCode"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var1631_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1634_map_result_groupitems)) then fn:string-join($var1634_map_result_groupitems, ' ') else ())"/>
													<xsl:for-each select="$var1631_cond_result_exists">
														<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI(.))"/></xsl:attribute>
													</xsl:for-each>
													<xsl:sequence select="."/>
												</gmd:MD_MediumFormatCode>
											</xsl:for-each>
										</gmd:mediumFormat>
										<xsl:variable name="var1642_cond_result_exists" as="xs:string?" select="(if (fn:exists($var_metadataRoot/distinfo/stdorder/digform/digtinfo/formcont)) then 'Format Information Content:  ' else ())"/>
										<xsl:if test="fn:exists($var1642_cond_result_exists)">
											<xsl:for-each select="$var_metadataRoot/distinfo/stdorder/digform/digtinfo/formcont">
												<xsl:variable name="var1643_formcont" as="node()" select="."/>
												<xsl:variable name="var1645_cond_result_exists" as="xs:string?" select="(if (fn:exists($var_offlineMediaOptionGroup/compat)) then ' Compatibility Information: ' else ())"/>
												<xsl:if test="fn:exists($var1645_cond_result_exists)">
													<xsl:for-each select="$var_offlineMediaOptionGroup/compat">
														<gmd:mediumNote>
															<gco:CharacterString>
																<xsl:sequence select="fn:concat(fn:concat(fn:concat($var1642_cond_result_exists, fn:normalize-space(xs:string($var1643_formcont))), $var1645_cond_result_exists), xs:string(.))"/>
															</gco:CharacterString>
														</gmd:mediumNote>
													</xsl:for-each>
												</xsl:if>
											</xsl:for-each>
										</xsl:if>
									</gmd:MD_Medium>
								</gmd:offLine>
							</gmd:MD_DigitalTransferOptions>
						</gmd:transferOptions>
					</xsl:for-each-group>
				</gmd:MD_Distribution>
			</gmd:distributionInfo>
			<!-- data quality section -->
			<xsl:for-each select="$var_metadataRoot">
				<xsl:for-each select="dataqual">
					<gmd:dataQualityInfo>
						<gmd:DQ_DataQuality>
							<gmd:scope>
								<gmd:DQ_Scope>
									<gmd:level>
										<gmd:MD_ScopeCode codeListValue="dataset" codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode">
										</gmd:MD_ScopeCode>
									</gmd:level>
								</gmd:DQ_Scope>
							</gmd:scope>
							<xsl:for-each select="posacc/horizpa">
								<xsl:if test="fn:exists(qhorizpa/horizpav)">
									<gmd:report>
										<gmd:DQ_AbsoluteExternalPositionalAccuracy>
											<gmd:nameOfMeasure>
												<gco:CharacterString>
													<xsl:sequence select="'Horizontal Positional Accuracy'"/>
												</gco:CharacterString>
											</gmd:nameOfMeasure>
											<gmd:measureDescription>
												<gco:CharacterString>
													<xsl:variable name="DQMeasureDesc" as="xs:integer">
														<xsl:value-of select="xs:integer(fn:count(/metadata/dataqual/posacc/horizpa/qhorizpa/horizpae))"/>
													</xsl:variable>
													<xsl:for-each select="/metadata/dataqual/posacc/horizpa/qhorizpa[1]/horizpae">
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
														<xsl:if test="($DQMeasureDesc>1)">
															<xsl:value-of select="xs:string(' ')"/>
														</xsl:if>
													</xsl:for-each>
												</gco:CharacterString>
											</gmd:measureDescription>
											<gmd:evaluationMethodDescription>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(horizpar))"/>
												</gco:CharacterString>
											</gmd:evaluationMethodDescription>
											<gmd:result>
												<gmd:DQ_QuantitativeResult>
													<gmd:valueUnit>
														<gml:BaseUnit>
															<xsl:attribute name="gml:id"><xsl:sequence select="fn:concat('uom.',generate-id())"/></xsl:attribute>
															<gml:identifier>
																<xsl:attribute name="codeSpace"><xsl:sequence select="fn:concat('uom.',generate-id())"/></xsl:attribute>
															</gml:identifier>
															<gml:unitsSystem>
																<xsl:attribute name="xlink:href"><xsl:sequence select="xs:string(xs:anyURI('http://www.bipm.org/en/si/'))"/></xsl:attribute>
															</gml:unitsSystem>
														</gml:BaseUnit>
													</gmd:valueUnit>
													<gmd:value>
														<gco:Record>
															<xsl:value-of select="xs:string(xs:double(/metadata/dataqual/posacc/horizpa/qhorizpa[1]/horizpav[1]))"/>
														</gco:Record>
													</gmd:value>
												</gmd:DQ_QuantitativeResult>
											</gmd:result>
										</gmd:DQ_AbsoluteExternalPositionalAccuracy>
									</gmd:report>
								</xsl:if>
							</xsl:for-each>
							<xsl:for-each select="posacc/vertacc">
								<xsl:if test="fn:exists(qvertpa/vertaccv)">
									<gmd:report>
										<gmd:DQ_AbsoluteExternalPositionalAccuracy>
											<gmd:nameOfMeasure>
												<gco:CharacterString>
													<xsl:sequence select="'Vertical Positional Accuracy'"/>
												</gco:CharacterString>
											</gmd:nameOfMeasure>
											<gmd:measureDescription>
												<gco:CharacterString>
													<xsl:variable name="DQMeasureDesc" as="xs:integer">
														<xsl:value-of select="xs:integer(fn:count(/metadata/dataqual/posacc/vertacc/qvertpa/vertacce[1]))"/>
													</xsl:variable>
													<xsl:for-each select="/metadata/dataqual/posacc/vertacc/qvertpa/vertacce[1]">
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
														<xsl:if test="($DQMeasureDesc>1)">
															<xsl:value-of select="xs:string(' ')"/>
														</xsl:if>
													</xsl:for-each>
												</gco:CharacterString>
											</gmd:measureDescription>
											<gmd:evaluationMethodDescription>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(vertaccr))"/>
												</gco:CharacterString>
											</gmd:evaluationMethodDescription>
											<gmd:result>
												<gmd:DQ_QuantitativeResult>
													<gmd:valueUnit>
														<gml:BaseUnit>
															<xsl:attribute name="gml:id"><xsl:sequence select="fn:concat('uom.',generate-id())"/></xsl:attribute>
															<gml:identifier>
																<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI('meters'))"/></xsl:attribute>
															</gml:identifier>
															<gml:unitsSystem>
																<xsl:attribute name="xlink:href"><xsl:sequence select="xs:string(xs:anyURI('http://www.bipm.org/en/si/'))"/></xsl:attribute>
															</gml:unitsSystem>
														</gml:BaseUnit>
													</gmd:valueUnit>
													<gmd:value>
														<gco:Record>
															<xsl:value-of select="xs:string(/metadata/dataqual/posacc/vertacc/qvertpa[1]/vertaccv[2])"/>
														</gco:Record>
													</gmd:value>
												</gmd:DQ_QuantitativeResult>
											</gmd:result>
										</gmd:DQ_AbsoluteExternalPositionalAccuracy>
									</gmd:report>
								</xsl:if>
							</xsl:for-each>
							<xsl:if test="fn:exists($var_metadataRoot/eainfo/detailed) or fn:exists(complete)">
								<gmd:report>
									<gmd:DQ_CompletenessOmission>
										<gmd:evaluationMethodDescription>
											<gco:CharacterString>
												<xsl:choose>
													<xsl:when test="fn:exists(complete)">
														<xsl:sequence select="fn:normalize-space(xs:string(complete))"/>
													</xsl:when>
													<xsl:otherwise>
														<xsl:value-of select="xs:string('missing')"/>
													</xsl:otherwise>
												</xsl:choose>
											</gco:CharacterString>
										</gmd:evaluationMethodDescription>
										<gmd:result>
											<xsl:variable name="var1664_cond_result_exists" as="xs:decimal" select="(if (fn:exists($var_metadataRoot/eainfo/detailed)) then xs:decimal(1) else xs:decimal(0))"/>
											<xsl:if test="fn:exists((if ((xs:string($var1664_cond_result_exists) = 'false')) then () else 'unknown'))">
												<xsl:attribute name="gco:nilReason"><xsl:sequence select="xs:string(xs:string((if ((xs:string($var1664_cond_result_exists) = 'false')) then () else 'unknown')))"/></xsl:attribute>
											</xsl:if>
										</gmd:result>
									</gmd:DQ_CompletenessOmission>
								</gmd:report>
							</xsl:if>
							<!-- conceptual consistency report -->
							<xsl:if test="fn:exists(logic)">
								<gmd:report>
									<gmd:DQ_ConceptualConsistency>
										<gmd:measureDescription>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(logic))"/>
											</gco:CharacterString>
										</gmd:measureDescription>
										<gmd:result>
											<xsl:attribute name="gco:nilReason"><xsl:sequence select="xs:string(xs:string('unknown'))"/></xsl:attribute>
										</gmd:result>
									</gmd:DQ_ConceptualConsistency>
								</gmd:report>
							</xsl:if>
							<!-- attribute accuracy information -->
							<xsl:for-each select="attracc">
								<xsl:variable name="var_attributeAccuracyNode" as="node()" select="."/>
								<xsl:for-each select="qattracc">
									<xsl:if test="fn:exists(attraccv)">
										<gmd:report>
											<gmd:DQ_QuantitativeAttributeAccuracy>
												<gmd:nameOfMeasure>
													<gco:CharacterString>
														<xsl:sequence select="'Quantitative Attribute Accuracy Assessment'"/>
													</gco:CharacterString>
												</gmd:nameOfMeasure>
												<gmd:measureDescription>
													<gco:CharacterString>
														<xsl:sequence select="xs:string(attracce)"/>
													</gco:CharacterString>
												</gmd:measureDescription>
												<gmd:evaluationMethodDescription>
													<xsl:for-each select="$var_attributeAccuracyNode/attraccr">
														<gco:CharacterString>
															<xsl:sequence select="xs:string(.)"/>
														</gco:CharacterString>
													</xsl:for-each>
												</gmd:evaluationMethodDescription>
												<gmd:result>
													<gmd:DQ_QuantitativeResult>
														<gmd:valueUnit gco:nilReason="inapplicable"/>
														<gmd:value>
															<!--<xsl:for-each select="attraccv"> -->
															<gco:Record>
																<xsl:variable name="DataQualResult" as="xs:integer">
																	<xsl:value-of select="xs:integer(fn:count(/metadata/dataqual/attracc/qattracc/attraccv))"/>
																</xsl:variable>
																<xsl:for-each select="/metadata/dataqual/attracc/qattracc/attraccv">
																	<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																	<xsl:if test="($DataQualResult>1)">
																		<xsl:value-of select="xs:string(' ')"/>
																	</xsl:if>
																</xsl:for-each>
															</gco:Record>
															<!--</xsl:for-each> -->
														</gmd:value>
													</gmd:DQ_QuantitativeResult>
												</gmd:result>
											</gmd:DQ_QuantitativeAttributeAccuracy>
										</gmd:report>
									</xsl:if>
								</xsl:for-each>
							</xsl:for-each>
							<!-- now handle the lineage/provenance information -->
							<xsl:if test="fn:exists(lineage/procstep) or fn:exists(lineage/srcinfo)">
								<gmd:lineage>
									<gmd:LI_Lineage>
										<gmd:statement>
											<gco:CharacterString>missing</gco:CharacterString>
										</gmd:statement>
										<xsl:for-each select="lineage/procstep">
											<xsl:variable name="var_lineageProcessingStepNode" as="node()" select="."/>
											<gmd:processStep>
												<gmd:LI_ProcessStep>
													<gmd:description>
														<gco:CharacterString>
															<xsl:sequence select="xs:string(procdesc)"/>
														</gco:CharacterString>
													</gmd:description>
													<gmd:dateTime>
														<xsl:call-template name="usgin:dateFormat">
															<xsl:with-param name="inputDate" select="procdate"/>
															<xsl:with-param name="inputTime" select="proctime"/>
														</xsl:call-template>
													</gmd:dateTime>
													<xsl:for-each select="proccont">
														<gmd:processor>
															<gmd:CI_ResponsibleParty>
																<xsl:variable name="var_contactIndividual_exists" as="xs:string*">
																	<xsl:choose>
																		<xsl:when test="fn:exists(cntinfo/cntperp/cntper)">
																			<xsl:for-each select="cntinfo/cntperp/cntper">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:for-each select="cntinfo/cntorgp/cntper">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:variable name="var_contactOrganisation_exists" as="xs:string*">
																	<xsl:choose>
																		<xsl:when test="fn:exists(cntinfo/cntperp/cntorg)">
																			<xsl:for-each select="cntinfo/cntperp/cntorg">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:for-each select="cntinfo/cntorgp/cntorg">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<!-- done scraping content for contact name -->
																<!-- now populate the elements count(individualName + OrganisationName + positionName) must be >0 -->
																<xsl:call-template name="usgin:contactName">
																	<xsl:with-param name="inputPersonNode" select="$var_contactIndividual_exists"/>
																	<xsl:with-param name="inputOrganizationNode" select="($var_contactOrganisation_exists)"/>
																	<xsl:with-param name="inputPositionNode" select="(cntinfo/cntpos)"/>
																</xsl:call-template>
																<gmd:contactInfo>
																	<gmd:CI_Contact>
																		<!-- do the phone number(s) -->
																		<xsl:call-template name="usgin:telephoneFormat">
																			<xsl:with-param name="telNode" select="(cntinfo)"/>
																		</xsl:call-template>
																		<!-- xsl:for-each select="cntinfo/cntaddr"  -->
																		<gmd:address>
																			<gmd:CI_Address>
																				<xsl:call-template name="usgin:addressFormat">
																					<xsl:with-param name="inputAddr" select="cntinfo/cntaddr[1]"/>
																				</xsl:call-template>
																				<!-- done with postal address elements, now the e-mail. Set this up so that some value gets inserted -->
																				<xsl:call-template name="usgin:emailFormat">
																					<xsl:with-param name="emailNode" select="cntinfo"/>
																				</xsl:call-template>
																			</gmd:CI_Address>
																		</gmd:address>
																		<gmd:hoursOfService>
																			<xsl:for-each select="cntinfo/hours">
																				<gco:CharacterString>
																					<xsl:sequence select="xs:string(.)"/>
																				</gco:CharacterString>
																			</xsl:for-each>
																		</gmd:hoursOfService>
																		<gmd:contactInstructions>
																			<xsl:for-each select="cntinfo/cntinst">
																				<gco:CharacterString>
																					<xsl:sequence select="xs:string(.)"/>
																				</gco:CharacterString>
																			</xsl:for-each>
																		</gmd:contactInstructions>
																	</gmd:CI_Contact>
																</gmd:contactInfo>
																<gmd:role>
																	<gmd:CI_RoleCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode" codeListValue="processor" codeSpace="009">
																		<xsl:value-of select="xs:string('processor')"/>
																	</gmd:CI_RoleCode>
																	<!-- /xsl:if -->
																</gmd:role>
															</gmd:CI_ResponsibleParty>
														</gmd:processor>
													</xsl:for-each>
													<xsl:for-each-group select="." group-by="grp:sourcesUsed(.)">
														<xsl:variable name="var1800_cur_result_groupby" as="item()+" select="current-group()"/>
														<xsl:variable name="var1801_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
														<gmd:source>
															<gmd:LI_Source>
																<gmd:sourceCitation>
																	<gmd:CI_Citation>
																		<gmd:title>
																			<gco:CharacterString>
																				<xsl:sequence select="$var1801_cur_result_groupby"/>
																			</gco:CharacterString>
																		</gmd:title>
																		<xsl:for-each select="$var1800_cur_result_groupby/srcprod">
																			<gmd:alternateTitle>
																				<gco:CharacterString>
																					<xsl:sequence select="xs:string(.)"/>
																				</gco:CharacterString>
																			</gmd:alternateTitle>
																		</xsl:for-each>
																		<gmd:date>
																			<xsl:attribute name="gco:nilReason"><xsl:sequence select="xs:string(xs:string('unknown'))"/></xsl:attribute>
																		</gmd:date>
																	</gmd:CI_Citation>
																</gmd:sourceCitation>
															</gmd:LI_Source>
														</gmd:source>
													</xsl:for-each-group>
												</gmd:LI_ProcessStep>
											</gmd:processStep>
										</xsl:for-each>
										<xsl:for-each select="lineage/srcinfo">
											<xsl:variable name="var_lineageSourceInfoNode" as="node()" select="."/>
											<gmd:source>
												<gmd:LI_Source>
													<xsl:if test="fn:exists(strcontr) or fn:exists(typesrc)">
														<gmd:description>
															<gco:CharacterString>
																<xsl:sequence select="fn:concat('Source Contribution: ', xs:string(srccontr), ' ', xs:string(typesrc))"/>
															</gco:CharacterString>
														</gmd:description>
													</xsl:if>
													<xsl:if test="fn:exists(srcscale) and ((fn:lower-case(fn:string(srcscale)) = 'unknown') or (srcscale castable as xs:integer))">
														<gmd:scaleDenominator>
															<gmd:MD_RepresentativeFraction>
																<gmd:denominator>
																	<xsl:choose>
																		<xsl:when test="(fn:lower-case(fn:string(srcscale)) = 'unknown')">
																			<xsl:attribute name="gco:nilReason"><xsl:sequence select="xs:string('unknown')"/></xsl:attribute>
																		</xsl:when>
																		<xsl:when test="srcscale castable as xs:integer">
																			<gco:Integer>
																				<xsl:sequence select="xs:string(xs:integer(srcscale))"/>
																			</gco:Integer>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:attribute name="gco:nilReason"><xsl:sequence select="xs:string('missing')"/></xsl:attribute>
																		</xsl:otherwise>
																	</xsl:choose>
																</gmd:denominator>
															</gmd:MD_RepresentativeFraction>
														</gmd:scaleDenominator>
													</xsl:if>
													<gmd:sourceCitation>
														<gmd:CI_Citation>
															<gmd:title>
																<gco:CharacterString>
																	<xsl:sequence select="xs:string(srccite/citeinfo/title)"/>
																</gco:CharacterString>
															</gmd:title>
															<xsl:if test="fn:exists(srccitea)">
																<gmd:alternateTitle>
																	<gco:CharacterString>
																		<xsl:sequence select="xs:string(srccitea)"/>
																	</gco:CharacterString>
																</gmd:alternateTitle>
															</xsl:if>
															<gmd:date>
																<gmd:CI_Date>
																	<gmd:date>
																		<xsl:call-template name="usgin:dateFormat">
																			<xsl:with-param name="inputDate" select="srccite/citeinfo/pubdate"/>
																			<xsl:with-param name="inputTime" select="srccite/citeinfo/pubtime"/>
																		</xsl:call-template>
																	</gmd:date>
																	<gmd:dateType>
																		<gmd:CI_DateTypeCode>
																			<xsl:attribute name="codeList"><xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode'))"/></xsl:attribute>
																			<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI('publication'))"/></xsl:attribute>
																			<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI('002'))"/></xsl:attribute>
																			<xsl:sequence select="'publication'"/>
																		</gmd:CI_DateTypeCode>
																	</gmd:dateType>
																</gmd:CI_Date>
															</gmd:date>
															<xsl:if test="fn:exists(srccite/citeinfo/edition)">
																<gmd:edition>
																	<gco:CharacterString>
																		<xsl:sequence select="xs:string(srccite/citeinfo/edition)"/>
																	</gco:CharacterString>
																</gmd:edition>
															</xsl:if>
															<xsl:for-each-group select="srccite/citeinfo" group-by="grp:origins(.)">
																<xsl:variable name="var1881_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																<gmd:citedResponsibleParty>
																	<gmd:CI_ResponsibleParty>
																		<gmd:organisationName>
																			<gco:CharacterString>
																				<xsl:sequence select="$var1881_cur_result_groupby"/>
																			</gco:CharacterString>
																		</gmd:organisationName>
																		<gmd:role>
																			<gmd:CI_RoleCode>
																				<xsl:attribute name="codeList"><xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/></xsl:attribute>
																				<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI('resourceProvider'))"/></xsl:attribute>
																				<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI('001'))"/></xsl:attribute>
																				<xsl:sequence select="'resourceProvider'"/>
																			</gmd:CI_RoleCode>
																		</gmd:role>
																	</gmd:CI_ResponsibleParty>
																</gmd:citedResponsibleParty>
															</xsl:for-each-group>
															<xsl:if test="fn:exists(srccite/citeinfo/geoform) ">
																<gmd:presentationForm>
																	<xsl:variable name="var1883_cond_result_exists" as="xs:string?">
																		<xsl:choose>
																			<xsl:when test="$var_lineageSourceInfoNode/srccite/citeinfo/geoform">
																				<!--xsl:for-each select="srccite/citeinfo/geoform" -->
																				<xsl:variable name="var_sourceDocTypeLookup" as="xs:string?">
																					<xsl:call-template name="vmf:docType">
																						<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(srccite/citeinfo/geoform)))"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var_sourceDocTypeLookup)">
																					<xsl:sequence select="$var_sourceDocTypeLookup"/>
																				</xsl:if>
																				<!-- /xsl:for-each -->
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:for-each select="srccite/citeinfo/geoform">
																					<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
																				</xsl:for-each>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<gmd:CI_PresentationFormCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode">
																		<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string($var1883_cond_result_exists)"/></xsl:attribute>
																		<xsl:variable name="var_presentationFormCodespaceLookup" as="xs:string?">
																			<xsl:call-template name="vmf:docCode">
																				<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(srccite/citeinfo/geoform)))"/>
																			</xsl:call-template>
																		</xsl:variable>
																		<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string($var_presentationFormCodespaceLookup)"/></xsl:attribute>
																		<xsl:sequence select="$var1883_cond_result_exists"/>
																	</gmd:CI_PresentationFormCode>
																</gmd:presentationForm>
															</xsl:if>
															<xsl:if test="fn:exists(srccite/citeinfo/serinfo)">
																<gmd:series>
																	<gmd:CI_Series>
																		<gmd:name>
																			<xsl:for-each select="srccite/citeinfo/serinfo">
																				<gco:CharacterString>
																					<xsl:sequence select="xs:string(sername)"/>
																				</gco:CharacterString>
																			</xsl:for-each>
																		</gmd:name>
																		<gmd:issueIdentification>
																			<xsl:for-each select="srccite/citeinfo/serinfo">
																				<gco:CharacterString>
																					<xsl:sequence select="xs:string(issue)"/>
																				</gco:CharacterString>
																			</xsl:for-each>
																		</gmd:issueIdentification>
																	</gmd:CI_Series>
																</gmd:series>
															</xsl:if>
															<xsl:if test="fn:exists(srccite/citeinfo/othercit)">
																<gmd:otherCitationDetails>
																	<!--xsl:for-each select="srccite/citeinfo/othercit" -->
																	<gco:CharacterString>
																		<xsl:sequence select="xs:string(srccite/citeinfo/othercit)"/>
																	</gco:CharacterString>
																	<!-- /xsl:for-each -->
																</gmd:otherCitationDetails>
															</xsl:if>
														</gmd:CI_Citation>
													</gmd:sourceCitation>
													<xsl:if test="fn:exists(srctime/timeinfo)">
														<gmd:sourceExtent>
															<gmd:EX_Extent>
																<xsl:for-each select="srctime/timeinfo/sngdate">
																	<gmd:temporalElement>
																		<gmd:EX_TemporalExtent>
																			<gmd:extent>
																				<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished'))">
																					<xsl:attribute name="gco:nilReason"><xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(caldate)))))"/></xsl:attribute>
																				</xsl:if>
																				<gml:TimeInstant>
																					<xsl:attribute name="gml:id"><xsl:sequence select="fn:concat('TempEx.',generate-id())"/></xsl:attribute>
																					<gml:description>
																						<xsl:sequence select="xs:string(xs:string($var_lineageSourceInfoNode/srctime/srccurr))"/>
																					</gml:description>
																					<xsl:variable name="var_DateTemp" as="node()">
																						<xsl:call-template name="usgin:dateFormat">
																							<xsl:with-param name="inputDate" select="(caldate)"/>
																							<xsl:with-param name="inputTime" select="(time)"/>
																						</xsl:call-template>
																					</xsl:variable>
																					<gml:timePosition>
																						<xsl:for-each select="var_DateTemp">
																							<xsl:choose>
																								<xsl:when test="fn:exists(gco:DateTime)">
																									<xsl:value-of select="fn:string(gco:DateTime)"/>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:attribute name="indeterminatePosition"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</gml:timePosition>
																				</gml:TimeInstant>
																			</gmd:extent>
																		</gmd:EX_TemporalExtent>
																	</gmd:temporalElement>
																</xsl:for-each>
																<xsl:for-each select="srctime/timeinfo/mdattim/sngdate">
																	<gmd:temporalElement>
																		<gmd:EX_TemporalExtent>
																			<gmd:extent>
																				<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished'))">
																					<xsl:attribute name="gco:nilReason"><xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(caldate)))))"/></xsl:attribute>
																				</xsl:if>
																				<gml:TimeInstant>
																					<xsl:attribute name="gml:id"><xsl:sequence select="fn:concat('sourceTimeInst.',generate-id())"/></xsl:attribute>
																					<gml:description>
																						<xsl:sequence select="xs:string(xs:string($var_lineageSourceInfoNode/srctime/srccurr))"/>
																					</gml:description>
																					<xsl:variable name="var_DateTemp" as="node()">
																						<xsl:call-template name="usgin:dateFormat">
																							<xsl:with-param name="inputDate" select="(caldate)"/>
																							<xsl:with-param name="inputTime" select="(time)"/>
																						</xsl:call-template>
																					</xsl:variable>
																					<gml:timePosition>
																						<xsl:for-each select="var_DateTemp">
																							<xsl:choose>
																								<xsl:when test="fn:exists(gco:DateTime)">
																									<xsl:value-of select="fn:string(gco:DateTime)"/>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:attribute name="indeterminatePosition"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</gml:timePosition>
																				</gml:TimeInstant>
																			</gmd:extent>
																		</gmd:EX_TemporalExtent>
																	</gmd:temporalElement>
																</xsl:for-each>
																<xsl:for-each select="srctime/timeinfo/rngdates">
																	<xsl:variable name="var_rngdatesNode" as="node()" select="."/>
																	<gmd:temporalElement>
																		<gmd:EX_TemporalExtent>
																			<gmd:extent>
																				<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished'))">
																					<xsl:attribute name="gco:nilReason"><xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(begdate)))))"/></xsl:attribute>
																				</xsl:if>
																				<gml:TimePeriod>
																					<xsl:attribute name="gml:id"><xsl:sequence select="fn:concat('srcTempEx.',generate-id())"/></xsl:attribute>
																					<gml:description>
																						<xsl:sequence select="xs:string(xs:string($var_lineageSourceInfoNode/srctime/srccurr))"/>
																					</gml:description>
																					<gml:beginPosition>
																						<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var_rngdatesNode/begdate))), 'present')) then 'now' else ()))">
																							<xsl:attribute name="indeterminatePosition"><xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var_rngdatesNode/begdate))), 'present')) then 'now' else ())"/></xsl:attribute>
																						</xsl:if>
																						<!-- can't use tempalate because that puts date in a gco:DateTime elelent, but needs to be gml:TimePosition here -->
																						<xsl:variable name="var_DateTemp" as="node()">
																							<xsl:call-template name="usgin:dateFormat">
																								<xsl:with-param name="inputDate" select="(begdate)"/>
																								<xsl:with-param name="inputTime" select="(begtime)"/>
																							</xsl:call-template>
																						</xsl:variable>
																						<xsl:for-each select="var_DateTemp">
																							<xsl:choose>
																								<xsl:when test="fn:exists(gco:DateTime)">
																									<xsl:value-of select="fn:string(gco:DateTime)"/>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:attribute name="indeterminatePosition"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</gml:beginPosition>
																					<gml:endPosition>
																						<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var_rngdatesNode/enddate))), 'present')) then 'now' else ()))">
																							<xsl:attribute name="indeterminatePosition"><xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var_rngdatesNode/enddate))), 'present')) then 'now' else ())"/></xsl:attribute>
																						</xsl:if>
																						<xsl:variable name="var_DateTemp" as="node()">
																							<xsl:call-template name="usgin:dateFormat">
																								<xsl:with-param name="inputDate" select="(enddate)"/>
																								<xsl:with-param name="inputTime" select="(endtime)"/>
																							</xsl:call-template>
																						</xsl:variable>
																						<xsl:for-each select="var_DateTemp">
																							<xsl:choose>
																								<xsl:when test="fn:exists(gco:DateTime)">
																									<xsl:value-of select="fn:string(gco:DateTime)"/>
																								</xsl:when>
																								<xsl:otherwise>
	lineab																							<xsl:attribute name="indeterminatePosition"><xsl:value-of select="xs:string('unknown')"/></xsl:attribute>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</gml:endPosition>
																				</gml:TimePeriod>
																			</gmd:extent>
																		</gmd:EX_TemporalExtent>
																	</gmd:temporalElement>
																</xsl:for-each>
															</gmd:EX_Extent>
														</gmd:sourceExtent>
													</xsl:if>
												</gmd:LI_Source>
											</gmd:source>
										</xsl:for-each>
									</gmd:LI_Lineage>
								</gmd:lineage>
							</xsl:if>
						</gmd:DQ_DataQuality>
					</gmd:dataQualityInfo>
				</xsl:for-each>
			</xsl:for-each>
			<!-- metadata constraints -->
			<xsl:for-each select="$var_metadataRoot">
				<xsl:variable name="var2374_metadata" as="node()" select="."/>
				<xsl:for-each select="metainfo/metac">
					<gmd:metadataConstraints>
						<gmd:MD_LegalConstraints>
							<gmd:accessConstraints>
								<gmd:MD_RestrictionCode>
									<xsl:attribute name="codeList"><xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode'))"/></xsl:attribute>
									<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI('otherRestrictions'))"/></xsl:attribute>
									<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI('008'))"/></xsl:attribute>
								</gmd:MD_RestrictionCode>
							</gmd:accessConstraints>
							<gmd:useConstraints>
								<gmd:MD_RestrictionCode>
									<xsl:if test="$var2374_metadata/metainfo/metuc">
										<xsl:attribute name="codeList"><xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode'))"/></xsl:attribute>
									</xsl:if>
									<xsl:if test="$var2374_metadata/metainfo/metuc">
										<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string(xs:anyURI('otherRestrictions'))"/></xsl:attribute>
									</xsl:if>
									<xsl:if test="$var2374_metadata/metainfo/metuc">
										<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string(xs:anyURI('008'))"/></xsl:attribute>
									</xsl:if>
								</gmd:MD_RestrictionCode>
							</gmd:useConstraints>
							<gmd:otherConstraints>
								<xsl:variable name="var2378_cond_result_exists" as="xs:string?">
									<xsl:choose>
										<xsl:when test="$var2374_metadata/metainfo/metuc">
											<xsl:for-each select="$var2374_metadata/metainfo/metuc">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:when>
										<xsl:otherwise>
											<xsl:sequence select="' '"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:if test="fn:exists($var2378_cond_result_exists)">
									<gco:CharacterString>
										<xsl:variable name="var2379_cond_result_exists" as="xs:string" select="(if (fn:exists($var2374_metadata/metainfo/metuc)) then ' Metadata Use Constraints: ' else ' ')"/>
										<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat('Metadata Access Constraints: ', xs:string(.)), $var2379_cond_result_exists), $var2378_cond_result_exists))"/>
									</gco:CharacterString>
								</xsl:if>
							</gmd:otherConstraints>
						</gmd:MD_LegalConstraints>
					</gmd:metadataConstraints>
				</xsl:for-each>
			</xsl:for-each>
			<!-- security constraints -->
			<xsl:for-each select="$var_metadataRoot/metainfo/metsi">
				<xsl:variable name="var_lookupSecurityClassType" as="xs:string?">
					<xsl:call-template name="vmf:securityClassType">
						<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(metsc)))"/>
					</xsl:call-template>
				</xsl:variable>
				<gmd:metadataConstraints>
					<gmd:MD_SecurityConstraints>
						<xsl:choose>
							<xsl:when test="fn:exists($var_lookupSecurityClassType) and string-length(xs:string($var_lookupSecurityClassType))>0">
								<gmd:classification>
									<gmd:MD_ClassificationCode>
										<xsl:attribute name="codeListValue"><xsl:sequence select="xs:string($var_lookupSecurityClassType)"/></xsl:attribute>
										<xsl:attribute name="codeList"><xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ClassificationCode'))"/></xsl:attribute>
										<xsl:variable name="var2388_result_securityClassCode" as="xs:string?">
											<xsl:call-template name="vmf:securityClassCode">
												<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(metsc)))"/>
											</xsl:call-template>
										</xsl:variable>
										<xsl:variable name="var2387_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2388_result_securityClassCode)) then $var2388_result_securityClassCode else ())"/>
										<xsl:if test="fn:exists($var2387_cond_result_exists)">
											<xsl:attribute name="codeSpace"><xsl:sequence select="xs:string($var2387_cond_result_exists)"/></xsl:attribute>
										</xsl:if>
									</gmd:MD_ClassificationCode>
								</gmd:classification>
							</xsl:when>
							<xsl:otherwise>
								<gmd:classification gco:nilReason="missing"/>
							</xsl:otherwise>
						</xsl:choose>
						<xsl:if test="fn:exists(metscs) and string-length(xs:string(metscs))>0">
							<gmd:classificationSystem>
								<gco:CharacterString>
									<xsl:sequence select="xs:string(metscs)"/>
								</gco:CharacterString>
							</gmd:classificationSystem>
						</xsl:if>
					</gmd:MD_SecurityConstraints>
				</gmd:metadataConstraints>
			</xsl:for-each>
			<!-- metadata maintenance -->
			<gmd:metadataMaintenance>
				<gmd:MD_MaintenanceInformation>
					<gmd:maintenanceAndUpdateFrequency>
						<xsl:attribute name="gco:nilReason"><xsl:sequence select="xs:string(xs:string('unknown'))"/></xsl:attribute>
					</gmd:maintenanceAndUpdateFrequency>
					<xsl:for-each select="$var_metadataRoot/metainfo/metfrd">
						<gmd:dateOfNextUpdate>
							<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unpublished'))">
								<xsl:attribute name="gco:nilReason"><xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(xs:string(.))))))"/></xsl:attribute>
							</xsl:if>
							<xsl:variable name="var2392_cond_result_logicalor" as="xs:string?">
								<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'present')))">
									<xsl:variable name="var2397_map_result_distinctvalues" as="xs:string*">
										<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
											<xsl:choose>
												<xsl:when test="fn:ends-with(., '-')">
													<xsl:if test="fn:ends-with(., '-')">
														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
														</xsl:if>
													</xsl:if>
												</xsl:when>
												<xsl:otherwise>
													<xsl:sequence select="."/>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:for-each>
									</xsl:variable>
									<xsl:variable name="var2396_map_result_distinctvalues" as="xs:string*">
										<xsl:for-each select="fn:distinct-values($var2397_map_result_distinctvalues)">
											<xsl:variable name="var2402_cond_result_endswith" as="xs:string?">
												<xsl:choose>
													<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
														<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
															<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
															</xsl:if>
														</xsl:if>
													</xsl:when>
													<xsl:otherwise>
														<xsl:sequence select="."/>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:variable>
											<xsl:if test="fn:exists($var2402_cond_result_endswith)">
												<xsl:sequence select="$var2402_cond_result_endswith"/>
											</xsl:if>
										</xsl:for-each>
									</xsl:variable>
									<xsl:if test="fn:exists($var2396_map_result_distinctvalues)">
										<xsl:sequence select="fn:string-join($var2396_map_result_distinctvalues, ' ')"/>
									</xsl:if>
								</xsl:if>
							</xsl:variable>
							<xsl:for-each select="$var2392_cond_result_logicalor">
								<gco:Date>
									<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
								</gco:Date>
							</xsl:for-each>
						</gmd:dateOfNextUpdate>
					</xsl:for-each>
					<gmd:maintenanceNote>
						<xsl:for-each select="$var_metadataRoot">
							<xsl:variable name="var2413_map_select_metadata">
								<xsl:variable name="var_DateTemp" as="xs:string">
									<xsl:call-template name="usgin:TimePositionFormat">
										<xsl:with-param name="inputDate" select="(metainfo/metrd)"/>
										<xsl:with-param name="inputTime" select="()"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:if test="fn:exists($var_DateTemp)">
									<xsl:value-of select="fn:string($var_DateTemp)"/>
								</xsl:if>
								<!-- metadata review date; if present will be concatenated with the maintenance note -->:
								<!--xsl:for-each select="$var_metadataRoot/metainfo/metrd">
									<xsl:variable name="var2417_cond_result_logicalor" as="xs:string?">
										<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
											<xsl:variable name="var2422_map_result_distinctvalues" as="xs:string*">
												<xsl:for-each select="fn:distinct-values(if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), 0, 5), '-', fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), 5, 2), '-', fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), 7,2)))">
													<xsl:choose>
														<xsl:when test="fn:ends-with(., '-')">
															<xsl:if test="fn:ends-with(., '-')">
																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																</xsl:if>
															</xsl:if>
														</xsl:when>
														<xsl:otherwise>
															<xsl:sequence select="."/>
														</xsl:otherwise>
													</xsl:choose>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var2421_map_result_distinctvalues" as="xs:string*">
												<xsl:for-each select="fn:distinct-values($var2422_map_result_distinctvalues)">
													<xsl:variable name="var2427_cond_result_endswith" as="xs:string?">
														<xsl:choose>
															<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																	<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																		<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																	</xsl:if>
																</xsl:if>
															</xsl:when>
															<xsl:otherwise>
																<xsl:sequence select="."/>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:if test="fn:exists($var2427_cond_result_endswith)">
														<xsl:sequence select="$var2427_cond_result_endswith"/>
													</xsl:if>
												</xsl:for-each>
											</xsl:variable>
											<xsl:if test="fn:exists($var2421_map_result_distinctvalues)">
												<xsl:sequence select="fn:string-join($var2421_map_result_distinctvalues, ' ')"/>
											</xsl:if>
										</xsl:if>
									</xsl:variable>
									<xsl:for-each select="$var2417_cond_result_logicalor">
										<xsl:value-of select="fn:string(fn:normalize-space(.))"/>
									</xsl:for-each>
								</xsl:for-each -->
							</xsl:variable>
							<xsl:variable name="var2411_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2413_map_select_metadata)) then $var2413_map_select_metadata else ' ')"/>
							<xsl:if test="fn:exists($var2411_cond_result_exists)">
								<gco:CharacterString>
									<xsl:variable name="var2412_cond_result_exists" as="xs:string" select="(if (fn:exists($var_metadataRoot/metainfo/metrd)) then ' Most recent metadata content review date: ' else ' ')"/>
									<xsl:sequence select="fn:normalize-space(fn:string(fn:concat('This metadata was automatically generated from the ', xs:string(metainfo/metstdn), ' standard, version ', xs:string(metainfo/metstdv), ' using the August 2011-REH version of the FGDC CSDGM to ISO 19115-2 transform modified and updatated by SMR 2012-02-02 to generate USGIN compatible ISO19139 XML. ', $var2412_cond_result_exists, $var2411_cond_result_exists)))"/>
								</gco:CharacterString>
							</xsl:if>
						</xsl:for-each>
					</gmd:maintenanceNote>
					<gmd:contact>
						<gmd:CI_ResponsibleParty>
							<gmd:positionName>
								<gco:CharacterString>USGIN/NGDS metadata editor</gco:CharacterString>
							</gmd:positionName>
							<gmd:contactInfo>
								<gmd:CI_Contact>
									<gmd:address>
										<gmd:CI_Address>
											<gmd:electronicMailAddress>
												<gco:CharacterString>metadata@usgin.org</gco:CharacterString>
											</gmd:electronicMailAddress>
										</gmd:CI_Address>
									</gmd:address>
								</gmd:CI_Contact>
							</gmd:contactInfo>
							<gmd:role>
								<gmd:CI_RoleCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode" codeListValue="processor" codeSpace="007">processor</gmd:CI_RoleCode>
							</gmd:role>
						</gmd:CI_ResponsibleParty>
					</gmd:contact>
				</gmd:MD_MaintenanceInformation>
			</gmd:metadataMaintenance>
		</gmd:MD_Metadata>
	</xsl:template>
	<!-- Map projection display handlers, this stuff gets put in the abstract -->
	<!-- Map Projections -->
	<xsl:template match="albers | equicon | lambertc">
		<xsl:apply-templates select="stdparll"/>
		<xsl:apply-templates select="longcm"/>
		<xsl:apply-templates select="latprjo"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="gnomonic | lamberta | orthogr | stereo | gvnsp">
		<xsl:for-each select="../gvnsp">
			<xsl:apply-templates select="heightpt"/>
		</xsl:for-each>
		<xsl:apply-templates select="longpc"/>
		<xsl:apply-templates select="latprjc"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="azimequi | polycon | transmer">
		<xsl:for-each select="../transmer">
			<xsl:apply-templates select="sfctrmer"/>
		</xsl:for-each>
		<xsl:apply-templates select="longcm"/>
		<xsl:apply-templates select="latprjo"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="miller | sinusoid | vdgrin">
		<xsl:for-each select="../equirect">
			<xsl:apply-templates select="stdparll"/>
		</xsl:for-each>
		<xsl:for-each select="../mercator">
			<xsl:apply-templates select="stdparll"/>
			<xsl:apply-templates select="sfequat"/>
		</xsl:for-each>
		<xsl:apply-templates select="longcm"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="equirect">
		<xsl:apply-templates select="stdparll"/>
		<xsl:apply-templates select="longcm"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="mercator">
		<xsl:apply-templates select="stdparll"/>
		<xsl:apply-templates select="sfequat"/>
		<xsl:apply-templates select="longcm"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="polarst">
		<xsl:apply-templates select="svlong"/>
		<xsl:apply-templates select="stdparll"/>
		<xsl:apply-templates select="sfprjorg"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="obqmerc">
		<xsl:apply-templates select="sfctrlin"/>
		<xsl:apply-templates select="obqlazim"/>
		<xsl:apply-templates select="obqlpt"/>
		<xsl:apply-templates select="latprjo"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="spaceobq">
		<xsl:apply-templates select="landsat"/>
		<xsl:apply-templates select="pathnum"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="robinson">
		<xsl:apply-templates select="longpc"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="modsak">
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<!-- Map Projection Parameters -->
	<xsl:template match="stdparll">
			Standard_Parallel: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="longcm">
			Longitude_of_Central_Meridian: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="latprjo">
			Latitude_of_Projection_Origin: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="feast">
			False_Easting: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="fnorth">
			False_Northing: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="sfequat">
			Scale_Factor_at_Equator: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="heightpt">
			Height_of_Perspective_Point_Above_Surface: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="longpc">
			Longitude_of_Projection_Center: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="latprjc">
			Latitude_of_Projection_Center: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="sfctrlin">
			Scale_Factor_at_Center_Line: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="obqlazim">
			Oblique_Line_Azimuth: <xsl:value-of select="."/>
		<xsl:for-each select="azimangl">
				Azimuthal_Angle:  <xsl:value-of select="."/>
		</xsl:for-each>
		<xsl:for-each select="azimptl">
				Azimuthal_Measure_Point_Longitude:  <xsl:value-of select="."/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template match="obqlpt">
			Oblique_Line_Point: 
			<xsl:value-of select="."/>
		<xsl:for-each select="obqllat">
				Oblique_Line_Latitude:  <xsl:value-of select="."/>
		</xsl:for-each>
		<xsl:for-each select="obqllong">
				Oblique_Line_Longitude:  <xsl:value-of select="."/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template match="svlong">
			Straight_Vertical_Longitude_from_Pole: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="sfprjorg">
			Scale_Factor_at_Projection_Origin: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="landsat">
			Landsat_Number: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="pathnum">
			Path_Number: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="sfctrmer">
			Scale_Factor_at_Central_Meridian: 
			<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="otherprj">
	Other_Projection's_Definition: 
<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="attr">
		<!-- template to handle attributes of attributes, don't allow recursion -->
			Attribute Label: <xsl:value-of select="attrlabl"/>
				Definition: <xsl:value-of select="attrdef"/>
				Source: <xsl:value-of select="attrdefs"/>
				Attribute of Attribute Domain: <xsl:for-each select="attrdomv">
					Attribute_Domain_Values: <xsl:for-each select="edom">
							Enumerated_Domain: <xsl:for-each select="edomv">
									Value: <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="edomvd">
									Value_Definition:  <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="edomvds">
									Value_Definition_Source:  <xsl:value-of select="."/>
				</xsl:for-each>
			</xsl:for-each>
			<!-- end enumerated domain -->
			<xsl:for-each select="rdom">
							Range_Domain: <xsl:for-each select="rdommin">
									Range_Minimum:  <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="rdommax">
									Range_Maximum:  <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="attrunit">
										Units_of_Measure:  <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="attrmres">
										Attribute_Measurement_Resolution:  <xsl:value-of select="."/>
				</xsl:for-each>
			</xsl:for-each>
			<xsl:for-each select="codesetd">
							Codeset Domain: <xsl:for-each select="codesetn">
								Codeset Name:  <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="codesets">
								Codeset Source:  <xsl:value-of select="."/>
				</xsl:for-each>
			</xsl:for-each>
			<xsl:for-each select="udom">
							Unrepresentable Domain:  <xsl:value-of select="."/>
			</xsl:for-each>
		</xsl:for-each>
	</xsl:template>
</xsl:stylesheet>
